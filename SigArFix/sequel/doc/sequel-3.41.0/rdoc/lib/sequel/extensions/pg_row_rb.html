<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=CP850" http-equiv="Content-Type" />

  <title>File: pg_row.rb [sequel-3.41.0 Documentation]</title>

  <link type="text/css" media="screen" href="../../../rdoc.css" rel="stylesheet" />

  <script src="../../../js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>
</head>

<body class="file file-popup">
  <div id="metadata">
    <dl>
      <dt class="modified-date">Last Modified</dt>
      <dd class="modified-date">2012-11-14 23:59:15 +0100</dd>

      
      <dt class="requires">Requires</dt>
      <dd class="requires">
        <ul>
        
          <li>delegate</li>
        
          <li>strscan</li>
        
          <li>adapters/utils/pg_types</li>
        
        </ul>
      </dd>
      

      
    </dl>
  </div>

  <div id="documentation">
    
    <div class="description">
      <h2>Description</h2>
      
<p>The pg_row extension adds support for <a
href="../../../Sequel.html">Sequel</a> to handle PostgreSQL's
row-valued/composite types.</p>

<p>This extension integrates with Sequel's native postgres adapter, so that
when composite fields are retrieved, they are parsed and returned as
instances of Sequel::Postgres::PGRow::(HashRow|ArrayRow), or optionally a
custom type.  HashRow and ArrayRow are DelegateClasses of of <a
href="../../../Hash.html">Hash</a> and <a
href="../../../Array.html">Array</a>, so they mostly act like a hash or
array, but not completely (is_a?(<a href="../../../Hash.html">Hash</a>) and
is_a?(<a href="../../../Array.html">Array</a>) are false).  If you want the
actual hash for a HashRow, call HashRow#to_hash, and if you want the actual
array for an ArrayRow, call ArrayRow#to_a.  This is done so that <a
href="../../../Sequel.html">Sequel</a> does not treat a values like an <a
href="../../../Array.html">Array</a> or <a
href="../../../Hash.html">Hash</a> by default, which would cause issues.</p>

<p>In addition to the parsers, this extension comes with literalizers for
HashRow and ArrayRow using the standard <a
href="../../../Sequel.html">Sequel</a> literalization callbacks, so they
work with on all adapters.</p>

<p>The first thing you are going to want to do is to load the extension into
your Database object.  Make sure you load the :pg_array extension first if
you plan to use composite types in bound variables:</p>

<pre>DB.extension(:pg_array, :pg_row)</pre>

<p>You can create an anonymous row type by calling the Sequel.pg_row with an
array:</p>

<pre>Sequel.pg_row(array)</pre>

<p>If you have loaded the <a
href="../../../files/doc/core_extensions_rdoc.html">core_extensions
extension</a>), you can also use <a
href="../../../Array.html#method-i-pg_row">Array#pg_row</a>:</p>

<pre>array.pg_row</pre>

<p>However, in most cases you are going to want something beyond anonymous row
types.  This extension allows you to register row types on a per database
basis, using Database#register_row_type:</p>

<pre>DB.register_row_type(:foo)</pre>

<p>When you register the row type, <a href="../../../Sequel.html">Sequel</a>
will query the PostgreSQL system tables to find the related metadata, and
will setup a custom HashRow subclass for that type.  This includes looking
up conversion procs for each column in the type, so that when the composite
type is returned from the database, the members of the type have the
correct type.  Additionally, if the composite type also has an array form,
<a href="../../../Sequel.html">Sequel</a> registers an array type for the
composite type, so that array columns of the composite type are converted
correctly.</p>

<p>You can then create values of that type by using Database#row_type:</p>

<pre>DB.row_type(:address, ['123 Sesame St.', 'Some City', '12345'])</pre>

<p>Let's say table address has columns street, city, and zip.  This would
return something similar to:</p>

<pre>{:street=&gt;'123 Sesame St.', :city=&gt;'Some City', :zip=&gt;'12345'}</pre>

<p>You can also use a hash:</p>

<pre>DB.row_type(:address, :street=&gt;'123 Sesame St.', :city=&gt;'Some City', :zip=&gt;'12345')</pre>

<p>So if you have a person table that has an address column, here's how you
could insert into the column:</p>

<pre>DB[:table].insert(:address=&gt;DB.row_type(:address, :street=&gt;'123 Sesame St.', :city=&gt;'Some City', :zip=&gt;'12345'))</pre>

<p>This extension requires both the strscan and delegate libraries.</p>

    </div>
    
  </div>
</body>
</html>

