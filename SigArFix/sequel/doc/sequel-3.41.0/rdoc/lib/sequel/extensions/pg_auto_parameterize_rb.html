<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=CP850" http-equiv="Content-Type" />

  <title>File: pg_auto_parameterize.rb [sequel-3.41.0 Documentation]</title>

  <link type="text/css" media="screen" href="../../../rdoc.css" rel="stylesheet" />

  <script src="../../../js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../../js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>
</head>

<body class="file file-popup">
  <div id="metadata">
    <dl>
      <dt class="modified-date">Last Modified</dt>
      <dd class="modified-date">2012-11-14 23:59:15 +0100</dd>

      
      <dt class="requires">Requires</dt>
      <dd class="requires">
        <ul>
        
        </ul>
      </dd>
      

      
    </dl>
  </div>

  <div id="documentation">
    
    <div class="description">
      <h2>Description</h2>
      
<p>This extension allows Sequel's postgres adapter to automatically
parameterize all common queries.  Sequel's default behavior has always been
to literalize all arguments unless specifically using parameters (via :$arg
placeholders and the prepare/call methods). This extension makes <a
href="../../../Sequel.html">Sequel</a> take all string, numeric, date, and
time types and automatically turn them into parameters. Example:</p>

<pre># Default
DB[:test].where(:a=&gt;1)
# SQL: SELECT * FROM test WHERE a = 1

DB.extension :pg_auto_parameterize
DB[:test].where(:a=&gt;1)
# SQL: SELECT * FROM test WHERE a = $1 (args: [1])</pre>

<p>This extension is not necessarily faster or more safe than the default
behavior.  In some cases it is faster, such as when using large strings. 
However, there are also some known issues with this approach:</p>
<ol><li>
<p>Because of the way it operates, it has no context to make a determination
about whether to literalize an object or not. For example, if it comes
across an integer, it will turn it into a parameter.  That breaks code such
as:</p>

<pre>DB[:table].select(:a, :b).order(2, 1)</pre>

<p>Since it will use the following SQL (which isn't valid):</p>

<pre>SELECT a, b FROM table ORDER BY $1, $2</pre>

<p>To work around this, you can either specify the columns manually or use a
literal string:</p>

<pre>DB[:table].select(:a, :b).order(:b, :a)
DB[:table].select(:a, :b).order(Sequel.lit('2, 1'))</pre>
</li><li>
<p>In order to avoid many type errors, it attempts to guess the appropriate
type and automatically casts all placeholders. Unfortunately, if the type
guess is incorrect, the query will be rejected.  For example, the following
works without automatic parameterization, but fails with it:</p>

<pre>DB[:table].insert(:interval=&gt;'1 day')</pre>

<p>To work around this, you can just add the necessary casts manually:</p>

<pre>DB[:table].insert(:interval=&gt;'1 day'.cast(:interval))</pre>
</li></ol>

<p>You can also work around any issues that come up by disabling automatic
parameterization by calling the no_auto_parameterize method on the dataset
(which returns a clone of the dataset).</p>

<p>It is likely there are other corner cases I am not yet aware of when using
this extension, so use this extension with caution.</p>

<p>This extension is only compatible when using the pg driver, not when using
the old postgres driver or the postgres-pr driver.</p>

    </div>
    
  </div>
</body>
</html>

