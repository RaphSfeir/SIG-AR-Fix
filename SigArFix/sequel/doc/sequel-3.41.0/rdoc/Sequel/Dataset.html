<?xml version="1.0" encoding="CP850"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=CP850" http-equiv="Content-Type" />

  <title>Class: Sequel::Dataset</title>

  <link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../lib/sequel/adapters/utils/stored_procedures_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/adapters/utils/stored_procedures.rb">lib/sequel/adapters/utils/stored_procedures.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/actions_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/actions.rb">lib/sequel/dataset/actions.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/features_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/features.rb">lib/sequel/dataset/features.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/graph_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/graph.rb">lib/sequel/dataset/graph.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/misc_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/misc.rb">lib/sequel/dataset/misc.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/mutation_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/mutation.rb">lib/sequel/dataset/mutation.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/prepared_statements_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/prepared_statements.rb">lib/sequel/dataset/prepared_statements.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/query_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/query.rb">lib/sequel/dataset/query.rb</a></li>
          
            <li><a href="../lib/sequel/dataset/sql_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset/sql.rb">lib/sequel/dataset/sql.rb</a></li>
          
            <li><a href="../lib/sequel/dataset_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/dataset.rb">lib/sequel/dataset.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/columns_introspection_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/columns_introspection.rb">lib/sequel/extensions/columns_introspection.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/null_dataset_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/null_dataset.rb">lib/sequel/extensions/null_dataset.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/pagination_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/pagination.rb">lib/sequel/extensions/pagination.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/pretty_table_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/pretty_table.rb">lib/sequel/extensions/pretty_table.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/query_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/query.rb">lib/sequel/extensions/query.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/select_remove_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/select_remove.rb">lib/sequel/extensions/select_remove.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/split_array_nil_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/split_array_nil.rb">lib/sequel/extensions/split_array_nil.rb</a></li>
          
            <li><a href="../lib/sequel/extensions/to_dot_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/sequel/extensions/to_dot.rb">lib/sequel/extensions/to_dot.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="../Object.html">Object</a></p>
        
      </div>
      

      
      <!-- Sections -->
      <div id="sections-section" class="section">
        <h3 class="section-header">Sections</h3>
        <ul class="link-list">
          
            <li><a href="#5Buntitled-5D"></a></li>
          
            <li><a href="#1+-+Methods+that+return+modified+datasets">1 - Methods that return modified datasets</a></li>
          
            <li><a href="#2+-+Methods+that+execute+code+on+the+database">2 - Methods that execute code on the database</a></li>
          
            <li><a href="#3+-+User+Methods+relating+to+SQL+Creation">3 - User Methods relating to SQL Creation</a></li>
          
            <li><a href="#4+-+Methods+that+describe+what+the+dataset+supports">4 - Methods that describe what the dataset supports</a></li>
          
            <li><a href="#5+-+Methods+related+to+dataset+graphing">5 - Methods related to dataset graphing</a></li>
          
            <li><a href="#6+-+Miscellaneous+methods">6 - Miscellaneous methods</a></li>
          
            <li><a href="#7+-+Mutation+methods">7 - Mutation methods</a></li>
          
            <li><a href="#8+-+Methods+related+to+prepared+statements+or+bound+variables">8 - Methods related to prepared statements or bound variables</a></li>
          
            <li><a href="#9+-+Internal+Methods+relating+to+SQL+Creation">9 - Internal Methods relating to SQL Creation</a></li>
          
        </ul>
      </div>
      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">MODULE</span> <a href="Dataset/ArgumentMapper.html">Sequel::Dataset::ArgumentMapper</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/NullDataset.html">Sequel::Dataset::NullDataset</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/Pagination.html">Sequel::Dataset::Pagination</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/PreparedStatementMethods.html">Sequel::Dataset::PreparedStatementMethods</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/QueryBlockCopy.html">Sequel::Dataset::QueryBlockCopy</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/SplitArrayNil.html">Sequel::Dataset::SplitArrayNil</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/StoredProcedureMethods.html">Sequel::Dataset::StoredProcedureMethods</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/StoredProcedures.html">Sequel::Dataset::StoredProcedures</a></li>
          
          <li><span class="type">MODULE</span> <a href="Dataset/UnnumberedArgumentMapper.html">Sequel::Dataset::UnnumberedArgumentMapper</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-clause_methods">::clause_methods</a></li>
          
          <li><a href="#method-c-def_append_methods">::def_append_methods</a></li>
          
          <li><a href="#method-c-def_mutation_method">::def_mutation_method</a></li>
          
          <li><a href="#method-c-introspect_all_columns">::introspect_all_columns</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-register_extension">::register_extension</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-_import">#_import</a></li>
          
          <li><a href="#method-i-_insert_sql">#_insert_sql</a></li>
          
          <li><a href="#method-i-_select_map_multiple">#_select_map_multiple</a></li>
          
          <li><a href="#method-i-_select_map_single">#_select_map_single</a></li>
          
          <li><a href="#method-i-_update_sql">#_update_sql</a></li>
          
          <li><a href="#method-i-add_graph_aliases">#add_graph_aliases</a></li>
          
          <li><a href="#method-i-aliased_expression_sql_append">#aliased_expression_sql_append</a></li>
          
          <li><a href="#method-i-all">#all</a></li>
          
          <li><a href="#method-i-and">#and</a></li>
          
          <li><a href="#method-i-array_sql_append">#array_sql_append</a></li>
          
          <li><a href="#method-i-avg">#avg</a></li>
          
          <li><a href="#method-i-bind">#bind</a></li>
          
          <li><a href="#method-i-boolean_constant_sql_append">#boolean_constant_sql_append</a></li>
          
          <li><a href="#method-i-call">#call</a></li>
          
          <li><a href="#method-i-case_expression_sql_append">#case_expression_sql_append</a></li>
          
          <li><a href="#method-i-cast_sql_append">#cast_sql_append</a></li>
          
          <li><a href="#method-i-clone">#clone</a></li>
          
          <li><a href="#method-i-column_all_sql_append">#column_all_sql_append</a></li>
          
          <li><a href="#method-i-columns">#columns</a></li>
          
          <li><a href="#method-i-columns-21">#columns!</a></li>
          
          <li><a href="#method-i-columns_without_introspection">#columns_without_introspection</a></li>
          
          <li><a href="#method-i-complex_expression_sql_append">#complex_expression_sql_append</a></li>
          
          <li><a href="#method-i-compound_clone">#compound_clone</a></li>
          
          <li><a href="#method-i-compound_from_self">#compound_from_self</a></li>
          
          <li><a href="#method-i-constant_sql_append">#constant_sql_append</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-def_mutation_method">#def_mutation_method</a></li>
          
          <li><a href="#method-i-delayed_evaluation_sql_append">#delayed_evaluation_sql_append</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_sql">#delete_sql</a></li>
          
          <li><a href="#method-i-distinct">#distinct</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_page">#each_page</a></li>
          
          <li><a href="#method-i-each_server">#each_server</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-emulated_function_sql_append">#emulated_function_sql_append</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-except">#except</a></li>
          
          <li><a href="#method-i-exclude">#exclude</a></li>
          
          <li><a href="#method-i-exclude_having">#exclude_having</a></li>
          
          <li><a href="#method-i-exclude_where">#exclude_where</a></li>
          
          <li><a href="#method-i-exists">#exists</a></li>
          
          <li><a href="#method-i-extension">#extension</a></li>
          
          <li><a href="#method-i-extension-21">#extension!</a></li>
          
          <li><a href="#method-i-fetch_rows">#fetch_rows</a></li>
          
          <li><a href="#method-i-filter">#filter</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-first_source">#first_source</a></li>
          
          <li><a href="#method-i-first_source_alias">#first_source_alias</a></li>
          
          <li><a href="#method-i-first_source_table">#first_source_table</a></li>
          
          <li><a href="#method-i-for_update">#for_update</a></li>
          
          <li><a href="#method-i-from">#from</a></li>
          
          <li><a href="#method-i-from_self">#from_self</a></li>
          
          <li><a href="#method-i-function_sql_append">#function_sql_append</a></li>
          
          <li><a href="#method-i-get">#get</a></li>
          
          <li><a href="#method-i-graph">#graph</a></li>
          
          <li><a href="#method-i-grep">#grep</a></li>
          
          <li><a href="#method-i-group">#group</a></li>
          
          <li><a href="#method-i-group_and_count">#group_and_count</a></li>
          
          <li><a href="#method-i-group_by">#group_by</a></li>
          
          <li><a href="#method-i-group_cube">#group_cube</a></li>
          
          <li><a href="#method-i-group_rollup">#group_rollup</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-having">#having</a></li>
          
          <li><a href="#method-i-identifier_input_method">#identifier_input_method</a></li>
          
          <li><a href="#method-i-identifier_output_method">#identifier_output_method</a></li>
          
          <li><a href="#method-i-import">#import</a></li>
          
          <li><a href="#method-i-insert">#insert</a></li>
          
          <li><a href="#method-i-insert_multiple">#insert_multiple</a></li>
          
          <li><a href="#method-i-insert_sql">#insert_sql</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-intersect">#intersect</a></li>
          
          <li><a href="#method-i-interval">#interval</a></li>
          
          <li><a href="#method-i-invert">#invert</a></li>
          
          <li><a href="#method-i-join">#join</a></li>
          
          <li><a href="#method-i-join_clause_sql_append">#join_clause_sql_append</a></li>
          
          <li><a href="#method-i-join_on_clause_sql_append">#join_on_clause_sql_append</a></li>
          
          <li><a href="#method-i-join_table">#join_table</a></li>
          
          <li><a href="#method-i-join_using_clause_sql_append">#join_using_clause_sql_append</a></li>
          
          <li><a href="#method-i-last">#last</a></li>
          
          <li><a href="#method-i-limit">#limit</a></li>
          
          <li><a href="#method-i-literal_append">#literal_append</a></li>
          
          <li><a href="#method-i-lock_style">#lock_style</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-max">#max</a></li>
          
          <li><a href="#method-i-min">#min</a></li>
          
          <li><a href="#method-i-multi_insert">#multi_insert</a></li>
          
          <li><a href="#method-i-multi_insert_sql">#multi_insert_sql</a></li>
          
          <li><a href="#method-i-naked">#naked</a></li>
          
          <li><a href="#method-i-naked-21">#naked!</a></li>
          
          <li><a href="#method-i-negative_boolean_constant_sql_append">#negative_boolean_constant_sql_append</a></li>
          
          <li><a href="#method-i-nullify">#nullify</a></li>
          
          <li><a href="#method-i-nullify-21">#nullify!</a></li>
          
          <li><a href="#method-i-options_overlap">#options_overlap</a></li>
          
          <li><a href="#method-i-or">#or</a></li>
          
          <li><a href="#method-i-order">#order</a></li>
          
          <li><a href="#method-i-order_append">#order_append</a></li>
          
          <li><a href="#method-i-order_by">#order_by</a></li>
          
          <li><a href="#method-i-order_more">#order_more</a></li>
          
          <li><a href="#method-i-order_prepend">#order_prepend</a></li>
          
          <li><a href="#method-i-ordered_expression_sql_append">#ordered_expression_sql_append</a></li>
          
          <li><a href="#method-i-paginate">#paginate</a></li>
          
          <li><a href="#method-i-placeholder_literal_string_sql_append">#placeholder_literal_string_sql_append</a></li>
          
          <li><a href="#method-i-prepare">#prepare</a></li>
          
          <li><a href="#method-i-print">#print</a></li>
          
          <li><a href="#method-i-provides_accurate_rows_matched-3F">#provides_accurate_rows_matched?</a></li>
          
          <li><a href="#method-i-qualified_identifier_sql_append">#qualified_identifier_sql_append</a></li>
          
          <li><a href="#method-i-qualify">#qualify</a></li>
          
          <li><a href="#method-i-qualify_to">#qualify_to</a></li>
          
          <li><a href="#method-i-qualify_to_first_source">#qualify_to_first_source</a></li>
          
          <li><a href="#method-i-query">#query</a></li>
          
          <li><a href="#method-i-quote_identifier_append">#quote_identifier_append</a></li>
          
          <li><a href="#method-i-quote_identifiers-3F">#quote_identifiers?</a></li>
          
          <li><a href="#method-i-quote_schema_table_append">#quote_schema_table_append</a></li>
          
          <li><a href="#method-i-quoted_identifier_append">#quoted_identifier_append</a></li>
          
          <li><a href="#method-i-range">#range</a></li>
          
          <li><a href="#method-i-recursive_cte_requires_column_aliases-3F">#recursive_cte_requires_column_aliases?</a></li>
          
          <li><a href="#method-i-requires_placeholder_type_specifiers-3F">#requires_placeholder_type_specifiers?</a></li>
          
          <li><a href="#method-i-requires_sql_standard_datetimes-3F">#requires_sql_standard_datetimes?</a></li>
          
          <li><a href="#method-i-returning">#returning</a></li>
          
          <li><a href="#method-i-reverse">#reverse</a></li>
          
          <li><a href="#method-i-reverse_order">#reverse_order</a></li>
          
          <li><a href="#method-i-row_number_column">#row_number_column</a></li>
          
          <li><a href="#method-i-schema_and_table">#schema_and_table</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-select_all">#select_all</a></li>
          
          <li><a href="#method-i-select_append">#select_append</a></li>
          
          <li><a href="#method-i-select_group">#select_group</a></li>
          
          <li><a href="#method-i-select_hash">#select_hash</a></li>
          
          <li><a href="#method-i-select_hash_groups">#select_hash_groups</a></li>
          
          <li><a href="#method-i-select_map">#select_map</a></li>
          
          <li><a href="#method-i-select_more">#select_more</a></li>
          
          <li><a href="#method-i-select_order_map">#select_order_map</a></li>
          
          <li><a href="#method-i-select_remove">#select_remove</a></li>
          
          <li><a href="#method-i-select_sql">#select_sql</a></li>
          
          <li><a href="#method-i-server">#server</a></li>
          
          <li><a href="#method-i-set">#set</a></li>
          
          <li><a href="#method-i-set_defaults">#set_defaults</a></li>
          
          <li><a href="#method-i-set_graph_aliases">#set_graph_aliases</a></li>
          
          <li><a href="#method-i-set_overrides">#set_overrides</a></li>
          
          <li><a href="#method-i-simple_select_all-3F">#simple_select_all?</a></li>
          
          <li><a href="#method-i-single_record">#single_record</a></li>
          
          <li><a href="#method-i-single_value">#single_value</a></li>
          
          <li><a href="#method-i-split_alias">#split_alias</a></li>
          
          <li><a href="#method-i-sql">#sql</a></li>
          
          <li><a href="#method-i-subscript_sql_append">#subscript_sql_append</a></li>
          
          <li><a href="#method-i-sum">#sum</a></li>
          
          <li><a href="#method-i-supports_cte-3F">#supports_cte?</a></li>
          
          <li><a href="#method-i-supports_cte_in_subqueries-3F">#supports_cte_in_subqueries?</a></li>
          
          <li><a href="#method-i-supports_distinct_on-3F">#supports_distinct_on?</a></li>
          
          <li><a href="#method-i-supports_group_cube-3F">#supports_group_cube?</a></li>
          
          <li><a href="#method-i-supports_group_rollup-3F">#supports_group_rollup?</a></li>
          
          <li><a href="#method-i-supports_insert_select-3F">#supports_insert_select?</a></li>
          
          <li><a href="#method-i-supports_intersect_except-3F">#supports_intersect_except?</a></li>
          
          <li><a href="#method-i-supports_intersect_except_all-3F">#supports_intersect_except_all?</a></li>
          
          <li><a href="#method-i-supports_is_true-3F">#supports_is_true?</a></li>
          
          <li><a href="#method-i-supports_join_using-3F">#supports_join_using?</a></li>
          
          <li><a href="#method-i-supports_modifying_joins-3F">#supports_modifying_joins?</a></li>
          
          <li><a href="#method-i-supports_multiple_column_in-3F">#supports_multiple_column_in?</a></li>
          
          <li><a href="#method-i-supports_ordered_distinct_on-3F">#supports_ordered_distinct_on?</a></li>
          
          <li><a href="#method-i-supports_regexp-3F">#supports_regexp?</a></li>
          
          <li><a href="#method-i-supports_returning-3F">#supports_returning?</a></li>
          
          <li><a href="#method-i-supports_select_all_and_column-3F">#supports_select_all_and_column?</a></li>
          
          <li><a href="#method-i-supports_timestamp_timezones-3F">#supports_timestamp_timezones?</a></li>
          
          <li><a href="#method-i-supports_timestamp_usecs-3F">#supports_timestamp_usecs?</a></li>
          
          <li><a href="#method-i-supports_where_true-3F">#supports_where_true?</a></li>
          
          <li><a href="#method-i-supports_window_functions-3F">#supports_window_functions?</a></li>
          
          <li><a href="#method-i-to_csv">#to_csv</a></li>
          
          <li><a href="#method-i-to_dot">#to_dot</a></li>
          
          <li><a href="#method-i-to_hash">#to_hash</a></li>
          
          <li><a href="#method-i-to_hash_groups">#to_hash_groups</a></li>
          
          <li><a href="#method-i-to_prepared_statement">#to_prepared_statement</a></li>
          
          <li><a href="#method-i-truncate">#truncate</a></li>
          
          <li><a href="#method-i-truncate_sql">#truncate_sql</a></li>
          
          <li><a href="#method-i-unbind">#unbind</a></li>
          
          <li><a href="#method-i-unfiltered">#unfiltered</a></li>
          
          <li><a href="#method-i-ungraphed">#ungraphed</a></li>
          
          <li><a href="#method-i-ungrouped">#ungrouped</a></li>
          
          <li><a href="#method-i-union">#union</a></li>
          
          <li><a href="#method-i-unlimited">#unlimited</a></li>
          
          <li><a href="#method-i-unordered">#unordered</a></li>
          
          <li><a href="#method-i-unused_table_alias">#unused_table_alias</a></li>
          
          <li><a href="#method-i-update">#update</a></li>
          
          <li><a href="#method-i-update_sql">#update_sql</a></li>
          
          <li><a href="#method-i-where">#where</a></li>
          
          <li><a href="#method-i-window_function_sql_append">#window_function_sql_append</a></li>
          
          <li><a href="#method-i-window_sql_append">#window_sql_append</a></li>
          
          <li><a href="#method-i-with">#with</a></li>
          
          <li><a href="#method-i-with_recursive">#with_recursive</a></li>
          
          <li><a href="#method-i-with_sql">#with_sql</a></li>
          
          <li><a href="#method-i-with_sql_delete">#with_sql_delete</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Metaprogramming.html">Sequel::Metaprogramming</a></li>
        
        
        
          <li><span class="include">Enumerable</span></li>
        
        
        
          <li><a class="include" href="SQL/AliasMethods.html">Sequel::SQL::AliasMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/BooleanMethods.html">Sequel::SQL::BooleanMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/CastMethods.html">Sequel::SQL::CastMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/ComplexExpressionMethods.html">Sequel::SQL::ComplexExpressionMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/InequalityMethods.html">Sequel::SQL::InequalityMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/NumericMethods.html">Sequel::SQL::NumericMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/OrderMethods.html">Sequel::SQL::OrderMethods</a></li>
        
        
        
          <li><a class="include" href="SQL/StringMethods.html">Sequel::SQL::StringMethods</a></li>
        
        
        
          <li><a class="include" href="ColumnsIntrospection.html">Sequel::ColumnsIntrospection</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="../CHANGELOG.html">CHANGELOG</a></li>
        
          <li class="file"><a href="../MIT-LICENSE.html">MIT-LICENSE</a></li>
        
          <li class="file"><a href="../README_rdoc.html">README.rdoc</a></li>
        
          <li class="file"><a href="../doc/active_record_rdoc.html">active_record.rdoc</a></li>
        
          <li class="file"><a href="../doc/advanced_associations_rdoc.html">advanced_associations.rdoc</a></li>
        
          <li class="file"><a href="../doc/association_basics_rdoc.html">association_basics.rdoc</a></li>
        
          <li class="file"><a href="../doc/bin_sequel_rdoc.html">bin_sequel.rdoc</a></li>
        
          <li class="file"><a href="../doc/cheat_sheet_rdoc.html">cheat_sheet.rdoc</a></li>
        
          <li class="file"><a href="../doc/core_extensions_rdoc.html">core_extensions.rdoc</a></li>
        
          <li class="file"><a href="../doc/dataset_basics_rdoc.html">dataset_basics.rdoc</a></li>
        
          <li class="file"><a href="../doc/dataset_filtering_rdoc.html">dataset_filtering.rdoc</a></li>
        
          <li class="file"><a href="../doc/mass_assignment_rdoc.html">mass_assignment.rdoc</a></li>
        
          <li class="file"><a href="../doc/migration_rdoc.html">migration.rdoc</a></li>
        
          <li class="file"><a href="../doc/model_hooks_rdoc.html">model_hooks.rdoc</a></li>
        
          <li class="file"><a href="../doc/object_model_rdoc.html">object_model.rdoc</a></li>
        
          <li class="file"><a href="../doc/opening_databases_rdoc.html">opening_databases.rdoc</a></li>
        
          <li class="file"><a href="../doc/prepared_statements_rdoc.html">prepared_statements.rdoc</a></li>
        
          <li class="file"><a href="../doc/querying_rdoc.html">querying.rdoc</a></li>
        
          <li class="file"><a href="../doc/reflection_rdoc.html">reflection.rdoc</a></li>
        
          <li class="file"><a href="../doc/release_notes/1_0_txt.html">1.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/1_1_txt.html">1.1.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/1_3_txt.html">1.3.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/1_4_0_txt.html">1.4.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/1_5_0_txt.html">1.5.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_0_0_txt.html">2.0.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_1_0_txt.html">2.1.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_10_0_txt.html">2.10.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_11_0_txt.html">2.11.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_12_0_txt.html">2.12.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_2_0_txt.html">2.2.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_3_0_txt.html">2.3.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_4_0_txt.html">2.4.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_5_0_txt.html">2.5.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_6_0_txt.html">2.6.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_7_0_txt.html">2.7.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_8_0_txt.html">2.8.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/2_9_0_txt.html">2.9.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_0_0_txt.html">3.0.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_1_0_txt.html">3.1.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_10_0_txt.html">3.10.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_11_0_txt.html">3.11.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_12_0_txt.html">3.12.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_13_0_txt.html">3.13.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_14_0_txt.html">3.14.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_15_0_txt.html">3.15.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_16_0_txt.html">3.16.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_17_0_txt.html">3.17.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_18_0_txt.html">3.18.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_19_0_txt.html">3.19.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_2_0_txt.html">3.2.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_20_0_txt.html">3.20.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_21_0_txt.html">3.21.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_22_0_txt.html">3.22.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_23_0_txt.html">3.23.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_24_0_txt.html">3.24.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_25_0_txt.html">3.25.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_26_0_txt.html">3.26.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_27_0_txt.html">3.27.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_28_0_txt.html">3.28.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_29_0_txt.html">3.29.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_3_0_txt.html">3.3.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_30_0_txt.html">3.30.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_31_0_txt.html">3.31.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_32_0_txt.html">3.32.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_33_0_txt.html">3.33.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_34_0_txt.html">3.34.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_35_0_txt.html">3.35.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_36_0_txt.html">3.36.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_37_0_txt.html">3.37.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_38_0_txt.html">3.38.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_39_0_txt.html">3.39.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_4_0_txt.html">3.4.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_40_0_txt.html">3.40.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_41_0_txt.html">3.41.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_5_0_txt.html">3.5.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_6_0_txt.html">3.6.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_7_0_txt.html">3.7.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_8_0_txt.html">3.8.0.txt</a></li>
        
          <li class="file"><a href="../doc/release_notes/3_9_0_txt.html">3.9.0.txt</a></li>
        
          <li class="file"><a href="../doc/schema_modification_rdoc.html">schema_modification.rdoc</a></li>
        
          <li class="file"><a href="../doc/sharding_rdoc.html">sharding.rdoc</a></li>
        
          <li class="file"><a href="../doc/sql_rdoc.html">sql.rdoc</a></li>
        
          <li class="file"><a href="../doc/testing_rdoc.html">testing.rdoc</a></li>
        
          <li class="file"><a href="../doc/thread_safety_rdoc.html">thread_safety.rdoc</a></li>
        
          <li class="file"><a href="../doc/transactions_rdoc.html">transactions.rdoc</a></li>
        
          <li class="file"><a href="../doc/validations_rdoc.html">validations.rdoc</a></li>
        
          <li class="file"><a href="../doc/virtual_rows_rdoc.html">virtual_rows.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../Sequel.html">Sequel</a></li>
        
          <li><a href="../Sequel/ADO.html">Sequel::ADO</a></li>
        
          <li><a href="../Sequel/ADO/Access.html">Sequel::ADO::Access</a></li>
        
          <li><a href="../Sequel/ADO/Access/AdoSchema.html">Sequel::ADO::Access::AdoSchema</a></li>
        
          <li><a href="../Sequel/ADO/Access/AdoSchema/Column.html">Sequel::ADO::Access::AdoSchema::Column</a></li>
        
          <li><a href="../Sequel/ADO/Access/DatabaseMethods.html">Sequel::ADO::Access::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/ADO/Access/Dataset.html">Sequel::ADO::Access::Dataset</a></li>
        
          <li><a href="../Sequel/ADO/Database.html">Sequel::ADO::Database</a></li>
        
          <li><a href="../Sequel/ADO/Dataset.html">Sequel::ADO::Dataset</a></li>
        
          <li><a href="../Sequel/ADO/MSSQL.html">Sequel::ADO::MSSQL</a></li>
        
          <li><a href="../Sequel/ADO/MSSQL/DatabaseMethods.html">Sequel::ADO::MSSQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/ADO/MSSQL/Dataset.html">Sequel::ADO::MSSQL::Dataset</a></li>
        
          <li><a href="../Sequel/ASTTransformer.html">Sequel::ASTTransformer</a></li>
        
          <li><a href="../Sequel/Access.html">Sequel::Access</a></li>
        
          <li><a href="../Sequel/Access/DatabaseMethods.html">Sequel::Access::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Access/DatasetMethods.html">Sequel::Access::DatasetMethods</a></li>
        
          <li><a href="../Sequel/AdapterNotFound.html">Sequel::AdapterNotFound</a></li>
        
          <li><a href="../Sequel/Amalgalite.html">Sequel::Amalgalite</a></li>
        
          <li><a href="../Sequel/Amalgalite/Database.html">Sequel::Amalgalite::Database</a></li>
        
          <li><a href="../Sequel/Amalgalite/Dataset.html">Sequel::Amalgalite::Dataset</a></li>
        
          <li><a href="../Sequel/Amalgalite/SequelTypeMap.html">Sequel::Amalgalite::SequelTypeMap</a></li>
        
          <li><a href="../Sequel/ArbitraryServers.html">Sequel::ArbitraryServers</a></li>
        
          <li><a href="../Sequel/BasicObject.html">Sequel::BasicObject</a></li>
        
          <li><a href="../Sequel/HookFailed.html">Sequel::BeforeHookFailed</a></li>
        
          <li><a href="../Sequel/ColumnsIntrospection.html">Sequel::ColumnsIntrospection</a></li>
        
          <li><a href="../Sequel/ConnectionPool.html">Sequel::ConnectionPool</a></li>
        
          <li><a href="../Sequel/ConnectionPool/ClassMethods.html">Sequel::ConnectionPool::ClassMethods</a></li>
        
          <li><a href="../Sequel/ConnectionValidator.html">Sequel::ConnectionValidator</a></li>
        
          <li><a href="../Sequel/ConnectionValidator/Retry.html">Sequel::ConnectionValidator::Retry</a></li>
        
          <li><a href="../Sequel/ConstraintValidations.html">Sequel::ConstraintValidations</a></li>
        
          <li><a href="../Sequel/ConstraintValidations/AlterTableGeneratorMethods.html">Sequel::ConstraintValidations::AlterTableGeneratorMethods</a></li>
        
          <li><a href="../Sequel/ConstraintValidations/CreateTableGeneratorMethods.html">Sequel::ConstraintValidations::CreateTableGeneratorMethods</a></li>
        
          <li><a href="../Sequel/ConstraintValidations/Generator.html">Sequel::ConstraintValidations::Generator</a></li>
        
          <li><a href="../Sequel/Cubrid.html">Sequel::Cubrid</a></li>
        
          <li><a href="../Sequel/Cubrid/Database.html">Sequel::Cubrid::Database</a></li>
        
          <li><a href="../Sequel/Cubrid/DatabaseMethods.html">Sequel::Cubrid::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Cubrid/Dataset.html">Sequel::Cubrid::Dataset</a></li>
        
          <li><a href="../Sequel/Cubrid/DatasetMethods.html">Sequel::Cubrid::DatasetMethods</a></li>
        
          <li><a href="../Sequel/DB2.html">Sequel::DB2</a></li>
        
          <li><a href="../Sequel/DB2/DB2Error.html">Sequel::DB2::DB2Error</a></li>
        
          <li><a href="../Sequel/DB2/Database.html">Sequel::DB2::Database</a></li>
        
          <li><a href="../Sequel/DB2/DatabaseMethods.html">Sequel::DB2::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/DB2/Dataset.html">Sequel::DB2::Dataset</a></li>
        
          <li><a href="../Sequel/DB2/DatasetMethods.html">Sequel::DB2::DatasetMethods</a></li>
        
          <li><a href="../Sequel/DBI.html">Sequel::DBI</a></li>
        
          <li><a href="../Sequel/DBI/Database.html">Sequel::DBI::Database</a></li>
        
          <li><a href="../Sequel/DBI/Dataset.html">Sequel::DBI::Dataset</a></li>
        
          <li><a href="../Sequel/DataObjects.html">Sequel::DataObjects</a></li>
        
          <li><a href="../Sequel/DataObjects/Database.html">Sequel::DataObjects::Database</a></li>
        
          <li><a href="../Sequel/DataObjects/Dataset.html">Sequel::DataObjects::Dataset</a></li>
        
          <li><a href="../Sequel/DataObjects/MySQL.html">Sequel::DataObjects::MySQL</a></li>
        
          <li><a href="../Sequel/DataObjects/MySQL/DatabaseMethods.html">Sequel::DataObjects::MySQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/DataObjects/MySQL/Dataset.html">Sequel::DataObjects::MySQL::Dataset</a></li>
        
          <li><a href="../Sequel/DataObjects/Postgres.html">Sequel::DataObjects::Postgres</a></li>
        
          <li><a href="../Sequel/DataObjects/Postgres/DatabaseMethods.html">Sequel::DataObjects::Postgres::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/DataObjects/SQLite.html">Sequel::DataObjects::SQLite</a></li>
        
          <li><a href="../Sequel/DataObjects/SQLite/DatabaseMethods.html">Sequel::DataObjects::SQLite::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Database.html">Sequel::Database</a></li>
        
          <li><a href="../Sequel/Dataset.html">Sequel::Database::DatasetClass</a></li>
        
          <li><a href="../Sequel/Database/SplitAlterTable.html">Sequel::Database::SplitAlterTable</a></li>
        
          <li><a href="../Sequel/DatabaseConnectionError.html">Sequel::DatabaseConnectionError</a></li>
        
          <li><a href="../Sequel/DatabaseDisconnectError.html">Sequel::DatabaseDisconnectError</a></li>
        
          <li><a href="../Sequel/DatabaseError.html">Sequel::DatabaseError</a></li>
        
          <li><a href="../Sequel/Dataset.html">Sequel::Dataset</a></li>
        
          <li><a href="../Sequel/Dataset/ArgumentMapper.html">Sequel::Dataset::ArgumentMapper</a></li>
        
          <li><a href="../Sequel/Dataset/NullDataset.html">Sequel::Dataset::NullDataset</a></li>
        
          <li><a href="../Sequel/Dataset/Pagination.html">Sequel::Dataset::Pagination</a></li>
        
          <li><a href="../Sequel/Dataset/PreparedStatementMethods.html">Sequel::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/Dataset/QueryBlockCopy.html">Sequel::Dataset::QueryBlockCopy</a></li>
        
          <li><a href="../Sequel/Dataset/SplitArrayNil.html">Sequel::Dataset::SplitArrayNil</a></li>
        
          <li><a href="../Sequel/Dataset/StoredProcedureMethods.html">Sequel::Dataset::StoredProcedureMethods</a></li>
        
          <li><a href="../Sequel/Dataset/StoredProcedures.html">Sequel::Dataset::StoredProcedures</a></li>
        
          <li><a href="../Sequel/Dataset/UnnumberedArgumentMapper.html">Sequel::Dataset::UnnumberedArgumentMapper</a></li>
        
          <li><a href="../Sequel/EmulateOffsetWithRowNumber.html">Sequel::EmulateOffsetWithRowNumber</a></li>
        
          <li><a href="../Sequel/Error.html">Sequel::Error</a></li>
        
          <li><a href="../Sequel/AdapterNotFound.html">Sequel::Error::AdapterNotFound</a></li>
        
          <li><a href="../Sequel/InvalidOperation.html">Sequel::Error::InvalidOperation</a></li>
        
          <li><a href="../Sequel/InvalidValue.html">Sequel::Error::InvalidValue</a></li>
        
          <li><a href="../Sequel/PoolTimeout.html">Sequel::Error::PoolTimeoutError</a></li>
        
          <li><a href="../Sequel/Rollback.html">Sequel::Error::Rollback</a></li>
        
          <li><a href="../Sequel/EvalInspect.html">Sequel::EvalInspect</a></li>
        
          <li><a href="../Sequel/Firebird.html">Sequel::Firebird</a></li>
        
          <li><a href="../Sequel/Firebird/Database.html">Sequel::Firebird::Database</a></li>
        
          <li><a href="../Sequel/Firebird/DatabaseMethods.html">Sequel::Firebird::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Firebird/Dataset.html">Sequel::Firebird::Dataset</a></li>
        
          <li><a href="../Sequel/Firebird/DatasetMethods.html">Sequel::Firebird::DatasetMethods</a></li>
        
          <li><a href="../Sequel/HookFailed.html">Sequel::HookFailed</a></li>
        
          <li><a href="../Sequel/IBMDB.html">Sequel::IBMDB</a></li>
        
          <li><a href="../Sequel/IBMDB/Connection.html">Sequel::IBMDB::Connection</a></li>
        
          <li><a href="../Sequel/IBMDB/Connection/Error.html">Sequel::IBMDB::Connection::Error</a></li>
        
          <li><a href="../Sequel/IBMDB/Database.html">Sequel::IBMDB::Database</a></li>
        
          <li><a href="../Sequel/IBMDB/Dataset.html">Sequel::IBMDB::Dataset</a></li>
        
          <li><a href="../Sequel/IBMDB/Dataset/CallableStatementMethods.html">Sequel::IBMDB::Dataset::CallableStatementMethods</a></li>
        
          <li><a href="../Sequel/IBMDB/Dataset/PreparedStatementMethods.html">Sequel::IBMDB::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/IBMDB/Statement.html">Sequel::IBMDB::Statement</a></li>
        
          <li><a href="../Sequel/Inflections.html">Sequel::Inflections</a></li>
        
          <li><a href="../Sequel/Informix.html">Sequel::Informix</a></li>
        
          <li><a href="../Sequel/Informix/Database.html">Sequel::Informix::Database</a></li>
        
          <li><a href="../Sequel/Informix/DatabaseMethods.html">Sequel::Informix::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Informix/Dataset.html">Sequel::Informix::Dataset</a></li>
        
          <li><a href="../Sequel/Informix/DatasetMethods.html">Sequel::Informix::DatasetMethods</a></li>
        
          <li><a href="../Sequel/IntegerMigrator.html">Sequel::IntegerMigrator</a></li>
        
          <li><a href="../Sequel/InvalidOperation.html">Sequel::InvalidOperation</a></li>
        
          <li><a href="../Sequel/InvalidValue.html">Sequel::InvalidValue</a></li>
        
          <li><a href="../Sequel/JDBC.html">Sequel::JDBC</a></li>
        
          <li><a href="../Sequel/JDBC/AS400.html">Sequel::JDBC::AS400</a></li>
        
          <li><a href="../Sequel/JDBC/AS400/DatabaseMethods.html">Sequel::JDBC::AS400::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/AS400/Dataset.html">Sequel::JDBC::AS400::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Cubrid.html">Sequel::JDBC::Cubrid</a></li>
        
          <li><a href="../Sequel/JDBC/Cubrid/DatabaseMethods.html">Sequel::JDBC::Cubrid::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/DB2.html">Sequel::JDBC::DB2</a></li>
        
          <li><a href="../Sequel/JDBC/DB2/DatabaseMethods.html">Sequel::JDBC::DB2::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/DB2/Dataset.html">Sequel::JDBC::DB2::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Database.html">Sequel::JDBC::Database</a></li>
        
          <li><a href="../Sequel/JDBC/Dataset.html">Sequel::JDBC::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Dataset/PreparedStatementMethods.html">Sequel::JDBC::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Dataset/StoredProcedureMethods.html">Sequel::JDBC::Dataset::StoredProcedureMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Dataset/TYPE_TRANSLATOR.html">Sequel::JDBC::Dataset::TYPE_TRANSLATOR</a></li>
        
          <li><a href="../Sequel/JDBC/Derby.html">Sequel::JDBC::Derby</a></li>
        
          <li><a href="../Sequel/JDBC/Derby/DatabaseMethods.html">Sequel::JDBC::Derby::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Derby/Dataset.html">Sequel::JDBC::Derby::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Firebird.html">Sequel::JDBC::Firebird</a></li>
        
          <li><a href="../Sequel/JDBC/Firebird/DatabaseMethods.html">Sequel::JDBC::Firebird::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/H2.html">Sequel::JDBC::H2</a></li>
        
          <li><a href="../Sequel/JDBC/H2/DatabaseMethods.html">Sequel::JDBC::H2::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/H2/Dataset.html">Sequel::JDBC::H2::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/HSQLDB.html">Sequel::JDBC::HSQLDB</a></li>
        
          <li><a href="../Sequel/JDBC/HSQLDB/DatabaseMethods.html">Sequel::JDBC::HSQLDB::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/HSQLDB/Dataset.html">Sequel::JDBC::HSQLDB::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Informix.html">Sequel::JDBC::Informix</a></li>
        
          <li><a href="../Sequel/JDBC/Informix/DatabaseMethods.html">Sequel::JDBC::Informix::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/JTDS.html">Sequel::JDBC::JTDS</a></li>
        
          <li><a href="../Sequel/JDBC/JTDS/DatabaseMethods.html">Sequel::JDBC::JTDS::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/JTDS/Dataset.html">Sequel::JDBC::JTDS::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/JavaLang.html">Sequel::JDBC::JavaLang</a></li>
        
          <li><a href="../Sequel/JDBC/JavaSQL.html">Sequel::JDBC::JavaSQL</a></li>
        
          <li><a href="../Sequel/JDBC/JavaxNaming.html">Sequel::JDBC::JavaxNaming</a></li>
        
          <li><a href="../Sequel/JDBC/MSSQL.html">Sequel::JDBC::MSSQL</a></li>
        
          <li><a href="../Sequel/JDBC/MSSQL/DatabaseMethods.html">Sequel::JDBC::MSSQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/MySQL.html">Sequel::JDBC::MySQL</a></li>
        
          <li><a href="../Sequel/JDBC/MySQL/DatabaseMethods.html">Sequel::JDBC::MySQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Oracle.html">Sequel::JDBC::Oracle</a></li>
        
          <li><a href="../Sequel/JDBC/Oracle/DatabaseMethods.html">Sequel::JDBC::Oracle::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Oracle/Dataset.html">Sequel::JDBC::Oracle::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Postgres.html">Sequel::JDBC::Postgres</a></li>
        
          <li><a href="../Sequel/JDBC/Postgres/DatabaseMethods.html">Sequel::JDBC::Postgres::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Postgres/Dataset.html">Sequel::JDBC::Postgres::Dataset</a></li>
        
          <li><a href="../Sequel/JDBC/Postgres/Dataset/PGArrayConverter.html">Sequel::JDBC::Postgres::Dataset::PGArrayConverter</a></li>
        
          <li><a href="../Sequel/JDBC/Progress.html">Sequel::JDBC::Progress</a></li>
        
          <li><a href="../Sequel/JDBC/Progress/DatabaseMethods.html">Sequel::JDBC::Progress::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/SQLServer.html">Sequel::JDBC::SQLServer</a></li>
        
          <li><a href="../Sequel/JDBC/SQLServer/DatabaseMethods.html">Sequel::JDBC::SQLServer::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/SQLServer/DatabaseMethods/MetadataDatasetMethods.html">Sequel::JDBC::SQLServer::DatabaseMethods::MetadataDatasetMethods</a></li>
        
          <li><a href="../Sequel/JDBC/SQLite.html">Sequel::JDBC::SQLite</a></li>
        
          <li><a href="../Sequel/JDBC/SQLite/DatabaseMethods.html">Sequel::JDBC::SQLite::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/JDBC/Transactions.html">Sequel::JDBC::Transactions</a></li>
        
          <li><a href="../Sequel/LiteralString.html">Sequel::LiteralString</a></li>
        
          <li><a href="../Sequel/LooserTypecasting.html">Sequel::LooserTypecasting</a></li>
        
          <li><a href="../Sequel/MSSQL.html">Sequel::MSSQL</a></li>
        
          <li><a href="../Sequel/MSSQL/DatabaseMethods.html">Sequel::MSSQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/MSSQL/DatasetMethods.html">Sequel::MSSQL::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Metaprogramming.html">Sequel::Metaprogramming</a></li>
        
          <li><a href="../Sequel/Migration.html">Sequel::Migration</a></li>
        
          <li><a href="../Sequel/MigrationAlterTableReverser.html">Sequel::MigrationAlterTableReverser</a></li>
        
          <li><a href="../Sequel/MigrationDSL.html">Sequel::MigrationDSL</a></li>
        
          <li><a href="../Sequel/MigrationReverser.html">Sequel::MigrationReverser</a></li>
        
          <li><a href="../Sequel/Migrator.html">Sequel::Migrator</a></li>
        
          <li><a href="../Sequel/Migrator/Error.html">Sequel::Migrator::Error</a></li>
        
          <li><a href="../Sequel/Migrator/NotCurrentError.html">Sequel::Migrator::NotCurrentError</a></li>
        
          <li><a href="../Sequel/Mock.html">Sequel::Mock</a></li>
        
          <li><a href="../Sequel/Mock/Connection.html">Sequel::Mock::Connection</a></li>
        
          <li><a href="../Sequel/Mock/Database.html">Sequel::Mock::Database</a></li>
        
          <li><a href="../Sequel/Mock/Dataset.html">Sequel::Mock::Dataset</a></li>
        
          <li><a href="../Sequel/Model.html">Sequel::Model</a></li>
        
          <li><a href="../Sequel/Model/Associations.html">Sequel::Model::Associations</a></li>
        
          <li><a href="../Sequel/Model/Associations/AssociationDatasetMethods.html">Sequel::Model::Associations::AssociationDatasetMethods</a></li>
        
          <li><a href="../Sequel/Model/Associations/AssociationReflection.html">Sequel::Model::Associations::AssociationReflection</a></li>
        
          <li><a href="../Sequel/Model/Associations/ClassMethods.html">Sequel::Model::Associations::ClassMethods</a></li>
        
          <li><a href="../Sequel/Model/Associations/DatasetMethods.html">Sequel::Model::Associations::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Model/Associations/EagerGraphLoader.html">Sequel::Model::Associations::EagerGraphLoader</a></li>
        
          <li><a href="../Sequel/Model/Associations/InstanceMethods.html">Sequel::Model::Associations::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Model/Associations/ManyToManyAssociationReflection.html">Sequel::Model::Associations::ManyToManyAssociationReflection</a></li>
        
          <li><a href="../Sequel/Model/Associations/ManyToOneAssociationReflection.html">Sequel::Model::Associations::ManyToOneAssociationReflection</a></li>
        
          <li><a href="../Sequel/Model/Associations/OneToManyAssociationReflection.html">Sequel::Model::Associations::OneToManyAssociationReflection</a></li>
        
          <li><a href="../Sequel/Model/Associations/OneToOneAssociationReflection.html">Sequel::Model::Associations::OneToOneAssociationReflection</a></li>
        
          <li><a href="../Sequel/Model/ClassMethods.html">Sequel::Model::ClassMethods</a></li>
        
          <li><a href="../Sequel/Model/DatasetMethods.html">Sequel::Model::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Model/Errors.html">Sequel::Model::Errors</a></li>
        
          <li><a href="../Sequel/Model/InstanceMethods.html">Sequel::Model::InstanceMethods</a></li>
        
          <li><a href="../Sequel/MySQL.html">Sequel::MySQL</a></li>
        
          <li><a href="../Sequel/MySQL/Database.html">Sequel::MySQL::Database</a></li>
        
          <li><a href="../Sequel/MySQL/DatabaseMethods.html">Sequel::MySQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/MySQL/Dataset.html">Sequel::MySQL::Dataset</a></li>
        
          <li><a href="../Sequel/MySQL/DatasetMethods.html">Sequel::MySQL::DatasetMethods</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements.html">Sequel::MySQL::PreparedStatements</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements/DatabaseMethods.html">Sequel::MySQL::PreparedStatements::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements/DatasetMethods.html">Sequel::MySQL::PreparedStatements::DatasetMethods</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements/DatasetMethods/CallableStatementMethods.html">Sequel::MySQL::PreparedStatements::DatasetMethods::CallableStatementMethods</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements/DatasetMethods/PreparedStatementMethods.html">Sequel::MySQL::PreparedStatements::DatasetMethods::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/MySQL/PreparedStatements/DatasetMethods/StoredProcedureMethods.html">Sequel::MySQL::PreparedStatements::DatasetMethods::StoredProcedureMethods</a></li>
        
          <li><a href="../Sequel/Mysql2.html">Sequel::Mysql2</a></li>
        
          <li><a href="../Sequel/Mysql2/Database.html">Sequel::Mysql2::Database</a></li>
        
          <li><a href="../Sequel/Mysql2/Dataset.html">Sequel::Mysql2::Dataset</a></li>
        
          <li><a href="../Sequel/NamedTimezones.html">Sequel::NamedTimezones</a></li>
        
          <li><a href="../Sequel/NoExistingObject.html">Sequel::NoExistingObject</a></li>
        
          <li><a href="../Sequel/NotImplemented.html">Sequel::NotImplemented</a></li>
        
          <li><a href="../Sequel/ODBC.html">Sequel::ODBC</a></li>
        
          <li><a href="../Sequel/ODBC/Database.html">Sequel::ODBC::Database</a></li>
        
          <li><a href="../Sequel/ODBC/Dataset.html">Sequel::ODBC::Dataset</a></li>
        
          <li><a href="../Sequel/ODBC/MSSQL.html">Sequel::ODBC::MSSQL</a></li>
        
          <li><a href="../Sequel/ODBC/MSSQL/DatabaseMethods.html">Sequel::ODBC::MSSQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/ODBC/MSSQL/Dataset.html">Sequel::ODBC::MSSQL::Dataset</a></li>
        
          <li><a href="../Sequel/OpenBase.html">Sequel::OpenBase</a></li>
        
          <li><a href="../Sequel/OpenBase/Database.html">Sequel::OpenBase::Database</a></li>
        
          <li><a href="../Sequel/OpenBase/Dataset.html">Sequel::OpenBase::Dataset</a></li>
        
          <li><a href="../Sequel/Oracle.html">Sequel::Oracle</a></li>
        
          <li><a href="../Sequel/Oracle/Database.html">Sequel::Oracle::Database</a></li>
        
          <li><a href="../Sequel/Oracle/DatabaseMethods.html">Sequel::Oracle::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Oracle/Dataset.html">Sequel::Oracle::Dataset</a></li>
        
          <li><a href="../Sequel/Oracle/Dataset/ArgumentMapper.html">Sequel::Oracle::Dataset::ArgumentMapper</a></li>
        
          <li><a href="../Sequel/Oracle/Dataset/BindArgumentMethods.html">Sequel::Oracle::Dataset::BindArgumentMethods</a></li>
        
          <li><a href="../Sequel/Oracle/Dataset/PreparedStatementMethods.html">Sequel::Oracle::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/Oracle/DatasetMethods.html">Sequel::Oracle::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins.html">Sequel::Plugins</a></li>
        
          <li><a href="../Sequel/Plugins/ActiveModel.html">Sequel::Plugins::ActiveModel</a></li>
        
          <li><a href="../Sequel/Plugins/ActiveModel/ClassMethods.html">Sequel::Plugins::ActiveModel::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ActiveModel/InstanceMethods.html">Sequel::Plugins::ActiveModel::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationAutoreloading.html">Sequel::Plugins::AssociationAutoreloading</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationAutoreloading/ClassMethods.html">Sequel::Plugins::AssociationAutoreloading::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationDependencies.html">Sequel::Plugins::AssociationDependencies</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationDependencies/ClassMethods.html">Sequel::Plugins::AssociationDependencies::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationDependencies/InstanceMethods.html">Sequel::Plugins::AssociationDependencies::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationPks.html">Sequel::Plugins::AssociationPks</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationPks/ClassMethods.html">Sequel::Plugins::AssociationPks::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationPks/InstanceMethods.html">Sequel::Plugins::AssociationPks::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationProxies.html">Sequel::Plugins::AssociationProxies</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationProxies/AssociationProxy.html">Sequel::Plugins::AssociationProxies::AssociationProxy</a></li>
        
          <li><a href="../Sequel/Plugins/AssociationProxies/ClassMethods.html">Sequel::Plugins::AssociationProxies::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/BooleanReaders.html">Sequel::Plugins::BooleanReaders</a></li>
        
          <li><a href="../Sequel/Plugins/BooleanReaders/ClassMethods.html">Sequel::Plugins::BooleanReaders::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Caching.html">Sequel::Plugins::Caching</a></li>
        
          <li><a href="../Sequel/Plugins/Caching/ClassMethods.html">Sequel::Plugins::Caching::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Caching/InstanceMethods.html">Sequel::Plugins::Caching::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ClassTableInheritance.html">Sequel::Plugins::ClassTableInheritance</a></li>
        
          <li><a href="../Sequel/Plugins/ClassTableInheritance/ClassMethods.html">Sequel::Plugins::ClassTableInheritance::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ClassTableInheritance/InstanceMethods.html">Sequel::Plugins::ClassTableInheritance::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Composition.html">Sequel::Plugins::Composition</a></li>
        
          <li><a href="../Sequel/Plugins/Composition/ClassMethods.html">Sequel::Plugins::Composition::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Composition/InstanceMethods.html">Sequel::Plugins::Composition::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ConstraintValidations.html">Sequel::Plugins::ConstraintValidations</a></li>
        
          <li><a href="../Sequel/Plugins/ConstraintValidations/ClassMethods.html">Sequel::Plugins::ConstraintValidations::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ConstraintValidations/DatabaseMethods.html">Sequel::Plugins::ConstraintValidations::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ConstraintValidations/InstanceMethods.html">Sequel::Plugins::ConstraintValidations::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/DatasetAssociations.html">Sequel::Plugins::DatasetAssociations</a></li>
        
          <li><a href="../Sequel/Plugins/DatasetAssociations/ClassMethods.html">Sequel::Plugins::DatasetAssociations::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/DatasetAssociations/DatasetMethods.html">Sequel::Plugins::DatasetAssociations::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/DefaultsSetter.html">Sequel::Plugins::DefaultsSetter</a></li>
        
          <li><a href="../Sequel/Plugins/DefaultsSetter/ClassMethods.html">Sequel::Plugins::DefaultsSetter::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/DefaultsSetter/InstanceMethods.html">Sequel::Plugins::DefaultsSetter::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Dirty.html">Sequel::Plugins::Dirty</a></li>
        
          <li><a href="../Sequel/Plugins/Dirty/InstanceMethods.html">Sequel::Plugins::Dirty::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/EagerEach.html">Sequel::Plugins::EagerEach</a></li>
        
          <li><a href="../Sequel/Plugins/EagerEach/DatasetMethods.html">Sequel::Plugins::EagerEach::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/EagerEach/EagerDatasetMethods.html">Sequel::Plugins::EagerEach::EagerDatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ForceEncoding.html">Sequel::Plugins::ForceEncoding</a></li>
        
          <li><a href="../Sequel/Plugins/ForceEncoding/ClassMethods.html">Sequel::Plugins::ForceEncoding::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ForceEncoding/InstanceMethods.html">Sequel::Plugins::ForceEncoding::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/HookClassMethods.html">Sequel::Plugins::HookClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/HookClassMethods/ClassMethods.html">Sequel::Plugins::HookClassMethods::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/HookClassMethods/InstanceMethods.html">Sequel::Plugins::HookClassMethods::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/IdentityMap.html">Sequel::Plugins::IdentityMap</a></li>
        
          <li><a href="../Sequel/Plugins/IdentityMap/ClassMethods.html">Sequel::Plugins::IdentityMap::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/IdentityMap/InstanceMethods.html">Sequel::Plugins::IdentityMap::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/InstanceFilters.html">Sequel::Plugins::InstanceFilters</a></li>
        
          <li><a href="../Sequel/NoExistingObject.html">Sequel::Plugins::InstanceFilters::Error</a></li>
        
          <li><a href="../Sequel/Plugins/InstanceFilters/InstanceMethods.html">Sequel::Plugins::InstanceFilters::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/InstanceHooks.html">Sequel::Plugins::InstanceHooks</a></li>
        
          <li><a href="../Sequel/Plugins/InstanceHooks/InstanceMethods.html">Sequel::Plugins::InstanceHooks::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/JsonSerializer.html">Sequel::Plugins::JsonSerializer</a></li>
        
          <li><a href="../Sequel/Plugins/JsonSerializer/ClassMethods.html">Sequel::Plugins::JsonSerializer::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/JsonSerializer/DatasetMethods.html">Sequel::Plugins::JsonSerializer::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/JsonSerializer/InstanceMethods.html">Sequel::Plugins::JsonSerializer::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/JsonSerializer/Literal.html">Sequel::Plugins::JsonSerializer::Literal</a></li>
        
          <li><a href="../Sequel/Plugins/LazyAttributes.html">Sequel::Plugins::LazyAttributes</a></li>
        
          <li><a href="../Sequel/Plugins/LazyAttributes/ClassMethods.html">Sequel::Plugins::LazyAttributes::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/LazyAttributes/InstanceMethods.html">Sequel::Plugins::LazyAttributes::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/List.html">Sequel::Plugins::List</a></li>
        
          <li><a href="../Sequel/Plugins/List/ClassMethods.html">Sequel::Plugins::List::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/List/InstanceMethods.html">Sequel::Plugins::List::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ManyThroughMany.html">Sequel::Plugins::ManyThroughMany</a></li>
        
          <li><a href="../Sequel/Plugins/ManyThroughMany/ClassMethods.html">Sequel::Plugins::ManyThroughMany::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ManyThroughMany/DatasetMethods.html">Sequel::Plugins::ManyThroughMany::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ManyThroughMany/ManyThroughManyAssociationReflection.html">Sequel::Plugins::ManyThroughMany::ManyThroughManyAssociationReflection</a></li>
        
          <li><a href="../Sequel/Plugins/ManyToOnePkLookup.html">Sequel::Plugins::ManyToOnePkLookup</a></li>
        
          <li><a href="../Sequel/Plugins/ManyToOnePkLookup/InstanceMethods.html">Sequel::Plugins::ManyToOnePkLookup::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/NestedAttributes.html">Sequel::Plugins::NestedAttributes</a></li>
        
          <li><a href="../Sequel/Plugins/NestedAttributes/ClassMethods.html">Sequel::Plugins::NestedAttributes::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/NestedAttributes/InstanceMethods.html">Sequel::Plugins::NestedAttributes::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/OptimisticLocking.html">Sequel::Plugins::OptimisticLocking</a></li>
        
          <li><a href="../Sequel/Plugins/OptimisticLocking/ClassMethods.html">Sequel::Plugins::OptimisticLocking::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/OptimisticLocking/InstanceMethods.html">Sequel::Plugins::OptimisticLocking::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PgRow.html">Sequel::Plugins::PgRow</a></li>
        
          <li><a href="../Sequel/Plugins/PgRow/ClassMethods.html">Sequel::Plugins::PgRow::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PgRow/DatabaseMethods.html">Sequel::Plugins::PgRow::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PgRow/InstanceMethods.html">Sequel::Plugins::PgRow::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PgTypecastOnLoad.html">Sequel::Plugins::PgTypecastOnLoad</a></li>
        
          <li><a href="../Sequel/Plugins/PgTypecastOnLoad/ClassMethods.html">Sequel::Plugins::PgTypecastOnLoad::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PgTypecastOnLoad/InstanceMethods.html">Sequel::Plugins::PgTypecastOnLoad::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatements.html">Sequel::Plugins::PreparedStatements</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatements/ClassMethods.html">Sequel::Plugins::PreparedStatements::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatements/InstanceMethods.html">Sequel::Plugins::PreparedStatements::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsAssociations.html">Sequel::Plugins::PreparedStatementsAssociations</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsAssociations/ClassMethods.html">Sequel::Plugins::PreparedStatementsAssociations::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsAssociations/InstanceMethods.html">Sequel::Plugins::PreparedStatementsAssociations::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsSafe.html">Sequel::Plugins::PreparedStatementsSafe</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsSafe/ClassMethods.html">Sequel::Plugins::PreparedStatementsSafe::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsSafe/InstanceMethods.html">Sequel::Plugins::PreparedStatementsSafe::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsWithPk.html">Sequel::Plugins::PreparedStatementsWithPk</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsWithPk/ClassMethods.html">Sequel::Plugins::PreparedStatementsWithPk::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/PreparedStatementsWithPk/DatasetMethods.html">Sequel::Plugins::PreparedStatementsWithPk::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/RcteTree.html">Sequel::Plugins::RcteTree</a></li>
        
          <li><a href="../Sequel/Plugins/Schema.html">Sequel::Plugins::Schema</a></li>
        
          <li><a href="../Sequel/Plugins/Schema/ClassMethods.html">Sequel::Plugins::Schema::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Serialization.html">Sequel::Plugins::Serialization</a></li>
        
          <li><a href="../Sequel/Plugins/Serialization/ClassMethods.html">Sequel::Plugins::Serialization::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Serialization/InstanceMethods.html">Sequel::Plugins::Serialization::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/SerializationModificationDetection.html">Sequel::Plugins::SerializationModificationDetection</a></li>
        
          <li><a href="../Sequel/Plugins/SerializationModificationDetection/InstanceMethods.html">Sequel::Plugins::SerializationModificationDetection::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Sharding.html">Sequel::Plugins::Sharding</a></li>
        
          <li><a href="../Sequel/Plugins/Sharding/ClassMethods.html">Sequel::Plugins::Sharding::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Sharding/DatasetMethods.html">Sequel::Plugins::Sharding::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Sharding/InstanceMethods.html">Sequel::Plugins::Sharding::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/SingleTableInheritance.html">Sequel::Plugins::SingleTableInheritance</a></li>
        
          <li><a href="../Sequel/Plugins/SingleTableInheritance/ClassMethods.html">Sequel::Plugins::SingleTableInheritance::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/SingleTableInheritance/InstanceMethods.html">Sequel::Plugins::SingleTableInheritance::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/SkipCreateRefresh.html">Sequel::Plugins::SkipCreateRefresh</a></li>
        
          <li><a href="../Sequel/Plugins/SkipCreateRefresh/InstanceMethods.html">Sequel::Plugins::SkipCreateRefresh::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/StaticCache.html">Sequel::Plugins::StaticCache</a></li>
        
          <li><a href="../Sequel/Plugins/StaticCache/ClassMethods.html">Sequel::Plugins::StaticCache::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/StringStripper.html">Sequel::Plugins::StringStripper</a></li>
        
          <li><a href="../Sequel/Plugins/StringStripper/InstanceMethods.html">Sequel::Plugins::StringStripper::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Subclasses.html">Sequel::Plugins::Subclasses</a></li>
        
          <li><a href="../Sequel/Plugins/Subclasses/ClassMethods.html">Sequel::Plugins::Subclasses::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/TacticalEagerLoading.html">Sequel::Plugins::TacticalEagerLoading</a></li>
        
          <li><a href="../Sequel/Plugins/TacticalEagerLoading/DatasetMethods.html">Sequel::Plugins::TacticalEagerLoading::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/TacticalEagerLoading/InstanceMethods.html">Sequel::Plugins::TacticalEagerLoading::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Timestamps.html">Sequel::Plugins::Timestamps</a></li>
        
          <li><a href="../Sequel/Plugins/Timestamps/ClassMethods.html">Sequel::Plugins::Timestamps::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Timestamps/InstanceMethods.html">Sequel::Plugins::Timestamps::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Touch.html">Sequel::Plugins::Touch</a></li>
        
          <li><a href="../Sequel/Plugins/Touch/ClassMethods.html">Sequel::Plugins::Touch::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Touch/InstanceMethods.html">Sequel::Plugins::Touch::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Tree.html">Sequel::Plugins::Tree</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/ClassMethods.html">Sequel::Plugins::Tree::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/InstanceMethods.html">Sequel::Plugins::Tree::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/SingleRoot.html">Sequel::Plugins::Tree::SingleRoot</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/SingleRoot/ClassMethods.html">Sequel::Plugins::Tree::SingleRoot::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/SingleRoot/InstanceMethods.html">Sequel::Plugins::Tree::SingleRoot::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/Tree/TreeMultipleRootError.html">Sequel::Plugins::Tree::TreeMultipleRootError</a></li>
        
          <li><a href="../Sequel/Plugins/TypecastOnLoad.html">Sequel::Plugins::TypecastOnLoad</a></li>
        
          <li><a href="../Sequel/Plugins/TypecastOnLoad/ClassMethods.html">Sequel::Plugins::TypecastOnLoad::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/TypecastOnLoad/InstanceMethods.html">Sequel::Plugins::TypecastOnLoad::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/UpdatePrimaryKey.html">Sequel::Plugins::UpdatePrimaryKey</a></li>
        
          <li><a href="../Sequel/Plugins/UpdatePrimaryKey/ClassMethods.html">Sequel::Plugins::UpdatePrimaryKey::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/UpdatePrimaryKey/InstanceMethods.html">Sequel::Plugins::UpdatePrimaryKey::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationClassMethods.html">Sequel::Plugins::ValidationClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationClassMethods/ClassMethods.html">Sequel::Plugins::ValidationClassMethods::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationClassMethods/ClassMethods/Generator.html">Sequel::Plugins::ValidationClassMethods::ClassMethods::Generator</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationClassMethods/InstanceMethods.html">Sequel::Plugins::ValidationClassMethods::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationHelpers.html">Sequel::Plugins::ValidationHelpers</a></li>
        
          <li><a href="../Sequel/Plugins/ValidationHelpers/InstanceMethods.html">Sequel::Plugins::ValidationHelpers::InstanceMethods</a></li>
        
          <li><a href="../Sequel/Plugins/XmlSerializer.html">Sequel::Plugins::XmlSerializer</a></li>
        
          <li><a href="../Sequel/Plugins/XmlSerializer/ClassMethods.html">Sequel::Plugins::XmlSerializer::ClassMethods</a></li>
        
          <li><a href="../Sequel/Plugins/XmlSerializer/DatasetMethods.html">Sequel::Plugins::XmlSerializer::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Plugins/XmlSerializer/InstanceMethods.html">Sequel::Plugins::XmlSerializer::InstanceMethods</a></li>
        
          <li><a href="../Sequel/PoolTimeout.html">Sequel::PoolTimeout</a></li>
        
          <li><a href="../Sequel/Postgres.html">Sequel::Postgres</a></li>
        
          <li><a href="../Sequel/Postgres/Adapter.html">Sequel::Postgres::Adapter</a></li>
        
          <li><a href="../Sequel/Postgres/AlterTableGenerator.html">Sequel::Postgres::AlterTableGenerator</a></li>
        
          <li><a href="../Sequel/Postgres/ArrayOp.html">Sequel::Postgres::ArrayOp</a></li>
        
          <li><a href="../Sequel/Postgres/ArrayOpMethods.html">Sequel::Postgres::ArrayOpMethods</a></li>
        
          <li><a href="../Sequel/Postgres/AutoParameterize.html">Sequel::Postgres::AutoParameterize</a></li>
        
          <li><a href="../Sequel/Postgres/AutoParameterize/DatabaseMethods.html">Sequel::Postgres::AutoParameterize::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/AutoParameterize/DatasetMethods.html">Sequel::Postgres::AutoParameterize::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Postgres/AutoParameterize/StringWithArray.html">Sequel::Postgres::AutoParameterize::StringWithArray</a></li>
        
          <li><a href="../Sequel/Postgres/CreateTableGenerator.html">Sequel::Postgres::CreateTableGenerator</a></li>
        
          <li><a href="../Sequel/Postgres/Database.html">Sequel::Postgres::Database</a></li>
        
          <li><a href="../Sequel/Postgres/DatabaseMethods.html">Sequel::Postgres::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/Dataset.html">Sequel::Postgres::Dataset</a></li>
        
          <li><a href="../Sequel/Postgres/Dataset/ArgumentMapper.html">Sequel::Postgres::Dataset::ArgumentMapper</a></li>
        
          <li><a href="../Sequel/Postgres/Dataset/BindArgumentMethods.html">Sequel::Postgres::Dataset::BindArgumentMethods</a></li>
        
          <li><a href="../Sequel/Postgres/Dataset/PreparedStatementMethods.html">Sequel::Postgres::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/Postgres/DatasetMethods.html">Sequel::Postgres::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Postgres/DatasetMethods/PreparedStatementMethods.html">Sequel::Postgres::DatasetMethods::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/Postgres/HStore.html">Sequel::Postgres::HStore</a></li>
        
          <li><a href="../Sequel/Postgres/HStore/DatabaseMethods.html">Sequel::Postgres::HStore::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/HStore/Parser.html">Sequel::Postgres::HStore::Parser</a></li>
        
          <li><a href="../Sequel/Postgres/HStoreOp.html">Sequel::Postgres::HStoreOp</a></li>
        
          <li><a href="../Sequel/Postgres/HStoreOpMethods.html">Sequel::Postgres::HStoreOpMethods</a></li>
        
          <li><a href="../Sequel/Postgres/InetDatabaseMethods.html">Sequel::Postgres::InetDatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/InetDatasetMethods.html">Sequel::Postgres::InetDatasetMethods</a></li>
        
          <li><a href="../Sequel/Postgres/IntervalDatabaseMethods.html">Sequel::Postgres::IntervalDatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/IntervalDatabaseMethods/Parser.html">Sequel::Postgres::IntervalDatabaseMethods::Parser</a></li>
        
          <li><a href="../Sequel/Postgres/IntervalDatasetMethods.html">Sequel::Postgres::IntervalDatasetMethods</a></li>
        
          <li><a href="../Sequel/Postgres/JSONArray.html">Sequel::Postgres::JSONArray</a></li>
        
          <li><a href="../Sequel/Postgres/JSONDatabaseMethods.html">Sequel::Postgres::JSONDatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/JSONHash.html">Sequel::Postgres::JSONHash</a></li>
        
          <li><a href="../Sequel/Postgres/PGArray.html">Sequel::Postgres::PGArray</a></li>
        
          <li><a href="../Sequel/Postgres/PGArray/Creator.html">Sequel::Postgres::PGArray::Creator</a></li>
        
          <li><a href="../Sequel/Postgres/PGArray/DatabaseMethods.html">Sequel::Postgres::PGArray::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/PGArray/JSONCreator.html">Sequel::Postgres::PGArray::JSONCreator</a></li>
        
          <li><a href="../Sequel/Postgres/PGArray/Parser.html">Sequel::Postgres::PGArray::Parser</a></li>
        
          <li><a href="../Sequel/Postgres/PGRange.html">Sequel::Postgres::PGRange</a></li>
        
          <li><a href="../Sequel/Postgres/PGRange/DatabaseMethods.html">Sequel::Postgres::PGRange::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/PGRange/DatasetMethods.html">Sequel::Postgres::PGRange::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Postgres/PGRange/Parser.html">Sequel::Postgres::PGRange::Parser</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow.html">Sequel::Postgres::PGRow</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow/ArrayRow.html">Sequel::Postgres::PGRow::ArrayRow</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow/DatabaseMethods.html">Sequel::Postgres::PGRow::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow/HashRow.html">Sequel::Postgres::PGRow::HashRow</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow/Parser.html">Sequel::Postgres::PGRow::Parser</a></li>
        
          <li><a href="../Sequel/Postgres/PGRow/Splitter.html">Sequel::Postgres::PGRow::Splitter</a></li>
        
          <li><a href="../Sequel/Postgres/PGRowOp.html">Sequel::Postgres::PGRowOp</a></li>
        
          <li><a href="../Sequel/Postgres/PGRowOp/ExpressionMethods.html">Sequel::Postgres::PGRowOp::ExpressionMethods</a></li>
        
          <li><a href="../Sequel/Postgres/RangeOp.html">Sequel::Postgres::RangeOp</a></li>
        
          <li><a href="../Sequel/Postgres/RangeOpMethods.html">Sequel::Postgres::RangeOpMethods</a></li>
        
          <li><a href="../Sequel/Postgres/StatementCache.html">Sequel::Postgres::StatementCache</a></li>
        
          <li><a href="../Sequel/Postgres/StatementCache/AdapterMethods.html">Sequel::Postgres::StatementCache::AdapterMethods</a></li>
        
          <li><a href="../Sequel/Postgres/StatementCache/DatabaseMethods.html">Sequel::Postgres::StatementCache::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Postgres/StatementCache/Statement.html">Sequel::Postgres::StatementCache::Statement</a></li>
        
          <li><a href="../Sequel/Postgres/StatementCache/StatementCache.html">Sequel::Postgres::StatementCache::StatementCache</a></li>
        
          <li><a href="../Sequel/PrettyTable.html">Sequel::PrettyTable</a></li>
        
          <li><a href="../Sequel/Progress.html">Sequel::Progress</a></li>
        
          <li><a href="../Sequel/Progress/DatabaseMethods.html">Sequel::Progress::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Progress/DatasetMethods.html">Sequel::Progress::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Qualifier.html">Sequel::Qualifier</a></li>
        
          <li><a href="../Sequel/QueryLiterals.html">Sequel::QueryLiterals</a></li>
        
          <li><a href="../Sequel/Rollback.html">Sequel::Rollback</a></li>
        
          <li><a href="../Sequel/SQL.html">Sequel::SQL</a></li>
        
          <li><a href="../Sequel/SQL/AliasMethods.html">Sequel::SQL::AliasMethods</a></li>
        
          <li><a href="../Sequel/SQL/AliasedExpression.html">Sequel::SQL::AliasedExpression</a></li>
        
          <li><a href="../Sequel/SQL/BitwiseMethods.html">Sequel::SQL::BitwiseMethods</a></li>
        
          <li><a href="../Sequel/SQL/Blob.html">Sequel::SQL::Blob</a></li>
        
          <li><a href="../Sequel/SQL/BooleanConstant.html">Sequel::SQL::BooleanConstant</a></li>
        
          <li><a href="../Sequel/SQL/BooleanExpression.html">Sequel::SQL::BooleanExpression</a></li>
        
          <li><a href="../Sequel/SQL/BooleanMethods.html">Sequel::SQL::BooleanMethods</a></li>
        
          <li><a href="../Sequel/SQL/Builders.html">Sequel::SQL::Builders</a></li>
        
          <li><a href="../Sequel/SQL/CaseExpression.html">Sequel::SQL::CaseExpression</a></li>
        
          <li><a href="../Sequel/SQL/Cast.html">Sequel::SQL::Cast</a></li>
        
          <li><a href="../Sequel/SQL/CastMethods.html">Sequel::SQL::CastMethods</a></li>
        
          <li><a href="../Sequel/SQL/ColumnAll.html">Sequel::SQL::ColumnAll</a></li>
        
          <li><a href="../Sequel/SQL/ComplexExpression.html">Sequel::SQL::ComplexExpression</a></li>
        
          <li><a href="../Sequel/SQL/ComplexExpressionMethods.html">Sequel::SQL::ComplexExpressionMethods</a></li>
        
          <li><a href="../Sequel/SQL/Constant.html">Sequel::SQL::Constant</a></li>
        
          <li><a href="../Sequel/SQL/Constants.html">Sequel::SQL::Constants</a></li>
        
          <li><a href="../Sequel/SQL/DelayedEvaluation.html">Sequel::SQL::DelayedEvaluation</a></li>
        
          <li><a href="../Sequel/SQL/EmulatedFunction.html">Sequel::SQL::EmulatedFunction</a></li>
        
          <li><a href="../Sequel/SQL/Expression.html">Sequel::SQL::Expression</a></li>
        
          <li><a href="../Sequel/SQL/Function.html">Sequel::SQL::Function</a></li>
        
          <li><a href="../Sequel/SQL/GenericExpression.html">Sequel::SQL::GenericExpression</a></li>
        
          <li><a href="../Sequel/SQL/Identifier.html">Sequel::SQL::Identifier</a></li>
        
          <li><a href="../Sequel/SQL/InequalityMethods.html">Sequel::SQL::InequalityMethods</a></li>
        
          <li><a href="../Sequel/SQL/JoinClause.html">Sequel::SQL::JoinClause</a></li>
        
          <li><a href="../Sequel/SQL/JoinOnClause.html">Sequel::SQL::JoinOnClause</a></li>
        
          <li><a href="../Sequel/SQL/JoinUsingClause.html">Sequel::SQL::JoinUsingClause</a></li>
        
          <li><a href="../Sequel/SQL/NegativeBooleanConstant.html">Sequel::SQL::NegativeBooleanConstant</a></li>
        
          <li><a href="../Sequel/SQL/NoBooleanInputMethods.html">Sequel::SQL::NoBooleanInputMethods</a></li>
        
          <li><a href="../Sequel/SQL/NumericExpression.html">Sequel::SQL::NumericExpression</a></li>
        
          <li><a href="../Sequel/SQL/NumericMethods.html">Sequel::SQL::NumericMethods</a></li>
        
          <li><a href="../Sequel/SQL/OperatorBuilders.html">Sequel::SQL::OperatorBuilders</a></li>
        
          <li><a href="../Sequel/SQL/OrderMethods.html">Sequel::SQL::OrderMethods</a></li>
        
          <li><a href="../Sequel/SQL/OrderedExpression.html">Sequel::SQL::OrderedExpression</a></li>
        
          <li><a href="../Sequel/SQL/PlaceholderLiteralString.html">Sequel::SQL::PlaceholderLiteralString</a></li>
        
          <li><a href="../Sequel/SQL/QualifiedIdentifier.html">Sequel::SQL::QualifiedIdentifier</a></li>
        
          <li><a href="../Sequel/SQL/QualifyingMethods.html">Sequel::SQL::QualifyingMethods</a></li>
        
          <li><a href="../Sequel/SQL/ValueList.html">Sequel::SQL::SQLArray</a></li>
        
          <li><a href="../Sequel/SQL/StringConcatenationMethods.html">Sequel::SQL::StringConcatenationMethods</a></li>
        
          <li><a href="../Sequel/SQL/StringExpression.html">Sequel::SQL::StringExpression</a></li>
        
          <li><a href="../Sequel/SQL/StringMethods.html">Sequel::SQL::StringMethods</a></li>
        
          <li><a href="../Sequel/SQL/Subscript.html">Sequel::SQL::Subscript</a></li>
        
          <li><a href="../Sequel/SQL/SubscriptMethods.html">Sequel::SQL::SubscriptMethods</a></li>
        
          <li><a href="../Sequel/SQL/ValueList.html">Sequel::SQL::ValueList</a></li>
        
          <li><a href="../Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a></li>
        
          <li><a href="../Sequel/SQL/Window.html">Sequel::SQL::Window</a></li>
        
          <li><a href="../Sequel/SQL/WindowFunction.html">Sequel::SQL::WindowFunction</a></li>
        
          <li><a href="../Sequel/SQL/Wrapper.html">Sequel::SQL::Wrapper</a></li>
        
          <li><a href="../Sequel/SQLTime.html">Sequel::SQLTime</a></li>
        
          <li><a href="../Sequel/SQLite.html">Sequel::SQLite</a></li>
        
          <li><a href="../Sequel/SQLite/Database.html">Sequel::SQLite::Database</a></li>
        
          <li><a href="../Sequel/SQLite/DatabaseMethods.html">Sequel::SQLite::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/SQLite/Dataset.html">Sequel::SQLite::Dataset</a></li>
        
          <li><a href="../Sequel/SQLite/Dataset/ArgumentMapper.html">Sequel::SQLite::Dataset::ArgumentMapper</a></li>
        
          <li><a href="../Sequel/SQLite/Dataset/BindArgumentMethods.html">Sequel::SQLite::Dataset::BindArgumentMethods</a></li>
        
          <li><a href="../Sequel/SQLite/Dataset/PreparedStatementMethods.html">Sequel::SQLite::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/SQLite/DatasetMethods.html">Sequel::SQLite::DatasetMethods</a></li>
        
          <li><a href="../Sequel/Schema.html">Sequel::Schema</a></li>
        
          <li><a href="../Sequel/Schema/AlterTableGenerator.html">Sequel::Schema::AlterTableGenerator</a></li>
        
          <li><a href="../Sequel/Schema/CreateTableGenerator.html">Sequel::Schema::CreateTableGenerator</a></li>
        
          <li><a href="../Sequel/Schema/CreateTableGenerator.html">Sequel::Schema::Generator</a></li>
        
          <li><a href="../Sequel/ServerBlock.html">Sequel::ServerBlock</a></li>
        
          <li><a href="../Sequel/ShardedSingleConnectionPool.html">Sequel::ShardedSingleConnectionPool</a></li>
        
          <li><a href="../Sequel/ShardedThreadedConnectionPool.html">Sequel::ShardedThreadedConnectionPool</a></li>
        
          <li><a href="../Sequel/SimpleMigration.html">Sequel::SimpleMigration</a></li>
        
          <li><a href="../Sequel/SingleConnectionPool.html">Sequel::SingleConnectionPool</a></li>
        
          <li><a href="../Sequel/Swift.html">Sequel::Swift</a></li>
        
          <li><a href="../Sequel/Swift/Database.html">Sequel::Swift::Database</a></li>
        
          <li><a href="../Sequel/Swift/Dataset.html">Sequel::Swift::Dataset</a></li>
        
          <li><a href="../Sequel/Swift/MySQL.html">Sequel::Swift::MySQL</a></li>
        
          <li><a href="../Sequel/Swift/MySQL/DatabaseMethods.html">Sequel::Swift::MySQL::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Swift/MySQL/Dataset.html">Sequel::Swift::MySQL::Dataset</a></li>
        
          <li><a href="../Sequel/Swift/Postgres.html">Sequel::Swift::Postgres</a></li>
        
          <li><a href="../Sequel/Swift/Postgres/DatabaseMethods.html">Sequel::Swift::Postgres::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Swift/SQLite.html">Sequel::Swift::SQLite</a></li>
        
          <li><a href="../Sequel/Swift/SQLite/DatabaseMethods.html">Sequel::Swift::SQLite::DatabaseMethods</a></li>
        
          <li><a href="../Sequel/Swift/SQLite/Dataset.html">Sequel::Swift::SQLite::Dataset</a></li>
        
          <li><a href="../Sequel/ThreadLocalTimezones.html">Sequel::ThreadLocalTimezones</a></li>
        
          <li><a href="../Sequel/ThreadedConnectionPool.html">Sequel::ThreadedConnectionPool</a></li>
        
          <li><a href="../Sequel/ThreadedServerBlock.html">Sequel::ThreadedServerBlock</a></li>
        
          <li><a href="../Sequel/TimestampMigrator.html">Sequel::TimestampMigrator</a></li>
        
          <li><a href="../Sequel/Timezones.html">Sequel::Timezones</a></li>
        
          <li><a href="../Sequel/TinyTDS.html">Sequel::TinyTDS</a></li>
        
          <li><a href="../Sequel/TinyTDS/Database.html">Sequel::TinyTDS::Database</a></li>
        
          <li><a href="../Sequel/TinyTDS/Dataset.html">Sequel::TinyTDS::Dataset</a></li>
        
          <li><a href="../Sequel/TinyTDS/Dataset/ArgumentMapper.html">Sequel::TinyTDS::Dataset::ArgumentMapper</a></li>
        
          <li><a href="../Sequel/TinyTDS/Dataset/PreparedStatementMethods.html">Sequel::TinyTDS::Dataset::PreparedStatementMethods</a></li>
        
          <li><a href="../Sequel/ToDot.html">Sequel::ToDot</a></li>
        
          <li><a href="../Sequel/UnbindDuplicate.html">Sequel::UnbindDuplicate</a></li>
        
          <li><a href="../Sequel/Unbinder.html">Sequel::Unbinder</a></li>
        
          <li><a href="../Sequel/UndefinedAssociation.html">Sequel::UndefinedAssociation</a></li>
        
          <li><a href="../Sequel/UnthreadedServerBlock.html">Sequel::UnthreadedServerBlock</a></li>
        
          <li><a href="../Sequel/ValidationFailed.html">Sequel::ValidationFailed</a></li>
        
          <li><a href="../String.html">String</a></li>
        
          <li><a href="../String/Inflections.html">String::Inflections</a></li>
        
          <li><a href="../Array.html">Array</a></li>
        
          <li><a href="../FalseClass.html">FalseClass</a></li>
        
          <li><a href="../Hash.html">Hash</a></li>
        
          <li><a href="../NilClass.html">NilClass</a></li>
        
          <li><a href="../Numeric.html">Numeric</a></li>
        
          <li><a href="../Object.html">Object</a></li>
        
          <li><a href="../PGconn.html">PGconn</a></li>
        
          <li><a href="../PGresult.html">PGresult</a></li>
        
          <li><a href="../Range.html">Range</a></li>
        
          <li><a href="../Symbol.html">Symbol</a></li>
        
          <li><a href="../TrueClass.html">TrueClass</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Sequel::Dataset</h1>

    <div id="description" class="description">
      
<p>A dataset represents an <a href="SQL.html">SQL</a> query, or more
generally, an abstract set of rows in the database.  Datasets can be used
to create, retrieve, update and delete records.</p>

<p>Query results are always retrieved on demand, so a dataset can be kept
around and reused indefinitely (datasets never cache results):</p>

<pre>my_posts = DB[:posts].filter(:author =&gt; 'david') # no records are retrieved
my_posts.all # records are retrieved
my_posts.all # records are retrieved again</pre>

<p>Most dataset methods return modified copies of the dataset (functional
style), so you can reuse different datasets to access data:</p>

<pre>posts = DB[:posts]
davids_posts = posts.filter(:author =&gt; 'david')
old_posts = posts.filter('stamp &lt; ?', Date.today - 7)
davids_old_posts = davids_posts.filter('stamp &lt; ?', Date.today - 7)</pre>

<p>Datasets are Enumerable objects, so they can be manipulated using any of
the Enumerable methods, such as map, inject, etc.</p>

<p>For more information, see the <a
href="../files/doc/dataset_basics_rdoc.html">"Dataset Basics" guide</a>.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
    </div><!-- 5Buntitled-5D -->
  
    
    
    <div id="1+-+Methods+that+return+modified+datasets" class="documentation-section">
      
      <h2 class="section-header">
        1 - Methods that return modified datasets
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods all return modified copies of the receiver.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="COLUMN_CHANGE_OPTS">COLUMN_CHANGE_OPTS</a></dt>
          
          <dd class="description"><p>The dataset options that require the removal of cached columns if changed.</p></dd>
          
        
          <dt><a name="CONDITIONED_JOIN_TYPES">CONDITIONED_JOIN_TYPES</a></dt>
          
          <dd class="description"><p>These symbols have _join methods created (e.g. inner_join) that call <a
href="Dataset.html#method-i-join_table">join_table</a> with the symbol,
passing along the arguments and block from the method call.</p></dd>
          
        
          <dt><a name="EXTENSIONS">EXTENSIONS</a></dt>
          
          <dd class="description"><p><a href="../Hash.html">Hash</a> of extension name symbols to callable
objects to load the extension into the <a href="Dataset.html">Dataset</a>
object (usually by extending it with a module defined in the extension).</p></dd>
          
        
          <dt><a name="JOIN_METHODS">JOIN_METHODS</a></dt>
          
          <dd class="description"><p>All methods that return modified datasets with a joined table added.</p></dd>
          
        
          <dt><a name="NON_SQL_OPTIONS">NON_SQL_OPTIONS</a></dt>
          
          <dd class="description"><p>Which options don't affect the <a href="SQL.html">SQL</a> generation.  Used
by simple_select_all? to determine if this is a simple <a
href="Dataset.html#SELECT">SELECT</a> * <a
href="Dataset.html#FROM">FROM</a> table.</p></dd>
          
        
          <dt><a name="QUERY_METHODS">QUERY_METHODS</a></dt>
          
          <dd class="description"><p>Methods that return modified datasets</p></dd>
          
        
          <dt><a name="UNCONDITIONED_JOIN_TYPES">UNCONDITIONED_JOIN_TYPES</a></dt>
          
          <dd class="description"><p>These symbols have _join methods created (e.g. natural_join) that call <a
href="Dataset.html#method-i-join_table">join_table</a> with the symbol. 
They only accept a single table argument which is passed to <a
href="Dataset.html#method-i-join_table">join_table</a>, and they raise an
error if called with a block.</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="register_extension-method" class="method-detail ">
          <a name="method-c-register_extension"></a>

          
          <div class="method-heading">
            <span class="method-name">register_extension</span><span
              class="method-args">(ext, mod=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Register an extension callback for <a href="Dataset.html">Dataset</a>
objects.  ext should be the extension name symbol, and mod should either be
a Module that the dataset is extended with, or a callable object called
with the database object.  If mod is not provided, a block can be provided
and is treated as the mod object.</p>

<p>If mod is a module, this also registers a <a
href="Database.html">Database</a> extension that will extend all of the
database's datasets.</p>
            

            
            <div class="method-source-code" id="register_extension-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">register_extension</span>(<span class="ruby-identifier">ext</span>, <span class="ruby-identifier">mod</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">mod</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;cannot provide both mod and block to Dataset.register_extension&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">mod</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Module</span>)
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">mod</span>)}
      <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Database</span>.<span class="ruby-identifier">register_extension</span>(<span class="ruby-identifier">ext</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">db</span><span class="ruby-operator">|</span> <span class="ruby-identifier">db</span>.<span class="ruby-identifier">extend_datasets</span>(<span class="ruby-identifier">mod</span>)}
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">mod</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">synchronize</span>{<span class="ruby-constant">EXTENSIONS</span>[<span class="ruby-identifier">ext</span>] = <span class="ruby-identifier">block</span>}
<span class="ruby-keyword">end</span></pre>
            </div><!-- register_extension-source -->
            
          </div>

          

          
        </div><!-- register_extension-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="and-method" class="method-detail ">
          <a name="method-i-and"></a>

          
          <div class="method-heading">
            <span class="method-name">and</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds an further filter to an existing filter using AND. If no filter 
exists an error is raised. This method is identical to <a
href="Dataset.html#method-i-filter">filter</a> except it expects an
existing filter.</p>

<pre>DB[:table].filter(:a).and(:b) # SELECT * FROM table WHERE a AND b</pre>
            

            
            <div class="method-source-code" id="and-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 71</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">and</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;No existing filter found.&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:having</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:where</span>]
  <span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- and-source -->
            
          </div>

          

          
        </div><!-- and-method -->

      
        <div id="clone-method" class="method-detail ">
          <a name="method-i-clone"></a>

          
          <div class="method-heading">
            <span class="method-name">clone</span><span
              class="method-args">(opts = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a new clone of the dataset with with the given options merged. If
the options changed include options in <a
href="Dataset.html#COLUMN_CHANGE_OPTS">COLUMN_CHANGE_OPTS</a>, the cached
columns are deleted.  This method should generally not be called directly
by user code.</p>
            

            
            <div class="method-source-code" id="clone-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">opts</span> = {})
  <span class="ruby-identifier">c</span> = <span class="ruby-keyword">super</span>()
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">opts</span> = <span class="ruby-ivar">@opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@columns</span>, <span class="ruby-keyword">nil</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">any?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-constant">COLUMN_CHANGE_OPTS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">o</span>)}
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- clone-source -->
            
          </div>

          

          
        </div><!-- clone-method -->

      
        <div id="distinct-method" class="method-detail ">
          <a name="method-i-distinct"></a>

          
          <div class="method-heading">
            <span class="method-name">distinct</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the <a href="SQL.html">SQL</a> <a
href="Dataset.html#DISTINCT">DISTINCT</a> clause. The <a
href="Dataset.html#DISTINCT">DISTINCT</a> clause is used to remove
duplicate rows from the output.  If arguments are provided, uses a <a
href="Dataset.html#DISTINCT">DISTINCT</a> <a href="Dataset.html#ON">ON</a>
clause, in which case it will only be distinct on those columns, instead of
all returned columns.  Raises an error if arguments are given and <a
href="Dataset.html#DISTINCT">DISTINCT</a> <a href="Dataset.html#ON">ON</a>
is not supported.</p>

<pre>DB[:items].distinct # SQL: SELECT DISTINCT * FROM items
DB[:items].order(:id).distinct(:id) # SQL: SELECT DISTINCT ON (id) * FROM items ORDER BY id</pre>
            

            
            <div class="method-source-code" id="distinct-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">distinct</span>(*<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;DISTINCT ON not supported&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_distinct_on?</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:distinct</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- distinct-source -->
            
          </div>

          

          
        </div><!-- distinct-method -->

      
        <div id="except-method" class="method-detail ">
          <a name="method-i-except"></a>

          
          <div class="method-heading">
            <span class="method-name">except</span><span
              class="method-args">(dataset, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds an EXCEPT clause using a second dataset object. An EXCEPT compound
dataset returns all rows in the current dataset that are not in the given
dataset. Raises an <tt>InvalidOperation</tt> if the operation is not
supported. Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:alias </p></td>
<td>
<p>Use the given value as the <a
href="Dataset.html#method-i-from_self">from_self</a> alias</p>
</td></tr><tr><td class="rdoc-term"><p>:all </p></td>
<td>
<p>Set to true to use EXCEPT <a href="Dataset.html#ALL">ALL</a> instead of
EXCEPT, so duplicate rows can occur</p>
</td></tr><tr><td class="rdoc-term"><p>:<a href="Dataset.html#method-i-from_self">from_self</a> </p></td>
<td>
<p>Set to false to not wrap the returned dataset in a <a
href="Dataset.html#method-i-from_self">from_self</a>, use with care.</p>
</td></tr></table>

<pre>DB[:items].except(DB[:other_items])
# SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS t1

DB[:items].except(DB[:other_items], :all=&gt;true, :from_self=&gt;false)
# SELECT * FROM items EXCEPT ALL SELECT * FROM other_items

DB[:items].except(DB[:other_items], :alias=&gt;:i)
# SELECT * FROM (SELECT * FROM items EXCEPT SELECT * FROM other_items) AS i</pre>
            

            
            <div class="method-source-code" id="except-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">except</span>(<span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:all=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">opts</span>} <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;EXCEPT not supported&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_intersect_except?</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;EXCEPT ALL not supported&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_intersect_except_all?</span>
  <span class="ruby-identifier">compound_clone</span>(<span class="ruby-value">:except</span>, <span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- except-source -->
            
          </div>

          

          
        </div><!-- except-method -->

      
        <div id="exclude-method" class="method-detail ">
          <a name="method-i-exclude"></a>

          
          <div class="method-heading">
            <span class="method-name">exclude</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Performs the inverse of <a
href="Dataset.html#method-i-filter">Dataset#filter</a>.  Note that if you
have multiple filter conditions, this is not the same as a negation of all
conditions.</p>

<pre>DB[:items].exclude(:category =&gt; 'software')
# SELECT * FROM items WHERE (category != 'software')

DB[:items].exclude(:category =&gt; 'software', :id=&gt;3)
# SELECT * FROM items WHERE ((category != 'software') OR (id != 3))</pre>
            

            
            <div class="method-source-code" id="exclude-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exclude</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter_or_exclude</span>(<span class="ruby-keyword">true</span>, <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:having</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:having</span> <span class="ruby-operator">:</span> <span class="ruby-value">:where</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- exclude-source -->
            
          </div>

          

          
        </div><!-- exclude-method -->

      
        <div id="exclude_having-method" class="method-detail ">
          <a name="method-i-exclude_having"></a>

          
          <div class="method-heading">
            <span class="method-name">exclude_having</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inverts the given conditions and adds them to the <a
href="Dataset.html#HAVING">HAVING</a> clause.</p>

<pre>DB[:items].select_group(:name).exclude_having{count(name) &lt; 2}
# SELECT name FROM items GROUP BY name HAVING (count(name) &gt;= 2)</pre>
            

            
            <div class="method-source-code" id="exclude_having-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exclude_having</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter_or_exclude</span>(<span class="ruby-keyword">true</span>, <span class="ruby-value">:having</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- exclude_having-source -->
            
          </div>

          

          
        </div><!-- exclude_having-method -->

      
        <div id="exclude_where-method" class="method-detail ">
          <a name="method-i-exclude_where"></a>

          
          <div class="method-heading">
            <span class="method-name">exclude_where</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inverts the given conditions and adds them to the <a
href="Dataset.html#WHERE">WHERE</a> clause.</p>

<pre>DB[:items].select_group(:name).exclude_where(:category =&gt; 'software')
# SELECT * FROM items WHERE (category != 'software')

DB[:items].select_group(:name).
  exclude_having{count(name) &lt; 2}.
  exclude_where(:category =&gt; 'software')
# SELECT name FROM items WHERE (category != 'software')
# GROUP BY name HAVING (count(name) &gt;= 2)</pre>
            

            
            <div class="method-source-code" id="exclude_where-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exclude_where</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter_or_exclude</span>(<span class="ruby-keyword">true</span>, <span class="ruby-value">:where</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- exclude_where-source -->
            
          </div>

          

          
        </div><!-- exclude_where-method -->

      
        <div id="extension-method" class="method-detail ">
          <a name="method-i-extension"></a>

          
          <div class="method-heading">
            <span class="method-name">extension</span><span
              class="method-args">(*exts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a clone of the dataset loaded with the extensions, see <a
href="Dataset.html#method-i-extension-21">extension!</a>.</p>
            

            
            <div class="method-source-code" id="extension-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">extension</span>(*<span class="ruby-identifier">exts</span>)
  <span class="ruby-identifier">clone</span>.<span class="ruby-identifier">extension!</span>(*<span class="ruby-identifier">exts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- extension-source -->
            
          </div>

          

          
        </div><!-- extension-method -->

      
        <div id="extension-21-method" class="method-detail ">
          <a name="method-i-extension-21"></a>

          
          <div class="method-heading">
            <span class="method-name">extension!</span><span
              class="method-args">(*exts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Load an extension into the receiver.  In addition to requiring the
extension file, this also modifies the dataset to work with the extension
(usually extending it with a module defined in the extension file).  If no
related extension file exists or the extension does not have specific
support for <a href="Database.html">Database</a> objects, an <a
href="Error.html">Error</a> will be raised. Returns self.</p>
            

            
            <div class="method-source-code" id="extension-21-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">extension!</span>(*<span class="ruby-identifier">exts</span>)
  <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extension</span>(*<span class="ruby-identifier">exts</span>)
  <span class="ruby-identifier">exts</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ext</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">pr</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">synchronize</span>{<span class="ruby-constant">EXTENSIONS</span>[<span class="ruby-identifier">ext</span>]}
      <span class="ruby-identifier">pr</span>.<span class="ruby-identifier">call</span>(<span class="ruby-keyword">self</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;Extension #{ext} does not have specific support handling individual datasets&quot;</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- extension-21-source -->
            
          </div>

          

          
        </div><!-- extension-21-method -->

      
        <div id="filter-method" class="method-detail ">
          <a name="method-i-filter"></a>

          
          <div class="method-heading">
            <span class="method-name">filter</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the given conditions imposed upon it.  
If the query already has a <a href="Dataset.html#HAVING">HAVING</a> clause,
then the conditions are imposed in the  <a
href="Dataset.html#HAVING">HAVING</a> clause. If not, then they are imposed
in the <a href="Dataset.html#WHERE">WHERE</a> clause.</p>

<p>filter accepts the following argument types:</p>
<ul><li>
<p><a href="../Hash.html">Hash</a> - list of equality/inclusion expressions</p>
</li><li>
<p><a href="../Array.html">Array</a> - depends:</p>
<ul><li>
<p>If first member is a string, assumes the rest of the arguments are
parameters and interpolates them into the string.</p>
</li><li>
<p>If all members are arrays of length two, treats the same way as a hash,
except it allows for duplicate keys to be specified.</p>
</li><li>
<p>Otherwise, treats each argument as a separate condition.</p>
</li></ul>
</li><li>
<p><a href="../String.html">String</a> - taken literally</p>
</li><li>
<p><a href="../Symbol.html">Symbol</a> - taken as a boolean column argument
(e.g. <a href="Dataset.html#WHERE">WHERE</a> active)</p>
</li><li>
<p><a href="SQL/BooleanExpression.html">Sequel::SQL::BooleanExpression</a> -
an existing condition expression, probably created using the <a
href="../Sequel.html">Sequel</a> expression filter DSL.</p>
</li></ul>

<p>filter also takes a block, which should return one of the above argument
types, and is treated the same way.  This block yields a virtual row
object, which is easy to use to create identifiers and functions.  For more
details on the virtual row support, see the <a
href="../files/doc/virtual_rows_rdoc.html">"Virtual Rows" guide</a></p>

<p>If both a block and regular argument are provided, they get ANDed together.</p>

<p>Examples:</p>

<pre>DB[:items].filter(:id =&gt; 3)
# SELECT * FROM items WHERE (id = 3)

DB[:items].filter('price &lt; ?', 100)
# SELECT * FROM items WHERE price &lt; 100

DB[:items].filter([[:id, [1,2,3]], [:id, 0..10]])
# SELECT * FROM items WHERE ((id IN (1, 2, 3)) AND ((id &gt;= 0) AND (id &lt;= 10)))

DB[:items].filter('price &lt; 100')
# SELECT * FROM items WHERE price &lt; 100

DB[:items].filter(:active)
# SELECT * FROM items WHERE :active

DB[:items].filter{price &lt; 100}
# SELECT * FROM items WHERE (price &lt; 100)</pre>

<p>Multiple filter calls can be chained for scoping:</p>

<pre>software = dataset.filter(:category =&gt; 'software').filter{price &lt; 100}
# SELECT * FROM items WHERE ((category = 'software') AND (price &lt; 100))</pre>

<p>See the the <a href="../files/doc/dataset_filtering_rdoc.html">"Dataset
Filtering" guide</a> for more examples and details.</p>
            

            
            <div class="method-source-code" id="filter-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:having</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:having</span> <span class="ruby-operator">:</span> <span class="ruby-value">:where</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- filter-source -->
            
          </div>

          

          
        </div><!-- filter-method -->

      
        <div id="for_update-method" class="method-detail ">
          <a name="method-i-for_update"></a>

          
          <div class="method-heading">
            <span class="method-name">for_update</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a cloned dataset with a :update lock style.</p>

<pre>DB[:table].for_update # SELECT * FROM table FOR UPDATE</pre>
            

            
            <div class="method-source-code" id="for_update-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">for_update</span>
  <span class="ruby-identifier">lock_style</span>(<span class="ruby-value">:update</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- for_update-source -->
            
          </div>

          

          
        </div><!-- for_update-method -->

      
        <div id="from-method" class="method-detail ">
          <a name="method-i-from"></a>

          
          <div class="method-heading">
            <span class="method-name">from</span><span
              class="method-args">(*source)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the source changed. If no source is
given, removes all tables.  If multiple sources are given, it is the same
as using a CROSS JOIN (cartesian product) between all tables.</p>

<pre>DB[:items].from # SQL: SELECT *
DB[:items].from(:blah) # SQL: SELECT * FROM blah
DB[:items].from(:blah, :foo) # SQL: SELECT * FROM blah, foo</pre>
            

            
            <div class="method-source-code" id="from-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">from</span>(*<span class="ruby-identifier">source</span>)
  <span class="ruby-identifier">table_alias_num</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">sources</span> = []
  <span class="ruby-identifier">ctes</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">source</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">s</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
      <span class="ruby-identifier">s</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sources</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span>)}
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Dataset</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">s</span>)
        <span class="ruby-identifier">ctes</span> <span class="ruby-operator">||=</span> []
        <span class="ruby-identifier">ctes</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:with</span>]
        <span class="ruby-identifier">s</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-value">:with=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">sources</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">s</span>, <span class="ruby-identifier">dataset_alias</span>(<span class="ruby-identifier">table_alias_num</span><span class="ruby-operator">+=</span><span class="ruby-value">1</span>))
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
      <span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">aliaz</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">s</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">aliaz</span>
        <span class="ruby-identifier">s</span> = <span class="ruby-identifier">sch</span> <span class="ruby-operator">?</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table</span>) <span class="ruby-operator">:</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table</span>)
        <span class="ruby-identifier">sources</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">s</span>, <span class="ruby-identifier">aliaz</span>.<span class="ruby-identifier">to_sym</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">sources</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">sources</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">o</span> = {<span class="ruby-value">:from=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">sources</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sources</span>}
  <span class="ruby-identifier">o</span>[<span class="ruby-value">:with</span>] = (<span class="ruby-identifier">opts</span>[<span class="ruby-value">:with</span>] <span class="ruby-operator">||</span> []) <span class="ruby-operator">+</span> <span class="ruby-identifier">ctes</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">ctes</span>
  <span class="ruby-identifier">o</span>[<span class="ruby-value">:num_dataset_sources</span>] = <span class="ruby-identifier">table_alias_num</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">table_alias_num</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">o</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- from-source -->
            
          </div>

          

          
        </div><!-- from-method -->

      
        <div id="from_self-method" class="method-detail ">
          <a name="method-i-from_self"></a>

          
          <div class="method-heading">
            <span class="method-name">from_self</span><span
              class="method-args">(opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a dataset selecting from the current dataset. Supplying the :alias
option controls the alias of the result.</p>

<pre>ds = DB[:items].order(:name).select(:id, :name)
# SELECT id,name FROM items ORDER BY name

ds.from_self
# SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS t1

ds.from_self(:alias=&gt;:foo)
# SELECT * FROM (SELECT id, name FROM items ORDER BY name) AS foo</pre>
            

            
            <div class="method-source-code" id="from_self-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">from_self</span>(<span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">fs</span> = {}
  <span class="ruby-ivar">@opts</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fs</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">NON_SQL_OPTIONS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">k</span>)}
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">fs</span>).<span class="ruby-identifier">from</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:alias</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">as</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:alias</span>]) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- from_self-source -->
            
          </div>

          

          
        </div><!-- from_self-method -->

      
        <div id="grep-method" class="method-detail ">
          <a name="method-i-grep"></a>

          
          <div class="method-heading">
            <span class="method-name">grep</span><span
              class="method-args">(columns, patterns, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Match any of the columns to any of the patterns. The terms can be strings
(which use LIKE) or regular expressions (which are only supported on <a
href="MySQL.html">MySQL</a> and PostgreSQL).  Note that the total number of
pattern matches will be Array(columns).length * Array(terms).length, which
could cause performance issues.</p>

<p>Options (all are boolean):</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:all_columns </p></td>
<td>
<p>All columns must be matched to any of the given patterns.</p>
</td></tr><tr><td class="rdoc-term"><p>:all_patterns </p></td>
<td>
<p>All patterns must match at least one of the columns.</p>
</td></tr><tr><td class="rdoc-term"><p>:case_insensitive </p></td>
<td>
<p>Use a case insensitive pattern match (the default is case sensitive if the
database supports it).</p>
</td></tr></table>

<p>If both :all_columns and :all_patterns are true, all columns must match all
patterns.</p>

<p>Examples:</p>

<pre>dataset.grep(:a, '%test%')
# SELECT * FROM items WHERE (a LIKE '%test%')

dataset.grep([:a, :b], %w'%test% foo')
# SELECT * FROM items WHERE ((a LIKE '%test%') OR (a LIKE 'foo') OR (b LIKE '%test%') OR (b LIKE 'foo'))

dataset.grep([:a, :b], %w'%foo% %bar%', :all_patterns=&gt;true)
# SELECT * FROM a WHERE (((a LIKE '%foo%') OR (b LIKE '%foo%')) AND ((a LIKE '%bar%') OR (b LIKE '%bar%')))

dataset.grep([:a, :b], %w'%foo% %bar%', :all_columns=&gt;true)
# SELECT * FROM a WHERE (((a LIKE '%foo%') OR (a LIKE '%bar%')) AND ((b LIKE '%foo%') OR (b LIKE '%bar%')))

dataset.grep([:a, :b], %w'%foo% %bar%', :all_patterns=&gt;true, :all_columns=&gt;true)
# SELECT * FROM a WHERE ((a LIKE '%foo%') AND (b LIKE '%foo%') AND (a LIKE '%bar%') AND (b LIKE '%bar%'))</pre>
            

            
            <div class="method-source-code" id="grep-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 332</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">grep</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">patterns</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all_patterns</span>]
    <span class="ruby-identifier">conds</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">patterns</span>).<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">pat</span><span class="ruby-operator">|</span>
      <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:all_columns</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:AND</span> <span class="ruby-operator">:</span> <span class="ruby-value">:OR</span>, *<span class="ruby-constant">Array</span>(<span class="ruby-identifier">columns</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">StringExpression</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">pat</span>, <span class="ruby-identifier">opts</span>)})
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">filter</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:all_patterns</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:AND</span> <span class="ruby-operator">:</span> <span class="ruby-value">:OR</span>, *<span class="ruby-identifier">conds</span>))
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">conds</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">columns</span>).<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
      <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:OR</span>, *<span class="ruby-constant">Array</span>(<span class="ruby-identifier">patterns</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">pat</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">StringExpression</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">c</span>, <span class="ruby-identifier">pat</span>, <span class="ruby-identifier">opts</span>)})
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">filter</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:all_columns</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:AND</span> <span class="ruby-operator">:</span> <span class="ruby-value">:OR</span>, *<span class="ruby-identifier">conds</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- grep-source -->
            
          </div>

          

          
        </div><!-- grep-method -->

      
        <div id="group-method" class="method-detail ">
          <a name="method-i-group"></a>

          
          <div class="method-heading">
            <span class="method-name">group</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the results grouped by the value of  the
given columns.  If a block is given, it is treated as a virtual row block,
similar to <tt>filter</tt>.</p>

<pre>DB[:items].group(:id) # SELECT * FROM items GROUP BY id
DB[:items].group(:id, :name) # SELECT * FROM items GROUP BY id, name
DB[:items].group{[a, sum(b)]} # SELECT * FROM items GROUP BY a, sum(b)</pre>
            

            
            <div class="method-source-code" id="group-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">group</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">virtual_row_columns</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:group</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">columns</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- group-source -->
            
          </div>

          

          
        </div><!-- group-method -->

      
        <div id="group_and_count-method" class="method-detail ">
          <a name="method-i-group_and_count"></a>

          
          <div class="method-heading">
            <span class="method-name">group_and_count</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a dataset grouped by the given column with count by group. Column
aliases may be supplied, and will be included in the select clause. If a
block is given, it is treated as a virtual row block, similar to
<tt>filter</tt>.</p>

<p>Examples:</p>

<pre>DB[:items].group_and_count(:name).all
# SELECT name, count(*) AS count FROM items GROUP BY name 
# =&gt; [{:name=&gt;'a', :count=&gt;1}, ...]

DB[:items].group_and_count(:first_name, :last_name).all
# SELECT first_name, last_name, count(*) AS count FROM items GROUP BY first_name, last_name
# =&gt; [{:first_name=&gt;'a', :last_name=&gt;'b', :count=&gt;1}, ...]

DB[:items].group_and_count(:first_name___name).all
# SELECT first_name AS name, count(*) AS count FROM items GROUP BY first_name
# =&gt; [{:name=&gt;'a', :count=&gt;1}, ...]

DB[:items].group_and_count{substr(first_name, 1, 1).as(initial)}.all
# SELECT substr(first_name, 1, 1) AS initial, count(*) AS count FROM items GROUP BY substr(first_name, 1, 1)
# =&gt; [{:initial=&gt;'a', :count=&gt;1}, ...]</pre>
            

            
            <div class="method-source-code" id="group_and_count-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 384</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">group_and_count</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">select_group</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>).<span class="ruby-identifier">select_more</span>(<span class="ruby-constant">COUNT_OF_ALL_AS_COUNT</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- group_and_count-source -->
            
          </div>

          

          
        </div><!-- group_and_count-method -->

      
        <div id="group_by-method" class="method-detail ">
          <a name="method-i-group_by"></a>

          
          <div class="method-heading">
            <span class="method-name">group_by</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of group</p>
            

            
            <div class="method-source-code" id="group_by-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 359</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">group_by</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">group</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- group_by-source -->
            
          </div>

          

          
        </div><!-- group_by-method -->

      
        <div id="group_cube-method" class="method-detail ">
          <a name="method-i-group_cube"></a>

          
          <div class="method-heading">
            <span class="method-name">group_cube</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds the appropriate CUBE syntax to GROUP BY.</p>
            

            
            <div class="method-source-code" id="group_cube-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">group_cube</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;GROUP BY CUBE not supported on #{db.database_type}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_group_cube?</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:group_options=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">:cube</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- group_cube-source -->
            
          </div>

          

          
        </div><!-- group_cube-method -->

      
        <div id="group_rollup-method" class="method-detail ">
          <a name="method-i-group_rollup"></a>

          
          <div class="method-heading">
            <span class="method-name">group_rollup</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds the appropriate ROLLUP syntax to GROUP BY.</p>
            

            
            <div class="method-source-code" id="group_rollup-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">group_rollup</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;GROUP BY ROLLUP not supported on #{db.database_type}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_group_rollup?</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:group_options=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">:rollup</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- group_rollup-source -->
            
          </div>

          

          
        </div><!-- group_rollup-method -->

      
        <div id="having-method" class="method-detail ">
          <a name="method-i-having"></a>

          
          <div class="method-heading">
            <span class="method-name">having</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the <a
href="Dataset.html#HAVING">HAVING</a> conditions changed. See <a
href="Dataset.html#method-i-filter">filter</a> for argument types.</p>

<pre>DB[:items].group(:sum).having(:sum=&gt;10)
# SELECT * FROM items GROUP BY sum HAVING (sum = 10)</pre>
            

            
            <div class="method-source-code" id="having-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 404</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">having</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter</span>(<span class="ruby-value">:having</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- having-source -->
            
          </div>

          

          
        </div><!-- having-method -->

      
        <div id="intersect-method" class="method-detail ">
          <a name="method-i-intersect"></a>

          
          <div class="method-heading">
            <span class="method-name">intersect</span><span
              class="method-args">(dataset, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds an INTERSECT clause using a second dataset object. An INTERSECT
compound dataset returns all rows in both the current dataset and the given
dataset. Raises an <tt>InvalidOperation</tt> if the operation is not
supported. Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:alias </p></td>
<td>
<p>Use the given value as the <a
href="Dataset.html#method-i-from_self">from_self</a> alias</p>
</td></tr><tr><td class="rdoc-term"><p>:all </p></td>
<td>
<p>Set to true to use INTERSECT <a href="Dataset.html#ALL">ALL</a> instead of
INTERSECT, so duplicate rows can occur</p>
</td></tr><tr><td class="rdoc-term"><p>:<a href="Dataset.html#method-i-from_self">from_self</a> </p></td>
<td>
<p>Set to false to not wrap the returned dataset in a <a
href="Dataset.html#method-i-from_self">from_self</a>, use with care.</p>
</td></tr></table>

<pre>DB[:items].intersect(DB[:other_items])
# SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS t1

DB[:items].intersect(DB[:other_items], :all=&gt;true, :from_self=&gt;false)
# SELECT * FROM items INTERSECT ALL SELECT * FROM other_items

DB[:items].intersect(DB[:other_items], :alias=&gt;:i)
# SELECT * FROM (SELECT * FROM items INTERSECT SELECT * FROM other_items) AS i</pre>
            

            
            <div class="method-source-code" id="intersect-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 425</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">intersect</span>(<span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:all=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">opts</span>} <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;INTERSECT not supported&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_intersect_except?</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;INTERSECT ALL not supported&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_intersect_except_all?</span>
  <span class="ruby-identifier">compound_clone</span>(<span class="ruby-value">:intersect</span>, <span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- intersect-source -->
            
          </div>

          

          
        </div><!-- intersect-method -->

      
        <div id="invert-method" class="method-detail ">
          <a name="method-i-invert"></a>

          
          <div class="method-heading">
            <span class="method-name">invert</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inverts the current filter.</p>

<pre>DB[:items].filter(:category =&gt; 'software').invert
# SELECT * FROM items WHERE (category != 'software')

DB[:items].filter(:category =&gt; 'software', :id=&gt;3).invert
# SELECT * FROM items WHERE ((category != 'software') OR (id != 3))</pre>
            

            
            <div class="method-source-code" id="invert-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 439</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert</span>
  <span class="ruby-identifier">having</span>, <span class="ruby-identifier">where</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:having</span>], <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:where</span>]
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;No current filter&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">having</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">where</span>
  <span class="ruby-identifier">o</span> = {}
  <span class="ruby-identifier">o</span>[<span class="ruby-value">:having</span>] = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">invert</span>(<span class="ruby-identifier">having</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">having</span>
  <span class="ruby-identifier">o</span>[<span class="ruby-value">:where</span>] = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">invert</span>(<span class="ruby-identifier">where</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">where</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">o</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- invert-source -->
            
          </div>

          

          
        </div><!-- invert-method -->

      
        <div id="join-method" class="method-detail ">
          <a name="method-i-join"></a>

          
          <div class="method-heading">
            <span class="method-name">join</span><span
              class="method-args">(*args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of <tt>inner_join</tt></p>
            

            
            <div class="method-source-code" id="join-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">join</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">inner_join</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- join-source -->
            
          </div>

          

          
        </div><!-- join-method -->

      
        <div id="join_table-method" class="method-detail ">
          <a name="method-i-join_table"></a>

          
          <div class="method-heading">
            <span class="method-name">join_table</span><span
              class="method-args">(type, table, expr=nil, options={}, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a joined dataset.  Not usually called directly, users should use
the appropriate join method (e.g. join, left_join, natural_join,
cross_join) which fills in the <tt>type</tt> argument.</p>

<p>Takes the following arguments:</p>
<ul><li>
<p>type - The type of join to do (e.g. :inner)</p>
</li><li>
<p>table - Depends on type:</p>
<ul><li>
<p><a href="Dataset.html">Dataset</a> - a subselect is performed with an alias
of tN for some value of N</p>
</li><li>
<p><a href="../String.html">String</a>, Symbol: table</p>
</li></ul>
</li><li>
<p>expr - specifies conditions, depends on type:</p>
<ul><li>
<p><a href="../Hash.html">Hash</a>, <a href="../Array.html">Array</a> of two
element arrays - Assumes key (1st arg) is column of joined table (unless
already qualified), and value (2nd arg) is column of the last joined or
primary table (or the :implicit_qualifier option). To specify multiple
conditions on a single joined table column, you must use an array. Uses a
JOIN with an <a href="Dataset.html#ON">ON</a> clause.</p>
</li><li>
<p><a href="../Array.html">Array</a> - If all members of the array are
symbols, considers them as columns and  uses a JOIN with a <a
href="Dataset.html#USING">USING</a> clause.  Most databases will remove
duplicate columns from the result set if this is used.</p>
</li><li>
<p>nil - If a block is not given, doesn't use <a href="Dataset.html#ON">ON</a>
or <a href="Dataset.html#USING">USING</a>, so the JOIN should be a NATURAL
or CROSS join. If a block is given, uses an <a
href="Dataset.html#ON">ON</a> clause based on the block, see below.</p>
</li><li>
<p>Everything else - pretty much the same as a using the argument in a call to
filter, so strings are considered literal, symbols specify boolean columns,
and <a href="../Sequel.html">Sequel</a> expressions can be used. Uses a
JOIN with an <a href="Dataset.html#ON">ON</a> clause.</p>
</li></ul>
</li><li>
<p>options - a hash of options, with any of the following keys:</p>
<ul><li>
<p>:table_alias - the name of the table's alias when joining, necessary for
joining to the same table more than once.  No alias is used by default.</p>
</li><li>
<p>:implicit_qualifier - The name to use for qualifying implicit conditions. 
By default, the last joined or primary table is used.</p>
</li><li>
<p>:qualify - Can be set to false to not do any implicit qualification.  Can
be set to :deep to use the <a href="Qualifier.html">Qualifier</a> AST
Transformer, which will attempt to qualify subexpressions of the expression
tree.</p>
</li></ul>
</li><li>
<p>block - The block argument should only be given if a JOIN with an <a
href="Dataset.html#ON">ON</a> clause is used, in which case it yields the
table alias/name for the table currently being joined, the table alias/name
for the last joined (or first table), and an array of previous <a
href="SQL/JoinClause.html">SQL::JoinClause</a>. Unlike <tt>filter</tt>,
this block is not treated as a virtual row block.</p>
</li></ul>

<p>Examples:</p>

<pre>DB[:a].join_table(:cross, :b)
# SELECT * FROM a CROSS JOIN b

DB[:a].join_table(:inner, DB[:b], :c=&gt;d)
# SELECT * FROM a INNER JOIN (SELECT * FROM b) AS t1 ON (t1.c = a.d)

DB[:a].join_table(:left, :b___c, [:d])
# SELECT * FROM a LEFT JOIN b AS c USING (d)

DB[:a].natural_join(:b).join_table(:inner, :c) do |ta, jta, js|
  (Sequel.qualify(ta, :d) &gt; Sequel.qualify(jta, :e)) &amp; {Sequel.qualify(ta, :f)=&gt;DB.from(js.first.table).select(:g)}
end
# SELECT * FROM a NATURAL JOIN b INNER JOIN c
#   ON ((c.d &gt; b.e) AND (c.f IN (SELECT g FROM b)))</pre>
            

            
            <div class="method-source-code" id="join_table-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 506</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">join_table</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">expr</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">options</span>={}, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">table</span>)
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">hoist_cte</span>(<span class="ruby-identifier">table</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">join_table</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">ds</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">options</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">using_join</span> = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expr</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">all?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>)}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">using_join</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_join_using?</span>
    <span class="ruby-identifier">h</span> = {}
    <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">s</span>}
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">join_table</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">h</span>, <span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">case</span> <span class="ruby-identifier">options</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:table_alias</span>]
    <span class="ruby-identifier">last_alias</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:implicit_qualifier</span>]
    <span class="ruby-identifier">qualify_type</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:qualify</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>, <span class="ruby-constant">String</span>, <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>
    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">options</span>
    <span class="ruby-identifier">last_alias</span> = <span class="ruby-keyword">nil</span> 
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid options format for join_table: #{options.inspect}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-constant">Dataset</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">table</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">table_alias</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">table_alias_num</span> = (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:num_dataset_sources</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">dataset_alias</span>(<span class="ruby-identifier">table_alias_num</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">table_name</span> = <span class="ruby-identifier">table_alias</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">table</span>, <span class="ruby-identifier">implicit_table_alias</span> = <span class="ruby-identifier">split_alias</span>(<span class="ruby-identifier">table</span>)
    <span class="ruby-identifier">table_alias</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">implicit_table_alias</span>
    <span class="ruby-identifier">table_name</span> = <span class="ruby-identifier">table_alias</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">table</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">join</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block</span>
    <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">JoinClause</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">table_alias</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">using_join</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;can't use a block if providing an array of symbols as expr&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
    <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">JoinUsingClause</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">expr</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">table_alias</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">last_alias</span> <span class="ruby-operator">||=</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:last_joined_table</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">first_source_alias</span>
    <span class="ruby-keyword">if</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">expr</span>)
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">qualify_type</span>
        <span class="ruby-keyword">when</span> <span class="ruby-keyword">false</span>
          <span class="ruby-keyword">nil</span> <span class="ruby-comment"># Do no qualification</span>
        <span class="ruby-keyword">when</span> <span class="ruby-value">:deep</span>
          <span class="ruby-identifier">k</span> = <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Qualifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">table_name</span>).<span class="ruby-identifier">transform</span>(<span class="ruby-identifier">k</span>)
          <span class="ruby-identifier">v</span> = <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Qualifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">last_alias</span>).<span class="ruby-identifier">transform</span>(<span class="ruby-identifier">v</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">k</span> = <span class="ruby-identifier">qualified_column_name</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">table_name</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>)
          <span class="ruby-identifier">v</span> = <span class="ruby-identifier">qualified_column_name</span>(<span class="ruby-identifier">v</span>, <span class="ruby-identifier">last_alias</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>)
        <span class="ruby-keyword">end</span>
        [<span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">expr</span> = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">from_value_pairs</span>(<span class="ruby-identifier">expr</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
      <span class="ruby-identifier">expr2</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">last_alias</span>, <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:join</span>] <span class="ruby-operator">||</span> [])
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">expr</span> <span class="ruby-operator">?</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:AND</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">expr2</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">expr2</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">JoinOnClause</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">expr</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">table_alias</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:join</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:join</span>] <span class="ruby-operator">||</span> []) <span class="ruby-operator">+</span> [<span class="ruby-identifier">join</span>], <span class="ruby-value">:last_joined_table</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">table_name</span>}
  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:num_dataset_sources</span>] = <span class="ruby-identifier">table_alias_num</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">table_alias_num</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- join_table-source -->
            
          </div>

          

          
        </div><!-- join_table-method -->

      
        <div id="limit-method" class="method-detail ">
          <a name="method-i-limit"></a>

          
          <div class="method-heading">
            <span class="method-name">limit</span><span
              class="method-args">(l, o = (no_offset = true; nil))</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>If given an integer, the dataset will contain only the first l results. If
given a range, it will contain only those at offsets within that range. If
a second argument is given, it is used as an offset. To use an offset
without a limit, pass nil as the first argument.</p>

<pre>DB[:items].limit(10) # SELECT * FROM items LIMIT 10
DB[:items].limit(10, 20) # SELECT * FROM items LIMIT 10 OFFSET 20
DB[:items].limit(10...20) # SELECT * FROM items LIMIT 10 OFFSET 10
DB[:items].limit(10..20) # SELECT * FROM items LIMIT 11 OFFSET 10
DB[:items].limit(nil, 20) # SELECT * FROM items OFFSET 20</pre>
            

            
            <div class="method-source-code" id="limit-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 595</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">limit</span>(<span class="ruby-identifier">l</span>, <span class="ruby-identifier">o</span> = (<span class="ruby-identifier">no_offset</span> = <span class="ruby-keyword">true</span>; <span class="ruby-keyword">nil</span>))
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">from_self</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-identifier">l</span>, <span class="ruby-identifier">o</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:sql</span>]

  <span class="ruby-keyword">if</span> <span class="ruby-constant">Range</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">l</span>
    <span class="ruby-identifier">o</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">first</span>
    <span class="ruby-identifier">l</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">l</span>.<span class="ruby-identifier">exclude_end?</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">l</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">l</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">LiteralString</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'Limits must be greater than or equal to 1'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">l</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:limit</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">l</span>}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>
    <span class="ruby-identifier">o</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">LiteralString</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'Offsets must be greater than or equal to 0'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">o</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:offset</span>] = <span class="ruby-identifier">o</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">no_offset</span>
    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:offset</span>] = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- limit-source -->
            
          </div>

          

          
        </div><!-- limit-method -->

      
        <div id="lock_style-method" class="method-detail ">
          <a name="method-i-lock_style"></a>

          
          <div class="method-heading">
            <span class="method-name">lock_style</span><span
              class="method-args">(style)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a cloned dataset with the given lock style.  If style is a string,
it will be used directly.  Otherwise, a symbol may be used for database
independent locking.  Currently :update is respected by most databases, and
:share is supported by some.</p>

<pre>DB[:items].lock_style('FOR SHARE') # SELECT * FROM items FOR SHARE</pre>
            

            
            <div class="method-source-code" id="lock_style-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 625</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lock_style</span>(<span class="ruby-identifier">style</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:lock</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">style</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- lock_style-source -->
            
          </div>

          

          
        </div><!-- lock_style-method -->

      
        <div id="naked-method" class="method-detail ">
          <a name="method-i-naked"></a>

          
          <div class="method-heading">
            <span class="method-name">naked</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a cloned dataset without a row_proc.</p>

<pre>ds = DB[:items]
ds.row_proc = proc{|r| r.invert}
ds.all # =&gt; [{2=&gt;:id}]
ds.naked.all # =&gt; [{:id=&gt;2}]</pre>
            

            
            <div class="method-source-code" id="naked-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 635</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">naked</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">row_proc</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">ds</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- naked-source -->
            
          </div>

          

          
        </div><!-- naked-method -->

      
        <div id="or-method" class="method-detail ">
          <a name="method-i-or"></a>

          
          <div class="method-heading">
            <span class="method-name">or</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds an alternate filter to an existing filter using OR. If no filter 
exists an <tt>Error</tt> is raised.</p>

<pre>DB[:items].filter(:a).or(:b) # SELECT * FROM items WHERE a OR b</pre>
            

            
            <div class="method-source-code" id="or-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 645</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">or</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">clause</span> = (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:having</span>] <span class="ruby-operator">?</span> <span class="ruby-value">:having</span> <span class="ruby-operator">:</span> <span class="ruby-value">:where</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;No existing filter found.&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-identifier">clause</span>]
  <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">cond</span>.<span class="ruby-identifier">first</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">cond</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">clause</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:OR</span>, <span class="ruby-ivar">@opts</span>[<span class="ruby-identifier">clause</span>], <span class="ruby-identifier">filter_expr</span>(<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)))
<span class="ruby-keyword">end</span></pre>
            </div><!-- or-source -->
            
          </div>

          

          
        </div><!-- or-method -->

      
        <div id="order-method" class="method-detail ">
          <a name="method-i-order"></a>

          
          <div class="method-heading">
            <span class="method-name">order</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the order changed. If the dataset has an
existing order, it is ignored and overwritten with this order. If a nil is
given the returned dataset has no order. This can accept multiple arguments
of varying kinds, such as <a href="SQL.html">SQL</a> functions.  If a block
is given, it is treated as a virtual row block, similar to <tt>filter</tt>.</p>

<pre>DB[:items].order(:name) # SELECT * FROM items ORDER BY name
DB[:items].order(:a, :b) # SELECT * FROM items ORDER BY a, b
DB[:items].order(Sequel.lit('a + b')) # SELECT * FROM items ORDER BY a + b
DB[:items].order(:a + :b) # SELECT * FROM items ORDER BY (a + b)
DB[:items].order(Sequel.desc(:name)) # SELECT * FROM items ORDER BY name DESC
DB[:items].order(Sequel.asc(:name, :nulls=&gt;:last)) # SELECT * FROM items ORDER BY name ASC NULLS LAST
DB[:items].order{sum(name).desc} # SELECT * FROM items ORDER BY sum(name) DESC
DB[:items].order(nil) # SELECT * FROM items</pre>
            

            
            <div class="method-source-code" id="order-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 666</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">order</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">virtual_row_columns</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:order</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">empty?</span>) <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">columns</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- order-source -->
            
          </div>

          

          
        </div><!-- order-method -->

      
        <div id="order_append-method" class="method-detail ">
          <a name="method-i-order_append"></a>

          
          <div class="method-heading">
            <span class="method-name">order_append</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of <a href="Dataset.html#method-i-order_more">order_more</a>, for
naming consistency with order_prepend.</p>
            

            
            <div class="method-source-code" id="order_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 672</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">order_append</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">order_more</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- order_append-source -->
            
          </div>

          

          
        </div><!-- order_append-method -->

      
        <div id="order_by-method" class="method-detail ">
          <a name="method-i-order_by"></a>

          
          <div class="method-heading">
            <span class="method-name">order_by</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of order</p>
            

            
            <div class="method-source-code" id="order_by-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 677</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">order_by</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">order</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- order_by-source -->
            
          </div>

          

          
        </div><!-- order_by-method -->

      
        <div id="order_more-method" class="method-detail ">
          <a name="method-i-order_more"></a>

          
          <div class="method-heading">
            <span class="method-name">order_more</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the order columns added to the end of
the existing order.</p>

<pre>DB[:items].order(:a).order(:b) # SELECT * FROM items ORDER BY b
DB[:items].order(:a).order_more(:b) # SELECT * FROM items ORDER BY a, b</pre>
            

            
            <div class="method-source-code" id="order_more-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 686</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">order_more</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">columns</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">columns</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>]
  <span class="ruby-identifier">order</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- order_more-source -->
            
          </div>

          

          
        </div><!-- order_more-method -->

      
        <div id="order_prepend-method" class="method-detail ">
          <a name="method-i-order_prepend"></a>

          
          <div class="method-heading">
            <span class="method-name">order_prepend</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the order columns added to the beginning
of the existing order.</p>

<pre>DB[:items].order(:a).order(:b) # SELECT * FROM items ORDER BY b
DB[:items].order(:a).order_prepend(:b) # SELECT * FROM items ORDER BY b, a</pre>
            

            
            <div class="method-source-code" id="order_prepend-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 696</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">order_prepend</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">order</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order_more</span>(*<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>]) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- order_prepend-source -->
            
          </div>

          

          
        </div><!-- order_prepend-method -->

      
        <div id="qualify-method" class="method-detail ">
          <a name="method-i-qualify"></a>

          
          <div class="method-heading">
            <span class="method-name">qualify</span><span
              class="method-args">(table=first_source)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Qualify to the given table, or first source if no table is given.</p>

<pre>DB[:items].filter(:id=&gt;1).qualify
# SELECT items.* FROM items WHERE (items.id = 1)

DB[:items].filter(:id=&gt;1).qualify(:i)
# SELECT i.* FROM items WHERE (i.id = 1)</pre>
            

            
            <div class="method-source-code" id="qualify-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 708</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">table</span>=<span class="ruby-identifier">first_source</span>)
  <span class="ruby-identifier">qualify_to</span>(<span class="ruby-identifier">table</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- qualify-source -->
            
          </div>

          

          
        </div><!-- qualify-method -->

      
        <div id="qualify_to-method" class="method-detail ">
          <a name="method-i-qualify_to"></a>

          
          <div class="method-heading">
            <span class="method-name">qualify_to</span><span
              class="method-args">(table)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a copy of the dataset with unqualified identifiers in the <a
href="Dataset.html#SELECT">SELECT</a>, <a
href="Dataset.html#WHERE">WHERE</a>, GROUP, <a
href="Dataset.html#HAVING">HAVING</a>, and ORDER clauses qualified by the
given table. If no columns are currently selected, select all columns of
the given table.</p>

<pre>DB[:items].filter(:id=&gt;1).qualify_to(:i)
# SELECT i.* FROM items WHERE (i.id = 1)</pre>
            

            
            <div class="method-source-code" id="qualify_to-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 719</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">qualify_to</span>(<span class="ruby-identifier">table</span>)
  <span class="ruby-identifier">o</span> = <span class="ruby-ivar">@opts</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">clone</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>[<span class="ruby-value">:sql</span>]
  <span class="ruby-identifier">h</span> = {}
  (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">keys</span> &amp; <span class="ruby-constant">QUALIFY_KEYS</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">h</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">qualified_expression</span>(<span class="ruby-identifier">o</span>[<span class="ruby-identifier">k</span>], <span class="ruby-identifier">table</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">h</span>[<span class="ruby-value">:select</span>] = [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ColumnAll</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table</span>)] <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">o</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">o</span>[<span class="ruby-value">:select</span>].<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">h</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- qualify_to-source -->
            
          </div>

          

          
        </div><!-- qualify_to-method -->

      
        <div id="qualify_to_first_source-method" class="method-detail ">
          <a name="method-i-qualify_to_first_source"></a>

          
          <div class="method-heading">
            <span class="method-name">qualify_to_first_source</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Qualify the dataset to its current first source.  This is useful if you
have unqualified identifiers in the query that all refer to the first
source, and you want to join to another table which has columns with the
same name as columns in the current dataset. See <tt>qualify_to</tt>.</p>

<pre>DB[:items].filter(:id=&gt;1).qualify_to_first_source
# SELECT items.* FROM items WHERE (items.id = 1)</pre>
            

            
            <div class="method-source-code" id="qualify_to_first_source-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 738</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">qualify_to_first_source</span>
  <span class="ruby-identifier">qualify_to</span>(<span class="ruby-identifier">first_source</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- qualify_to_first_source-source -->
            
          </div>

          

          
        </div><!-- qualify_to_first_source-method -->

      
        <div id="returning-method" class="method-detail ">
          <a name="method-i-returning"></a>

          
          <div class="method-heading">
            <span class="method-name">returning</span><span
              class="method-args">(*values)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Modify the <a href="Dataset.html#RETURNING">RETURNING</a> clause, only
supported on a few databases.  If returning is used, instead of insert
returning the autogenerated primary key or update/delete returning the
number of modified rows, results are returned using <tt>fetch_rows</tt>.</p>

<pre>DB[:items].returning # RETURNING *
DB[:items].returning(nil) # RETURNING NULL
DB[:items].returning(:id, :name) # RETURNING id, name</pre>
            

            
            <div class="method-source-code" id="returning-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 750</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">returning</span>(*<span class="ruby-identifier">values</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:returning=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">values</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- returning-source -->
            
          </div>

          

          
        </div><!-- returning-method -->

      
        <div id="reverse-method" class="method-detail ">
          <a name="method-i-reverse"></a>

          
          <div class="method-heading">
            <span class="method-name">reverse</span><span
              class="method-args">(*order, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the order reversed. If no order is
given, the existing order is inverted.</p>

<pre>DB[:items].reverse(:id) # SELECT * FROM items ORDER BY id DESC
DB[:items].reverse{foo(bar)} # SELECT * FROM items ORDER BY foo(bar) DESC
DB[:items].order(:id).reverse # SELECT * FROM items ORDER BY id DESC
DB[:items].order(:id).reverse(Sequel.desc(:name)) # SELECT * FROM items ORDER BY name ASC</pre>
            

            
            <div class="method-source-code" id="reverse-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 761</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reverse</span>(*<span class="ruby-identifier">order</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">virtual_row_columns</span>(<span class="ruby-identifier">order</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">order</span>(*<span class="ruby-identifier">invert_order</span>(<span class="ruby-identifier">order</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">order</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- reverse-source -->
            
          </div>

          

          
        </div><!-- reverse-method -->

      
        <div id="reverse_order-method" class="method-detail ">
          <a name="method-i-reverse_order"></a>

          
          <div class="method-heading">
            <span class="method-name">reverse_order</span><span
              class="method-args">(*order, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of <tt>reverse</tt></p>
            

            
            <div class="method-source-code" id="reverse_order-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 767</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reverse_order</span>(*<span class="ruby-identifier">order</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">reverse</span>(*<span class="ruby-identifier">order</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- reverse_order-source -->
            
          </div>

          

          
        </div><!-- reverse_order-method -->

      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          <div class="method-heading">
            <span class="method-name">select</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the columns selected changed to the
given columns. This also takes a virtual row block, similar to
<tt>filter</tt>.</p>

<pre>DB[:items].select(:a) # SELECT a FROM items
DB[:items].select(:a, :b) # SELECT a, b FROM items
DB[:items].select{[a, sum(b)]} # SELECT a, sum(b) FROM items</pre>
            

            
            <div class="method-source-code" id="select-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 778</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">virtual_row_columns</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">m</span> = []
  <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">i</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">i</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span>)}) <span class="ruby-operator">:</span> <span class="ruby-identifier">m</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">i</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:select</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">m</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->

      
        <div id="select_all-method" class="method-detail ">
          <a name="method-i-select_all"></a>

          
          <div class="method-heading">
            <span class="method-name">select_all</span><span
              class="method-args">(*tables)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset selecting the wildcard if no arguments are
given.  If arguments are given, treat them as tables and select all columns
(using the wildcard) from each table.</p>

<pre>DB[:items].select(:a).select_all # SELECT * FROM items
DB[:items].select_all(:items) # SELECT items.* FROM items
DB[:items].select_all(:items, :foo) # SELECT items.*, foo.* FROM items</pre>
            

            
            <div class="method-source-code" id="select_all-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 794</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_all</span>(*<span class="ruby-identifier">tables</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">tables</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">clone</span>(<span class="ruby-value">:select</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">tables</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>, <span class="ruby-identifier">a</span> = <span class="ruby-identifier">split_alias</span>(<span class="ruby-identifier">t</span>); <span class="ruby-identifier">a</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">i</span>}.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ColumnAll</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>)})
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_all-source -->
            
          </div>

          

          
        </div><!-- select_all-method -->

      
        <div id="select_append-method" class="method-detail ">
          <a name="method-i-select_append"></a>

          
          <div class="method-heading">
            <span class="method-name">select_append</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the given columns added to the existing
selected columns.  If no columns are currently selected, it will select the
columns given in addition to *.</p>

<pre>DB[:items].select(:a).select(:b) # SELECT b FROM items
DB[:items].select(:a).select_append(:b) # SELECT a, b FROM items
DB[:items].select_append(:b) # SELECT *, b FROM items</pre>
            

            
            <div class="method-source-code" id="select_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 809</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_append</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">cur_sel</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:select</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cur_sel</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">cur_sel</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_select_all_and_column?</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">select_all</span>(*(<span class="ruby-constant">Array</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:from</span>]) <span class="ruby-operator">+</span> <span class="ruby-constant">Array</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:join</span>]))).<span class="ruby-identifier">select_more</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">cur_sel</span> = [<span class="ruby-constant">WILDCARD</span>]
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">select</span>(*(<span class="ruby-identifier">cur_sel</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">columns</span>), &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_append-source -->
            
          </div>

          

          
        </div><!-- select_append-method -->

      
        <div id="select_group-method" class="method-detail ">
          <a name="method-i-select_group"></a>

          
          <div class="method-heading">
            <span class="method-name">select_group</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set both the select and group clauses with the given <tt>columns</tt>.
Column aliases may be supplied, and will be included in the select clause.
This also takes a virtual row block similar to <tt>filter</tt>.</p>

<pre>DB[:items].select_group(:a, :b)
# SELECT a, b FROM items GROUP BY a, b

DB[:items].select_group(:c___a){f(c2)}
# SELECT c AS a, f(c2) FROM items GROUP BY c, f(c2)</pre>
            

            
            <div class="method-source-code" id="select_group-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 829</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_group</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">virtual_row_columns</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">columns</span>).<span class="ruby-identifier">group</span>(*<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">unaliased_identifier</span>(<span class="ruby-identifier">c</span>)})
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_group-source -->
            
          </div>

          

          
        </div><!-- select_group-method -->

      
        <div id="select_more-method" class="method-detail ">
          <a name="method-i-select_more"></a>

          
          <div class="method-heading">
            <span class="method-name">select_more</span><span
              class="method-args">(*columns, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the given columns added to the existing
selected columns. If no columns are currently selected it will just select
the columns given.</p>

<pre>DB[:items].select(:a).select(:b) # SELECT b FROM items
DB[:items].select(:a).select_more(:b) # SELECT a, b FROM items
DB[:items].select_more(:b) # SELECT b FROM items</pre>
            

            
            <div class="method-source-code" id="select_more-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 841</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_more</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">columns</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">columns</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:select</span>]
  <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">columns</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_more-source -->
            
          </div>

          

          
        </div><!-- select_more-method -->

      
        <div id="server-method" class="method-detail ">
          <a name="method-i-server"></a>

          
          <div class="method-heading">
            <span class="method-name">server</span><span
              class="method-args">(servr)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set the server for this dataset to use.  Used to pick a specific database
shard to run a query against, or to override the default (where <a
href="Dataset.html#SELECT">SELECT</a> uses :read_only database and all
other queries use the :default database).  This method is always available
but is only useful when database sharding is being used.</p>

<pre>DB[:items].all # Uses the :read_only or :default server 
DB[:items].delete # Uses the :default server
DB[:items].server(:blah).delete # Uses the :blah server</pre>
            

            
            <div class="method-source-code" id="server-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 855</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">server</span>(<span class="ruby-identifier">servr</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:server=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">servr</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- server-source -->
            
          </div>

          

          
        </div><!-- server-method -->

      
        <div id="set_defaults-method" class="method-detail ">
          <a name="method-i-set_defaults"></a>

          
          <div class="method-heading">
            <span class="method-name">set_defaults</span><span
              class="method-args">(hash)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set the default values for insert and update statements.  The values hash
passed to insert or update are merged into this hash, so any values in the
hash passed to insert or update will override values passed to this method.</p>

<pre>DB[:items].set_defaults(:a=&gt;'a', :c=&gt;'c').insert(:a=&gt;'d', :b=&gt;'b')
# INSERT INTO items (a, c, b) VALUES ('d', 'c', 'b')</pre>
            

            
            <div class="method-source-code" id="set_defaults-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 865</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_defaults</span>(<span class="ruby-identifier">hash</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:defaults=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:defaults</span>]<span class="ruby-operator">||</span>{}).<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">hash</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_defaults-source -->
            
          </div>

          

          
        </div><!-- set_defaults-method -->

      
        <div id="set_overrides-method" class="method-detail ">
          <a name="method-i-set_overrides"></a>

          
          <div class="method-heading">
            <span class="method-name">set_overrides</span><span
              class="method-args">(hash)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set values that override hash arguments given to insert and update
statements. This hash is merged into the hash provided to insert or update,
so values will override any values given in the insert/update hashes.</p>

<pre>DB[:items].set_overrides(:a=&gt;'a', :c=&gt;'c').insert(:a=&gt;'d', :b=&gt;'b')
# INSERT INTO items (a, c, b) VALUES ('a', 'c', 'b')</pre>
            

            
            <div class="method-source-code" id="set_overrides-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 875</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_overrides</span>(<span class="ruby-identifier">hash</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:overrides=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">hash</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:overrides</span>]<span class="ruby-operator">||</span>{}))
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_overrides-source -->
            
          </div>

          

          
        </div><!-- set_overrides-method -->

      
        <div id="unbind-method" class="method-detail ">
          <a name="method-i-unbind"></a>

          
          <div class="method-heading">
            <span class="method-name">unbind</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Unbind bound variables from this dataset's filter and return an array of
two objects.  The first object is a modified dataset where the filter has
been replaced with one that uses bound variable placeholders.  The second
object is the hash of unbound variables.  You can then prepare and execute
(or just call) the dataset with the bound variables to get results.</p>

<pre>ds, bv = DB[:items].filter(:a=&gt;1).unbind
ds # SELECT * FROM items WHERE (a = $a)
bv #  {:a =&gt; 1}
ds.call(:select, bv)</pre>
            

            
            <div class="method-source-code" id="unbind-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 889</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unbind</span>
  <span class="ruby-identifier">u</span> = <span class="ruby-constant">Unbinder</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>(<span class="ruby-value">:where=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">u</span>.<span class="ruby-identifier">transform</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:where</span>]), <span class="ruby-value">:join=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">u</span>.<span class="ruby-identifier">transform</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:join</span>]))
  [<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">u</span>.<span class="ruby-identifier">binds</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- unbind-source -->
            
          </div>

          

          
        </div><!-- unbind-method -->

      
        <div id="unfiltered-method" class="method-detail ">
          <a name="method-i-unfiltered"></a>

          
          <div class="method-heading">
            <span class="method-name">unfiltered</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with no filters (<a
href="Dataset.html#HAVING">HAVING</a> or <a
href="Dataset.html#WHERE">WHERE</a> clause) applied.</p>

<pre>DB[:items].group(:a).having(:a=&gt;1).where(:b).unfiltered
# SELECT * FROM items GROUP BY a</pre>
            

            
            <div class="method-source-code" id="unfiltered-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 899</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unfiltered</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:where</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">:having</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- unfiltered-source -->
            
          </div>

          

          
        </div><!-- unfiltered-method -->

      
        <div id="ungrouped-method" class="method-detail ">
          <a name="method-i-ungrouped"></a>

          
          <div class="method-heading">
            <span class="method-name">ungrouped</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with no grouping (GROUP or <a
href="Dataset.html#HAVING">HAVING</a> clause) applied.</p>

<pre>DB[:items].group(:a).having(:a=&gt;1).where(:b).ungrouped
# SELECT * FROM items WHERE b</pre>
            

            
            <div class="method-source-code" id="ungrouped-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 907</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ungrouped</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:group</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">:having</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- ungrouped-source -->
            
          </div>

          

          
        </div><!-- ungrouped-method -->

      
        <div id="union-method" class="method-detail ">
          <a name="method-i-union"></a>

          
          <div class="method-heading">
            <span class="method-name">union</span><span
              class="method-args">(dataset, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds a UNION clause using a second dataset object. A UNION compound dataset
returns all rows in either the current dataset or the given dataset.
Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:alias </p></td>
<td>
<p>Use the given value as the <a
href="Dataset.html#method-i-from_self">from_self</a> alias</p>
</td></tr><tr><td class="rdoc-term"><p>:all </p></td>
<td>
<p>Set to true to use UNION <a href="Dataset.html#ALL">ALL</a> instead of
UNION, so duplicate rows can occur</p>
</td></tr><tr><td class="rdoc-term"><p>:<a href="Dataset.html#method-i-from_self">from_self</a> </p></td>
<td>
<p>Set to false to not wrap the returned dataset in a <a
href="Dataset.html#method-i-from_self">from_self</a>, use with care.</p>
</td></tr></table>

<pre>DB[:items].union(DB[:other_items])
# SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS t1

DB[:items].union(DB[:other_items], :all=&gt;true, :from_self=&gt;false)
# SELECT * FROM items UNION ALL SELECT * FROM other_items

DB[:items].union(DB[:other_items], :alias=&gt;:i)
# SELECT * FROM (SELECT * FROM items UNION SELECT * FROM other_items) AS i</pre>
            

            
            <div class="method-source-code" id="union-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 927</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">union</span>(<span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:all=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">opts</span>} <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
  <span class="ruby-identifier">compound_clone</span>(<span class="ruby-value">:union</span>, <span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- union-source -->
            
          </div>

          

          
        </div><!-- union-method -->

      
        <div id="unlimited-method" class="method-detail ">
          <a name="method-i-unlimited"></a>

          
          <div class="method-heading">
            <span class="method-name">unlimited</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with no limit or offset.</p>

<pre>DB[:items].limit(10, 20).unlimited # SELECT * FROM items</pre>
            

            
            <div class="method-source-code" id="unlimited-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 935</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unlimited</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:limit=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, <span class="ruby-value">:offset=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- unlimited-source -->
            
          </div>

          

          
        </div><!-- unlimited-method -->

      
        <div id="unordered-method" class="method-detail ">
          <a name="method-i-unordered"></a>

          
          <div class="method-heading">
            <span class="method-name">unordered</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with no order.</p>

<pre>DB[:items].order(:a).unordered # SELECT * FROM items</pre>
            

            
            <div class="method-source-code" id="unordered-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 942</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unordered</span>
  <span class="ruby-identifier">order</span>(<span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- unordered-source -->
            
          </div>

          

          
        </div><!-- unordered-method -->

      
        <div id="where-method" class="method-detail ">
          <a name="method-i-where"></a>

          
          <div class="method-heading">
            <span class="method-name">where</span><span
              class="method-args">(*cond, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Add a condition to the <a href="Dataset.html#WHERE">WHERE</a> clause.  See
<tt>filter</tt> for argument types.</p>

<pre>DB[:items].group(:a).having(:a).filter(:b)
# SELECT * FROM items GROUP BY a HAVING a AND b

DB[:items].group(:a).having(:a).where(:b)
# SELECT * FROM items WHERE b GROUP BY a HAVING a</pre>
            

            
            <div class="method-source-code" id="where-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 953</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">where</span>(*<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_filter</span>(<span class="ruby-value">:where</span>, *<span class="ruby-identifier">cond</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- where-source -->
            
          </div>

          

          
        </div><!-- where-method -->

      
        <div id="with-method" class="method-detail ">
          <a name="method-i-with"></a>

          
          <div class="method-heading">
            <span class="method-name">with</span><span
              class="method-args">(name, dataset, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Add a common table expression (CTE) with the given name and a dataset that
defines the CTE. A common table expression acts as an inline view for the
query. Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:args </p></td>
<td>
<p>Specify the arguments/columns for the CTE, should be an array of symbols.</p>
</td></tr><tr><td class="rdoc-term"><p>:recursive </p></td>
<td>
<p>Specify that this is a recursive CTE</p>
</td></tr></table>

<pre>DB[:items].with(:items, DB[:syx].filter(:name.like('A%')))
# WITH items AS (SELECT * FROM syx WHERE (name LIKE 'A%')) SELECT * FROM items</pre>
            

            
            <div class="method-source-code" id="with-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 965</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'This datatset does not support common table expressions'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_cte?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">dataset</span>)
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">hoist_cte</span>(<span class="ruby-identifier">dataset</span>)
    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">with</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ds</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">clone</span>(<span class="ruby-value">:with=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:with</span>]<span class="ruby-operator">||</span>[]) <span class="ruby-operator">+</span> [<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-value">:name=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">name</span>, <span class="ruby-value">:dataset=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">dataset</span>)])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- with-source -->
            
          </div>

          

          
        </div><!-- with-method -->

      
        <div id="with_recursive-method" class="method-detail ">
          <a name="method-i-with_recursive"></a>

          
          <div class="method-heading">
            <span class="method-name">with_recursive</span><span
              class="method-args">(name, nonrecursive, recursive, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Add a recursive common table expression (CTE) with the given name, a
dataset that defines the nonrecursive part of the CTE, and a dataset that
defines the recursive part of the CTE.  Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:args </p></td>
<td>
<p>Specify the arguments/columns for the CTE, should be an array of symbols.</p>
</td></tr><tr><td class="rdoc-term"><p>:union_all </p></td>
<td>
<p>Set to false to use UNION instead of UNION <a
href="Dataset.html#ALL">ALL</a> combining the nonrecursive and recursive
parts.</p>
</td></tr></table>

<pre>DB[:t].with_recursive(:t,
  DB[:i1].select(:id, :parent_id).filter(:parent_id=&gt;nil),
  DB[:i1].join(:t, :id=&gt;:parent_id).select(:i1__id, :i1__parent_id),
  :args=&gt;[:id, :parent_id])

# WITH RECURSIVE &quot;t&quot;(&quot;id&quot;, &quot;parent_id&quot;) AS (
#   SELECT &quot;id&quot;, &quot;parent_id&quot; FROM &quot;i1&quot; WHERE (&quot;parent_id&quot; IS NULL)
#   UNION ALL
#   SELECT &quot;i1&quot;.&quot;id&quot;, &quot;i1&quot;.&quot;parent_id&quot; FROM &quot;i1&quot; INNER JOIN &quot;t&quot; ON (&quot;t&quot;.&quot;id&quot; = &quot;i1&quot;.&quot;parent_id&quot;)
# ) SELECT * FROM &quot;t&quot;</pre>
            

            
            <div class="method-source-code" id="with_recursive-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 991</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">nonrecursive</span>, <span class="ruby-identifier">recursive</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'This datatset does not support common table expressions'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_cte?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">nonrecursive</span>)
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">hoist_cte</span>(<span class="ruby-identifier">nonrecursive</span>)
    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ds</span>, <span class="ruby-identifier">recursive</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">recursive</span>)
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">hoist_cte</span>(<span class="ruby-identifier">recursive</span>)
    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">nonrecursive</span>, <span class="ruby-identifier">ds</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">clone</span>(<span class="ruby-value">:with=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:with</span>]<span class="ruby-operator">||</span>[]) <span class="ruby-operator">+</span> [<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-value">:recursive=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, <span class="ruby-value">:name=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">name</span>, <span class="ruby-value">:dataset=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">nonrecursive</span>.<span class="ruby-identifier">union</span>(<span class="ruby-identifier">recursive</span>, {<span class="ruby-value">:all=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">opts</span>[<span class="ruby-value">:union_all</span>] <span class="ruby-operator">!=</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">:from_self=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>}))])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- with_recursive-source -->
            
          </div>

          

          
        </div><!-- with_recursive-method -->

      
        <div id="with_sql-method" class="method-detail ">
          <a name="method-i-with_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">with_sql</span><span
              class="method-args">(sql, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a copy of the dataset with the static <a href="SQL.html">SQL</a>
used.  This is useful if you want to keep the same row_proc/graph, but
change the <a href="SQL.html">SQL</a> used to custom <a
href="SQL.html">SQL</a>.</p>

<pre>DB[:items].with_sql('SELECT * FROM foo') # SELECT * FROM foo</pre>

<p>You can use placeholders in your <a href="SQL.html">SQL</a> and provide
arguments for those placeholders:</p>

<pre>DB[:items].with_sql('SELECT ? FROM foo', 1) # SELECT 1 FROM foo</pre>

<p>You can also provide a method name and arguments to call to get the SQL:</p>

<pre>DB[:items].with_sql(:insert_sql, :b=&gt;1) # INSERT INTO items (b) VALUES (1)</pre>
            

            
            <div class="method-source-code" id="with_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 1016</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_sql</span>(<span class="ruby-identifier">sql</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sql</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>)
    <span class="ruby-identifier">sql</span> = <span class="ruby-identifier">send</span>(<span class="ruby-identifier">sql</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">sql</span> = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:sql=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">sql</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- with_sql-source -->
            
          </div>

          

          
        </div><!-- with_sql-method -->

      
      </div><!-- public-instance-method-details -->
    
      <div id="protected-instance-method-details" class="method-section section">
        <h3 class="section-header">Protected Instance Methods</h3>

      
        <div id="compound_clone-method" class="method-detail ">
          <a name="method-i-compound_clone"></a>

          
          <div class="method-heading">
            <span class="method-name">compound_clone</span><span
              class="method-args">(type, dataset, opts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Add the dataset to the list of compounds</p>
            

            
            <div class="method-source-code" id="compound_clone-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 1028</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compound_clone</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">hoist_cte?</span>(<span class="ruby-identifier">dataset</span>)
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">hoist_cte</span>(<span class="ruby-identifier">dataset</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">compound_clone</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">ds</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">compound_from_self</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-value">:compounds=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Array</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:compounds</span>]).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">dup</span>} <span class="ruby-operator">+</span> [[<span class="ruby-identifier">type</span>, <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">compound_from_self</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all</span>]]])
  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:from_self</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">from_self</span>(<span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- compound_clone-source -->
            
          </div>

          

          
        </div><!-- compound_clone-method -->

      
        <div id="options_overlap-method" class="method-detail ">
          <a name="method-i-options_overlap"></a>

          
          <div class="method-heading">
            <span class="method-name">options_overlap</span><span
              class="method-args">(opts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return true if the dataset has a non-nil value for any key in opts.</p>
            

            
            <div class="method-source-code" id="options_overlap-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 1038</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">options_overlap</span>(<span class="ruby-identifier">opts</span>)
  <span class="ruby-operator">!</span>(<span class="ruby-ivar">@opts</span>.<span class="ruby-identifier">collect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">nil?</span>}.<span class="ruby-identifier">compact</span> &amp; <span class="ruby-identifier">opts</span>).<span class="ruby-identifier">empty?</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- options_overlap-source -->
            
          </div>

          

          
        </div><!-- options_overlap-method -->

      
        <div id="simple_select_all-3F-method" class="method-detail ">
          <a name="method-i-simple_select_all-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">simple_select_all?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether this dataset is a simple <a href="Dataset.html#SELECT">SELECT</a> *
<a href="Dataset.html#FROM">FROM</a> table.</p>
            

            
            <div class="method-source-code" id="simple_select_all-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/query.rb, line 1043</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">simple_select_all?</span>
  <span class="ruby-identifier">o</span> = <span class="ruby-ivar">@opts</span>.<span class="ruby-identifier">reject</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-constant">NON_SQL_OPTIONS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">k</span>)}
  <span class="ruby-identifier">o</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">f</span> = <span class="ruby-identifier">o</span>[<span class="ruby-value">:from</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">f</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- simple_select_all-3F-source -->
            
          </div>

          

          
        </div><!-- simple_select_all-3F-method -->

      
      </div><!-- protected-instance-method-details -->
    
    </div><!-- 1+-+Methods+that+return+modified+datasets -->
  
    
    
    <div id="2+-+Methods+that+execute+code+on+the+database" class="documentation-section">
      
      <h2 class="section-header">
        2 - Methods that execute code on the database
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods all execute the dataset's <a href="SQL.html">SQL</a> on the
database. They don't return modified datasets, so if used in a method chain
they should be the last method called.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="ACTION_METHODS">ACTION_METHODS</a></dt>
          
          <dd class="description"><p>Action methods defined by <a href="../Sequel.html">Sequel</a> that execute
code on the database.</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          <div class="method-heading">
            <span class="method-name">&lt;&lt;</span><span
              class="method-args">(arg)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inserts the given argument into the database.  Returns self so it can be
used safely when chaining:</p>

<pre>DB[:items] &lt;&lt; {:id=&gt;0, :name=&gt;'Zero'} &lt;&lt; DB[:old_items].select(:id, name)</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 22</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">&lt;&lt;</span>(<span class="ruby-identifier">arg</span>)
  <span class="ruby-identifier">insert</span>(<span class="ruby-identifier">arg</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]</span><span
              class="method-args">(*conditions)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the first record matching the conditions. Examples:</p>

<pre>DB[:table][:id=&gt;1] # SELECT * FROM table WHERE (id = 1) LIMIT 1
# =&gt; {:id=1}</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 31</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(*<span class="ruby-identifier">conditions</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-constant">ARRAY_ACCESS_ERROR_MSG</span>) <span class="ruby-keyword">if</span> (<span class="ruby-identifier">conditions</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">conditions</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)) <span class="ruby-keyword">or</span> <span class="ruby-identifier">conditions</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">first</span>(*<span class="ruby-identifier">conditions</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->

      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]=</span><span
              class="method-args">(conditions, values)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Update all records matching the conditions with the values specified.
Returns the number of rows affected.</p>

<pre>DB[:table][:id=&gt;1] = {:id=&gt;2} # UPDATE table SET id = 2 WHERE id = 1
# =&gt; 1 # number of rows affected</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]=</span>(<span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">values</span>)
  <span class="ruby-identifier">filter</span>(<span class="ruby-identifier">conditions</span>).<span class="ruby-identifier">update</span>(<span class="ruby-identifier">values</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->

      
        <div id="all-method" class="method-detail ">
          <a name="method-i-all"></a>

          
          <div class="method-heading">
            <span class="method-name">all</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns an array with all records in the dataset. If a block is given, the
array is iterated over after all items have been loaded.</p>

<pre>DB[:table].all # SELECT * FROM table
# =&gt; [{:id=&gt;1, ...}, {:id=&gt;2, ...}, ...]

# Iterate over all rows in the table
DB[:table].all{|row| p row}</pre>
            

            
            <div class="method-source-code" id="all-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">all</span>(&amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">a</span> = []
  <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-identifier">post_load</span>(<span class="ruby-identifier">a</span>)
  <span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span>(&amp;<span class="ruby-identifier">block</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">a</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- all-source -->
            
          </div>

          

          
        </div><!-- all-method -->

      
        <div id="avg-method" class="method-detail ">
          <a name="method-i-avg"></a>

          
          <div class="method-heading">
            <span class="method-name">avg</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the average value for the given column.</p>

<pre>DB[:table].avg(:number) # SELECT avg(number) FROM table LIMIT 1
# =&gt; 3</pre>
            

            
            <div class="method-source-code" id="avg-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">avg</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-identifier">avg</span>(<span class="ruby-identifier">column</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- avg-source -->
            
          </div>

          

          
        </div><!-- avg-method -->

      
        <div id="columns-method" class="method-detail ">
          <a name="method-i-columns"></a>

          
          <div class="method-heading">
            <span class="method-name">columns</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the columns in the result set in order as an array of symbols. If
the columns are currently cached, returns the cached value. Otherwise, a <a
href="Dataset.html#SELECT">SELECT</a> query is performed to retrieve a
single row in order to get the columns.</p>

<p>If you are looking for all columns for a single table and maybe some
information about each column (e.g. database type), see
<tt>Database#schema</tt>.</p>

<pre>DB[:table].columns
# =&gt; [:id, :name]</pre>
            

            
            <div class="method-source-code" id="columns-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">columns</span>
  <span class="ruby-keyword">return</span> <span class="ruby-ivar">@columns</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@columns</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">unfiltered</span>.<span class="ruby-identifier">unordered</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-value">:distinct</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">:limit</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:offset=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">each</span>{<span class="ruby-keyword">break</span>}
  <span class="ruby-ivar">@columns</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-value">:@columns</span>)
  <span class="ruby-ivar">@columns</span> <span class="ruby-operator">||</span> []
<span class="ruby-keyword">end</span></pre>
            </div><!-- columns-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Dataset.html#method-i-columns_without_introspection">columns_without_introspection</a>
          </div>
          

          
        </div><!-- columns-method -->

      
        <div id="columns-21-method" class="method-detail ">
          <a name="method-i-columns-21"></a>

          
          <div class="method-heading">
            <span class="method-name">columns!</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Ignore any cached column information and perform a query to retrieve a row
in order to get the columns.</p>

<pre>DB[:table].columns!
# =&gt; [:id, :name]</pre>
            

            
            <div class="method-source-code" id="columns-21-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">columns!</span>
  <span class="ruby-ivar">@columns</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">columns</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- columns-21-source -->
            
          </div>

          

          
        </div><!-- columns-21-method -->

      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          <div class="method-heading">
            <span class="method-name">count</span><span
              class="method-args">(arg=(no_arg=true), &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the number of records in the dataset. If an argument is provided,
it is used as the argument to count.  If a block is provided, it is treated
as a virtual row, and the result is used as the argument to count.</p>

<pre>DB[:table].count # SELECT COUNT(*) AS count FROM table LIMIT 1
# =&gt; 3
DB[:table].count(:column) # SELECT COUNT(column) AS count FROM table LIMIT 1
# =&gt; 2
DB[:table].count{foo(column)} # SELECT COUNT(foo(column)) AS count FROM table LIMIT 1
# =&gt; 1</pre>
            

            
            <div class="method-source-code" id="count-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">count</span>(<span class="ruby-identifier">arg</span>=(<span class="ruby-identifier">no_arg</span>=<span class="ruby-keyword">true</span>), &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">no_arg</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
      <span class="ruby-identifier">arg</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">virtual_row</span>(&amp;<span class="ruby-identifier">block</span>)
      <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-constant">COUNT</span>(<span class="ruby-identifier">arg</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">count</span>)}
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-constant">COUNT</span>(<span class="ruby-value">:*</span>){}.<span class="ruby-identifier">as</span>(<span class="ruby-identifier">count</span>)}.<span class="ruby-identifier">to_i</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">'cannot provide both argument and block to Dataset#count'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-constant">COUNT</span>(<span class="ruby-identifier">arg</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">count</span>)}
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->

      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          <div class="method-heading">
            <span class="method-name">delete</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Deletes the records in the dataset.  The returned value should be  number
of records deleted, but that is adapter dependent.</p>

<pre>DB[:table].delete # DELETE * FROM table
# =&gt; 3</pre>
            

            
            <div class="method-source-code" id="delete-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete</span>(&amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-identifier">delete_sql</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">uses_returning?</span>(<span class="ruby-value">:delete</span>)
    <span class="ruby-identifier">returning_fetch_rows</span>(<span class="ruby-identifier">sql</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">execute_dui</span>(<span class="ruby-identifier">sql</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->

      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          <div class="method-heading">
            <span class="method-name">each</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Iterates over the records in the dataset as they are yielded from the
database adapter, and returns self.</p>

<pre>DB[:table].each{|row| p row} # SELECT * FROM table</pre>

<p>Note that this method is not safe to use on many adapters if you are
running additional queries inside the provided block.  If you are running
queries inside the block, you should use <tt>all</tt> instead of
<tt>each</tt> for the outer queries, or use a separate thread or shard
inside <tt>each</tt>:</p>
            

            
            <div class="method-source-code" id="each-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:graph</span>]
    <span class="ruby-identifier">graph_each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">row_proc</span> = <span class="ruby-ivar">@row_proc</span>
    <span class="ruby-identifier">fetch_rows</span>(<span class="ruby-identifier">select_sql</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">row_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">r</span>)}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">fetch_rows</span>(<span class="ruby-identifier">select_sql</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->

      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">empty?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns true if no records exist in the dataset, false otherwise</p>

<pre>DB[:table].empty? # SELECT 1 AS one FROM table LIMIT 1
# =&gt; false</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">get</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:one</span>)).<span class="ruby-identifier">nil?</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->

      
        <div id="fetch_rows-method" class="method-detail ">
          <a name="method-i-fetch_rows"></a>

          
          <div class="method-heading">
            <span class="method-name">fetch_rows</span><span
              class="method-args">(sql)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Executes a select query and fetches records, yielding each record to the
supplied block.  The yielded records should be hashes with symbol keys.
This method should probably should not be called by user code, use
<tt>each</tt> instead.</p>
            

            
            <div class="method-source-code" id="fetch_rows-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">fetch_rows</span>(<span class="ruby-identifier">sql</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplemented</span>, <span class="ruby-constant">NOTIMPL_MSG</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- fetch_rows-source -->
            
          </div>

          

          
        </div><!-- fetch_rows-method -->

      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          <div class="method-heading">
            <span class="method-name">first</span><span
              class="method-args">(*args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>If a integer argument is given, it is interpreted as a limit, and then
returns all  matching records up to that limit.  If no argument is passed,
it returns the first matching record.  If any other type of argument(s) is
passed, it is given to filter and the first matching record is returned. If
a block is given, it is used to filter the dataset before returning
anything.  Examples:</p>

<pre>DB[:table].first # SELECT * FROM table LIMIT 1
# =&gt; {:id=&gt;7}

DB[:table].first(2) # SELECT * FROM table LIMIT 2
# =&gt; [{:id=&gt;6}, {:id=&gt;4}]

DB[:table].first(:id=&gt;2) # SELECT * FROM table WHERE (id = 2) LIMIT 1
# =&gt; {:id=&gt;2}

DB[:table].first(&quot;id = 3&quot;) # SELECT * FROM table WHERE (id = 3) LIMIT 1
# =&gt; {:id=&gt;3}

DB[:table].first(&quot;id = ?&quot;, 4) # SELECT * FROM table WHERE (id = 4) LIMIT 1
# =&gt; {:id=&gt;4}

DB[:table].first{id &gt; 2} # SELECT * FROM table WHERE (id &gt; 2) LIMIT 1
# =&gt; {:id=&gt;5}

DB[:table].first(&quot;id &gt; ?&quot;, 4){id &lt; 6} # SELECT * FROM table WHERE ((id &gt; 4) AND (id &lt; 6)) LIMIT 1
# =&gt; {:id=&gt;5}

DB[:table].first(2){id &lt; 2} # SELECT * FROM table WHERE (id &lt; 2) LIMIT 2
# =&gt; [{:id=&gt;1}]</pre>
            

            
            <div class="method-source-code" id="first-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">first</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">block</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">filter</span>(&amp;<span class="ruby-identifier">block</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">single_record</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">args</span> = (<span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">args</span>
    <span class="ruby-keyword">if</span> <span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">args</span>
      <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-identifier">args</span>).<span class="ruby-identifier">all</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">args</span>).<span class="ruby-identifier">single_record</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-i-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span
              class="method-args">(column=(no_arg=true; nil), &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return the column value for the first matching record in the dataset.
Raises an error if both an argument and block is given.</p>

<pre>DB[:table].get(:id) # SELECT id FROM table LIMIT 1
# =&gt; 3

ds.get{sum(id)} # SELECT sum(id) FROM table LIMIT 1
# =&gt; 6</pre>
            

            
            <div class="method-source-code" id="get-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get</span>(<span class="ruby-identifier">column</span>=(<span class="ruby-identifier">no_arg</span>=<span class="ruby-keyword">true</span>; <span class="ruby-keyword">nil</span>), &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-constant">ARG_BLOCK_ERROR_MSG</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">no_arg</span>
    <span class="ruby-identifier">select</span>(&amp;<span class="ruby-identifier">block</span>).<span class="ruby-identifier">single_value</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">select</span>(<span class="ruby-identifier">column</span>).<span class="ruby-identifier">single_value</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get-source -->
            
          </div>

          

          
        </div><!-- get-method -->

      
        <div id="import-method" class="method-detail ">
          <a name="method-i-import"></a>

          
          <div class="method-heading">
            <span class="method-name">import</span><span
              class="method-args">(columns, values, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inserts multiple records into the associated table. This method can be used
to efficiently insert a large number of records into a table in a single
query if the database supports it. Inserts are automatically wrapped in a
transaction.</p>

<p>This method is called with a columns array and an array of value arrays:</p>

<pre>DB[:table].import([:x, :y], [[1, 2], [3, 4]])
# INSERT INTO table (x, y) VALUES (1, 2) 
# INSERT INTO table (x, y) VALUES (3, 4)</pre>

<p>This method also accepts a dataset instead of an array of value arrays:</p>

<pre>DB[:table].import([:x, :y], DB[:table2].select(:a, :b))
# INSERT INTO table (x, y) SELECT a, b FROM table2</pre>

<p>Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:commit_every </p></td>
<td>
<p>Open a new transaction for every given number of records. For example, if
you provide a value of 50, will commit after every 50 records.</p>
</td></tr><tr><td class="rdoc-term"><p>:server </p></td>
<td>
<p>Set the server/shard to use for the transaction and insert queries.</p>
</td></tr><tr><td class="rdoc-term"><p>:slice </p></td>
<td>
<p>Same as :commit_every, :commit_every takes precedence.</p>
</td></tr></table>
            

            
            <div class="method-source-code" id="import-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">import</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-keyword">return</span> <span class="ruby-ivar">@db</span>.<span class="ruby-identifier">transaction</span>{<span class="ruby-identifier">insert</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>)} <span class="ruby-keyword">if</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Dataset</span>)

  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-constant">IMPORT_ERROR_MSG</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">server</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
  
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">slice_size</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:commit_every</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:slice</span>]
    <span class="ruby-identifier">offset</span> = <span class="ruby-value">0</span>
    <span class="ruby-identifier">rows</span> = []
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">offset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-identifier">rows</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">_import</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>[<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">slice_size</span>], <span class="ruby-identifier">opts</span>)
      <span class="ruby-identifier">offset</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">slice_size</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">rows</span>.<span class="ruby-identifier">flatten</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">_import</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- import-source -->
            
          </div>

          

          
        </div><!-- import-method -->

      
        <div id="insert-method" class="method-detail ">
          <a name="method-i-insert"></a>

          
          <div class="method-heading">
            <span class="method-name">insert</span><span
              class="method-args">(*values, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inserts values into the associated table.  The returned value is generally
the value of the primary key for the inserted row, but that is adapter
dependent.</p>

<p><tt>insert</tt> handles a number of different argument formats:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>no arguments or single empty hash </p></td>
<td>
<p>Uses <a href="Dataset.html#DEFAULT">DEFAULT</a> <a
href="Dataset.html#VALUES">VALUES</a></p>
</td></tr><tr><td class="rdoc-term"><p>single hash </p></td>
<td>
<p>Most common format, treats keys as columns an values as values</p>
</td></tr><tr><td class="rdoc-term"><p>single array </p></td>
<td>
<p>Treats entries as values, with no columns</p>
</td></tr><tr><td class="rdoc-term"><p>two arrays </p></td>
<td>
<p>Treats first array as columns, second array as values</p>
</td></tr><tr><td class="rdoc-term"><p>single <a href="Dataset.html">Dataset</a> </p></td>
<td>
<p>Treats as an insert based on a selection from the dataset given, with no
columns</p>
</td></tr><tr><td class="rdoc-term"><p>array and dataset </p></td>
<td>
<p>Treats as an insert based on a selection from the dataset given, with the
columns given by the array.</p>
</td></tr></table>

<p>Examples:</p>

<pre>DB[:items].insert
# INSERT INTO items DEFAULT VALUES

DB[:items].insert({})
# INSERT INTO items DEFAULT VALUES

DB[:items].insert([1,2,3])
# INSERT INTO items VALUES (1, 2, 3)

DB[:items].insert([:a, :b], [1,2])
# INSERT INTO items (a, b) VALUES (1, 2)

DB[:items].insert(:a =&gt; 1, :b =&gt; 2)
# INSERT INTO items (a, b) VALUES (1, 2)

DB[:items].insert(DB[:old_items])
# INSERT INTO items SELECT * FROM old_items

DB[:items].insert([:a, :b], DB[:old_items])
# INSERT INTO items (a, b) SELECT * FROM old_items</pre>
            

            
            <div class="method-source-code" id="insert-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">insert</span>(*<span class="ruby-identifier">values</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-identifier">insert_sql</span>(*<span class="ruby-identifier">values</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">uses_returning?</span>(<span class="ruby-value">:insert</span>)
    <span class="ruby-identifier">returning_fetch_rows</span>(<span class="ruby-identifier">sql</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">execute_insert</span>(<span class="ruby-identifier">sql</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- insert-source -->
            
          </div>

          

          
        </div><!-- insert-method -->

      
        <div id="insert_multiple-method" class="method-detail ">
          <a name="method-i-insert_multiple"></a>

          
          <div class="method-heading">
            <span class="method-name">insert_multiple</span><span
              class="method-args">(array, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Inserts multiple values. If a block is given it is invoked for each item in
the given array before inserting it.  See <tt>multi_insert</tt> as a
possibly faster version that may be able to insert multiple records in one
<a href="SQL.html">SQL</a> statement (if supported by the database).
Returns an array of primary keys of inserted rows.</p>

<pre>DB[:table].insert_multiple([{:x=&gt;1}, {:x=&gt;2}])
# =&gt; [4, 5]
# INSERT INTO table (x) VALUES (1)
# INSERT INTO table (x) VALUES (2)

DB[:table].insert_multiple([{:x=&gt;1}, {:x=&gt;2}]){|row| row[:y] = row[:x] * 2; row }
# =&gt; [6, 7]
# INSERT INTO table (x, y) VALUES (1, 2)
# INSERT INTO table (x, y) VALUES (2, 4)</pre>
            

            
            <div class="method-source-code" id="insert_multiple-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">insert_multiple</span>(<span class="ruby-identifier">array</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
    <span class="ruby-identifier">array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">insert</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">i</span>))}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">insert</span>(<span class="ruby-identifier">i</span>)}
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- insert_multiple-source -->
            
          </div>

          

          
        </div><!-- insert_multiple-method -->

      
        <div id="interval-method" class="method-detail ">
          <a name="method-i-interval"></a>

          
          <div class="method-heading">
            <span class="method-name">interval</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the interval between minimum and maximum values for the given 
column.</p>

<pre>DB[:table].interval(:id) # SELECT (max(id) - min(id)) FROM table LIMIT 1
# =&gt; 6</pre>
            

            
            <div class="method-source-code" id="interval-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">interval</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-identifier">max</span>(<span class="ruby-identifier">column</span>) <span class="ruby-operator">-</span> <span class="ruby-identifier">min</span>(<span class="ruby-identifier">column</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- interval-source -->
            
          </div>

          

          
        </div><!-- interval-method -->

      
        <div id="last-method" class="method-detail ">
          <a name="method-i-last"></a>

          
          <div class="method-heading">
            <span class="method-name">last</span><span
              class="method-args">(*args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Reverses the order and then runs <a
href="Dataset.html#method-i-first">first</a> with the given arguments and
block.  Note that this will not necessarily give you the last record in the
dataset, unless you have an unambiguous order.  If there is not currently
an order for this dataset, raises an <tt>Error</tt>.</p>

<pre>DB[:table].order(:id).last # SELECT * FROM table ORDER BY id DESC LIMIT 1
# =&gt; {:id=&gt;10}

DB[:table].order(Sequel.desc(:id)).last(2) # SELECT * FROM table ORDER BY id ASC LIMIT 2
# =&gt; [{:id=&gt;1}, {:id=&gt;2}]</pre>
            

            
            <div class="method-source-code" id="last-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">last</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'No order specified'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>]
  <span class="ruby-identifier">reverse</span>.<span class="ruby-identifier">first</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- last-source -->
            
          </div>

          

          
        </div><!-- last-method -->

      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          <div class="method-heading">
            <span class="method-name">map</span><span
              class="method-args">(column=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Maps column values for each record in the dataset (if a column name is
given), or performs the stock mapping functionality of <tt>Enumerable</tt>
otherwise.  Raises an <tt>Error</tt> if both an argument and block are
given.</p>

<pre>DB[:table].map(:id) # SELECT * FROM table
# =&gt; [1, 2, 3, ...]

DB[:table].map{|r| r[:id] * 2} # SELECT * FROM table
# =&gt; [2, 4, 6, ...]</pre>

<p>You can also provide an array of column names:</p>

<pre>DB[:table].map([:id, :name]) # SELECT * FROM table
# =&gt; [[1, 'A'], [2, 'B'], [3, 'C'], ...]</pre>
            

            
            <div class="method-source-code" id="map-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 382</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map</span>(<span class="ruby-identifier">column</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">column</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-constant">ARG_BLOCK_ERROR_MSG</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">naked</span>.<span class="ruby-identifier">map</span>(<span class="ruby-identifier">column</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">row_proc</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
      <span class="ruby-keyword">super</span>(){<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">column</span>)}
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">super</span>(){<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>[<span class="ruby-identifier">column</span>]}
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">super</span>(&amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->

      
        <div id="max-method" class="method-detail ">
          <a name="method-i-max"></a>

          
          <div class="method-heading">
            <span class="method-name">max</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the maximum value for the given column.</p>

<pre>DB[:table].max(:id) # SELECT max(id) FROM table LIMIT 1
# =&gt; 10</pre>
            

            
            <div class="method-source-code" id="max-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-identifier">max</span>(<span class="ruby-identifier">column</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- max-source -->
            
          </div>

          

          
        </div><!-- max-method -->

      
        <div id="min-method" class="method-detail ">
          <a name="method-i-min"></a>

          
          <div class="method-heading">
            <span class="method-name">min</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the minimum value for the given column.</p>

<pre>DB[:table].min(:id) # SELECT min(id) FROM table LIMIT 1
# =&gt; 1</pre>
            

            
            <div class="method-source-code" id="min-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">min</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-identifier">min</span>(<span class="ruby-identifier">column</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- min-source -->
            
          </div>

          

          
        </div><!-- min-method -->

      
        <div id="multi_insert-method" class="method-detail ">
          <a name="method-i-multi_insert"></a>

          
          <div class="method-heading">
            <span class="method-name">multi_insert</span><span
              class="method-args">(hashes, opts={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This is a front end for import that allows you to submit an array of hashes
instead of arrays of columns and values:</p>

<pre>DB[:table].multi_insert([{:x =&gt; 1}, {:x =&gt; 2}])
# INSERT INTO table (x) VALUES (1)
# INSERT INTO table (x) VALUES (2)</pre>

<p>Be aware that all hashes should have the same keys if you use this calling
method, otherwise some columns could be missed or set to null instead of to
default values.</p>

<p>This respects the same options as <a
href="Dataset.html#method-i-import">import</a>.</p>
            

            
            <div class="method-source-code" id="multi_insert-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">multi_insert</span>(<span class="ruby-identifier">hashes</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">hashes</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">columns</span> = <span class="ruby-identifier">hashes</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">keys</span>
  <span class="ruby-identifier">import</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">hashes</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">h</span><span class="ruby-operator">|</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">c</span>]}}, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- multi_insert-source -->
            
          </div>

          

          
        </div><!-- multi_insert-method -->

      
        <div id="range-method" class="method-detail ">
          <a name="method-i-range"></a>

          
          <div class="method-heading">
            <span class="method-name">range</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a <tt>Range</tt> instance made from the minimum and maximum values
for the given column.</p>

<pre>DB[:table].range(:id) # SELECT max(id) AS v1, min(id) AS v2 FROM table LIMIT 1
# =&gt; 1..10</pre>
            

            
            <div class="method-source-code" id="range-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 435</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">range</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span> = <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">select</span>{[<span class="ruby-identifier">min</span>(<span class="ruby-identifier">column</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">v1</span>), <span class="ruby-identifier">max</span>(<span class="ruby-identifier">column</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">v2</span>)]}.<span class="ruby-identifier">first</span>
    (<span class="ruby-identifier">r</span>[<span class="ruby-value">:v1</span>]<span class="ruby-operator">..</span><span class="ruby-identifier">r</span>[<span class="ruby-value">:v2</span>])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- range-source -->
            
          </div>

          

          
        </div><!-- range-method -->

      
        <div id="select_hash-method" class="method-detail ">
          <a name="method-i-select_hash"></a>

          
          <div class="method-heading">
            <span class="method-name">select_hash</span><span
              class="method-args">(key_column, value_column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a hash with key_column values as keys and value_column values as
values.  Similar to <a href="Dataset.html#method-i-to_hash">to_hash</a>,
but only selects the columns given.</p>

<pre>DB[:table].select_hash(:id, :name) # SELECT id, name FROM table
# =&gt; {1=&gt;'a', 2=&gt;'b', ...}</pre>

<p>You can also provide an array of column names for either the key_column,
the value column, or both:</p>

<pre>DB[:table].select_hash([:id, :foo], [:name, :bar]) # SELECT * FROM table
# {[1, 3]=&gt;['a', 'c'], [2, 4]=&gt;['b', 'd'], ...}</pre>

<p>When using this method, you must be sure that each expression has an alias
that <a href="../Sequel.html">Sequel</a> can determine.  Usually you can do
this by calling the <a href="SQL/AliasMethods.html#method-i-as">as</a>
method on the expression and providing an alias.</p>
            

            
            <div class="method-source-code" id="select_hash-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 456</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_hash</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>)
  <span class="ruby-identifier">_select_hash</span>(<span class="ruby-value">:to_hash</span>, <span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_hash-source -->
            
          </div>

          

          
        </div><!-- select_hash-method -->

      
        <div id="select_hash_groups-method" class="method-detail ">
          <a name="method-i-select_hash_groups"></a>

          
          <div class="method-heading">
            <span class="method-name">select_hash_groups</span><span
              class="method-args">(key_column, value_column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a hash with key_column values as keys and an array of value_column
values. Similar to <a
href="Dataset.html#method-i-to_hash_groups">to_hash_groups</a>, but only
selects the columns given.</p>

<pre>DB[:table].select_hash(:name, :id) # SELECT id, name FROM table
# =&gt; {'a'=&gt;[1, 4, ...], 'b'=&gt;[2, ...], ...}</pre>

<p>You can also provide an array of column names for either the key_column,
the value column, or both:</p>

<pre>DB[:table].select_hash([:first, :middle], [:last, :id]) # SELECT * FROM table
# {['a', 'b']=&gt;[['c', 1], ['d', 2], ...], ...}</pre>

<p>When using this method, you must be sure that each expression has an alias
that <a href="../Sequel.html">Sequel</a> can determine.  Usually you can do
this by calling the <a href="SQL/AliasMethods.html#method-i-as">as</a>
method on the expression and providing an alias.</p>
            

            
            <div class="method-source-code" id="select_hash_groups-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 475</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_hash_groups</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>)
  <span class="ruby-identifier">_select_hash</span>(<span class="ruby-value">:to_hash_groups</span>, <span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_hash_groups-source -->
            
          </div>

          

          
        </div><!-- select_hash_groups-method -->

      
        <div id="select_map-method" class="method-detail ">
          <a name="method-i-select_map"></a>

          
          <div class="method-heading">
            <span class="method-name">select_map</span><span
              class="method-args">(column=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Selects the column given (either as an argument or as a block), and returns
an array of all values of that column in the dataset.  If you give a block
argument that returns an array with multiple entries, the contents of the
resulting array are undefined.  Raises an <a href="Error.html">Error</a> if
called with both an argument and a block.</p>

<pre>DB[:table].select_map(:id) # SELECT id FROM table
# =&gt; [3, 5, 8, 1, ...]

DB[:table].select_map{id * 2} # SELECT (id * 2) FROM table
# =&gt; [6, 10, 16, 2, ...]</pre>

<p>You can also provide an array of column names:</p>

<pre>DB[:table].select_map([:id, :name]) # SELECT id, name FROM table
# =&gt; [[1, 'A'], [2, 'B'], [3, 'C'], ...]</pre>

<p>If you provide an array of expressions, you must be sure that each entry in
the array has an alias that <a href="../Sequel.html">Sequel</a> can
determine.  Usually you can do this by calling the <a
href="SQL/AliasMethods.html#method-i-as">as</a> method on the expression
and providing an alias.</p>
            

            
            <div class="method-source-code" id="select_map-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 499</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_map</span>(<span class="ruby-identifier">column</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_select_map</span>(<span class="ruby-identifier">column</span>, <span class="ruby-keyword">false</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_map-source -->
            
          </div>

          

          
        </div><!-- select_map-method -->

      
        <div id="select_order_map-method" class="method-detail ">
          <a name="method-i-select_order_map"></a>

          
          <div class="method-heading">
            <span class="method-name">select_order_map</span><span
              class="method-args">(column=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The same as <a href="Dataset.html#method-i-select_map">select_map</a>, but
in addition orders the array by the column.</p>

<pre>DB[:table].select_order_map(:id) # SELECT id FROM table ORDER BY id
# =&gt; [1, 2, 3, 4, ...]

DB[:table].select_order_map{id * 2} # SELECT (id * 2) FROM table ORDER BY (id * 2)
# =&gt; [2, 4, 6, 8, ...]</pre>

<p>You can also provide an array of column names:</p>

<pre>DB[:table].select_order_map([:id, :name]) # SELECT id, name FROM table ORDER BY id, name
# =&gt; [[1, 'A'], [2, 'B'], [3, 'C'], ...]</pre>

<p>If you provide an array of expressions, you must be sure that each entry in
the array has an alias that <a href="../Sequel.html">Sequel</a> can
determine.  Usually you can do this by calling the <a
href="SQL/AliasMethods.html#method-i-as">as</a> method on the expression
and providing an alias.</p>
            

            
            <div class="method-source-code" id="select_order_map-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 519</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_order_map</span>(<span class="ruby-identifier">column</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">_select_map</span>(<span class="ruby-identifier">column</span>, <span class="ruby-keyword">true</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_order_map-source -->
            
          </div>

          

          
        </div><!-- select_order_map-method -->

      
        <div id="set-method" class="method-detail ">
          <a name="method-i-set"></a>

          
          <div class="method-heading">
            <span class="method-name">set</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias for update, but not aliased directly so subclasses don't have to
override both methods.</p>
            

            
            <div class="method-source-code" id="set-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 525</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set</span>(*<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">update</span>(*<span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- set-source -->
            
          </div>

          

          
        </div><!-- set-method -->

      
        <div id="single_record-method" class="method-detail ">
          <a name="method-i-single_record"></a>

          
          <div class="method-heading">
            <span class="method-name">single_record</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the first record in the dataset, or nil if the dataset has no
records. Users should probably use <tt>first</tt> instead of this method.</p>
            

            
            <div class="method-source-code" id="single_record-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 532</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">single_record</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:limit=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-keyword">return</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- single_record-source -->
            
          </div>

          

          
        </div><!-- single_record-method -->

      
        <div id="single_value-method" class="method-detail ">
          <a name="method-i-single_value"></a>

          
          <div class="method-heading">
            <span class="method-name">single_value</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the first value of the first record in the dataset. Returns nil if
dataset is empty.  Users should generally use <tt>get</tt> instead of this
method.</p>
            

            
            <div class="method-source-code" id="single_value-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 540</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">single_value</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span> = <span class="ruby-identifier">naked</span>.<span class="ruby-identifier">ungraphed</span>.<span class="ruby-identifier">single_record</span>
    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- single_value-source -->
            
          </div>

          

          
        </div><!-- single_value-method -->

      
        <div id="sum-method" class="method-detail ">
          <a name="method-i-sum"></a>

          
          <div class="method-heading">
            <span class="method-name">sum</span><span
              class="method-args">(column)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the sum for the given column.</p>

<pre>DB[:table].sum(:id) # SELECT sum(id) FROM table LIMIT 1
# =&gt; 55</pre>
            

            
            <div class="method-source-code" id="sum-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 550</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">column</span>)
  <span class="ruby-identifier">aggregate_dataset</span>.<span class="ruby-identifier">get</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">column</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- sum-source -->
            
          </div>

          

          
        </div><!-- sum-method -->

      
        <div id="to_csv-method" class="method-detail ">
          <a name="method-i-to_csv"></a>

          
          <div class="method-heading">
            <span class="method-name">to_csv</span><span
              class="method-args">(include_column_titles = true)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a string in CSV format containing the dataset records. By  default
the CSV representation includes the column titles in the first line. You
can turn that off by passing false as the  include_column_titles argument.</p>

<p>This does not use a CSV library or handle quoting of values in any way.  If
any values in any of the rows could include commas or line endings, you
shouldn't use this.</p>

<pre>puts DB[:table].to_csv # SELECT * FROM table
# id,name
# 1,Jim
# 2,Bob</pre>
            

            
            <div class="method-source-code" id="to_csv-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 567</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_csv</span>(<span class="ruby-identifier">include_column_titles</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">n</span> = <span class="ruby-identifier">naked</span>
  <span class="ruby-identifier">cols</span> = <span class="ruby-identifier">n</span>.<span class="ruby-identifier">columns</span>
  <span class="ruby-identifier">csv</span> = <span class="ruby-string">''</span>
  <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;#{cols.join(COMMA_SEPARATOR)}\r\n&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">include_column_titles</span>
  <span class="ruby-identifier">n</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">csv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;#{cols.collect{|c| r[c]}.join(COMMA_SEPARATOR)}\r\n&quot;</span>}
  <span class="ruby-identifier">csv</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_csv-source -->
            
          </div>

          

          
        </div><!-- to_csv-method -->

      
        <div id="to_hash-method" class="method-detail ">
          <a name="method-i-to_hash"></a>

          
          <div class="method-heading">
            <span class="method-name">to_hash</span><span
              class="method-args">(key_column, value_column = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a hash with one column used as key and another used as value. If
rows have duplicate values for the key column, the latter row(s) will
overwrite the value of the previous row(s). If the value_column is not
given or nil, uses the entire hash as the value.</p>

<pre>DB[:table].to_hash(:id, :name) # SELECT * FROM table
# {1=&gt;'Jim', 2=&gt;'Bob', ...}

DB[:table].to_hash(:id) # SELECT * FROM table
# {1=&gt;{:id=&gt;1, :name=&gt;'Jim'}, 2=&gt;{:id=&gt;2, :name=&gt;'Bob'}, ...}</pre>

<p>You can also provide an array of column names for either the key_column,
the value column, or both:</p>

<pre>DB[:table].to_hash([:id, :foo], [:name, :bar]) # SELECT * FROM table
# {[1, 3]=&gt;['Jim', 'bo'], [2, 4]=&gt;['Bob', 'be'], ...}

DB[:table].to_hash([:id, :name]) # SELECT * FROM table
# {[1, 'Jim']=&gt;{:id=&gt;1, :name=&gt;'Jim'}, [2, 'Bob'=&gt;{:id=&gt;2, :name=&gt;'Bob'}, ...}</pre>
            

            
            <div class="method-source-code" id="to_hash-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 595</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">h</span> = {}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">value_column</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">naked</span>.<span class="ruby-identifier">to_hash</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">row_proc</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">value_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">value_column</span>)}
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">value_column</span>)}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] = <span class="ruby-identifier">r</span>[<span class="ruby-identifier">value_column</span>]}
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] = <span class="ruby-identifier">r</span>[<span class="ruby-identifier">value_column</span>]}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] = <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] = <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">h</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_hash-source -->
            
          </div>

          

          
        </div><!-- to_hash-method -->

      
        <div id="to_hash_groups-method" class="method-detail ">
          <a name="method-i-to_hash_groups"></a>

          
          <div class="method-heading">
            <span class="method-name">to_hash_groups</span><span
              class="method-args">(key_column, value_column = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a hash with one column used as key and the values being an array of
column values. If the value_column is not given or nil, uses the entire
hash as the value.</p>

<pre>DB[:table].to_hash(:name, :id) # SELECT * FROM table
# {'Jim'=&gt;[1, 4, 16, ...], 'Bob'=&gt;[2], ...}

DB[:table].to_hash(:name) # SELECT * FROM table
# {'Jim'=&gt;[{:id=&gt;1, :name=&gt;'Jim'}, {:id=&gt;4, :name=&gt;'Jim'}, ...], 'Bob'=&gt;[{:id=&gt;2, :name=&gt;'Bob'}], ...}</pre>

<p>You can also provide an array of column names for either the key_column,
the value column, or both:</p>

<pre>DB[:table].to_hash([:first, :middle], [:last, :id]) # SELECT * FROM table
# {['Jim', 'Bob']=&gt;[['Smith', 1], ['Jackson', 4], ...], ...}

DB[:table].to_hash([:first, :middle]) # SELECT * FROM table
# {['Jim', 'Bob']=&gt;[{:id=&gt;1, :first=&gt;'Jim', :middle=&gt;'Bob', :last=&gt;'Smith'}, ...], ...}</pre>
            

            
            <div class="method-source-code" id="to_hash_groups-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 638</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash_groups</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">h</span> = {}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">value_column</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">naked</span>.<span class="ruby-identifier">to_hash_groups</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">row_proc</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">value_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">value_column</span>)}
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">value_column</span>)}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-identifier">value_column</span>]}
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-identifier">value_column</span>]}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">key_column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">key_column</span>)] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">r</span>[<span class="ruby-identifier">key_column</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>}
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">h</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_hash_groups-source -->
            
          </div>

          

          
        </div><!-- to_hash_groups-method -->

      
        <div id="truncate-method" class="method-detail ">
          <a name="method-i-truncate"></a>

          
          <div class="method-heading">
            <span class="method-name">truncate</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Truncates the dataset.  Returns nil.</p>

<pre>DB[:table].truncate # TRUNCATE table
# =&gt; nil</pre>
            

            
            <div class="method-source-code" id="truncate-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 667</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">truncate</span>
  <span class="ruby-identifier">execute_ddl</span>(<span class="ruby-identifier">truncate_sql</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- truncate-source -->
            
          </div>

          

          
        </div><!-- truncate-method -->

      
        <div id="update-method" class="method-detail ">
          <a name="method-i-update"></a>

          
          <div class="method-heading">
            <span class="method-name">update</span><span
              class="method-args">(values={}, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Updates values for the dataset.  The returned value is generally the number
of rows updated, but that is adapter dependent. <tt>values</tt> should a
hash where the keys are columns to set and values are the values to which
to set the columns.</p>

<pre>DB[:table].update(:x=&gt;nil) # UPDATE table SET x = NULL
# =&gt; 10

DB[:table].update(:x=&gt;:x+1, :y=&gt;0) # UPDATE table SET x = (x + 1), y = 0
# =&gt; 10</pre>
            

            
            <div class="method-source-code" id="update-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 681</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">update</span>(<span class="ruby-identifier">values</span>={}, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-identifier">update_sql</span>(<span class="ruby-identifier">values</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">uses_returning?</span>(<span class="ruby-value">:update</span>)
    <span class="ruby-identifier">returning_fetch_rows</span>(<span class="ruby-identifier">sql</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">execute_dui</span>(<span class="ruby-identifier">sql</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- update-source -->
            
          </div>

          

          
        </div><!-- update-method -->

      
        <div id="with_sql_delete-method" class="method-detail ">
          <a name="method-i-with_sql_delete"></a>

          
          <div class="method-heading">
            <span class="method-name">with_sql_delete</span><span
              class="method-args">(sql)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Execute the given <a href="SQL.html">SQL</a> and return the number of rows
deleted.  This exists solely as an optimization, replacing <a
href="Dataset.html#method-i-with_sql">with_sql</a>(sql).delete.  It's
significantly faster as it does not require cloning the current dataset.</p>
            

            
            <div class="method-source-code" id="with_sql_delete-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 693</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_sql_delete</span>(<span class="ruby-identifier">sql</span>)
  <span class="ruby-identifier">execute_dui</span>(<span class="ruby-identifier">sql</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- with_sql_delete-source -->
            
          </div>

          

          
        </div><!-- with_sql_delete-method -->

      
      </div><!-- public-instance-method-details -->
    
      <div id="protected-instance-method-details" class="method-section section">
        <h3 class="section-header">Protected Instance Methods</h3>

      
        <div id="_import-method" class="method-detail ">
          <a name="method-i-_import"></a>

          
          <div class="method-heading">
            <span class="method-name">_import</span><span
              class="method-args">(columns, values, opts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internals of <a href="Dataset.html#method-i-import">import</a>.  If primary
key values are requested, use separate insert commands for each row. 
Otherwise, call <a
href="Dataset.html#method-i-multi_insert_sql">multi_insert_sql</a> and
execute each statement it gives separately.</p>
            

            
            <div class="method-source-code" id="_import-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 702</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">_import</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-identifier">trans_opts</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-value">:server=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@opts</span>[<span class="ruby-value">:server</span>])
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:return</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:primary_key</span>
    <span class="ruby-ivar">@db</span>.<span class="ruby-identifier">transaction</span>(<span class="ruby-identifier">trans_opts</span>){<span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">insert</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">v</span>)}}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">stmts</span> = <span class="ruby-identifier">multi_insert_sql</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>)
    <span class="ruby-ivar">@db</span>.<span class="ruby-identifier">transaction</span>(<span class="ruby-identifier">trans_opts</span>){<span class="ruby-identifier">stmts</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">st</span><span class="ruby-operator">|</span> <span class="ruby-identifier">execute_dui</span>(<span class="ruby-identifier">st</span>)}}
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- _import-source -->
            
          </div>

          

          
        </div><!-- _import-method -->

      
        <div id="_select_map_multiple-method" class="method-detail ">
          <a name="method-i-_select_map_multiple"></a>

          
          <div class="method-heading">
            <span class="method-name">_select_map_multiple</span><span
              class="method-args">(ret_cols)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return an array of arrays of values given by the symbols in ret_cols.</p>
            

            
            <div class="method-source-code" id="_select_map_multiple-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 713</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">_select_map_multiple</span>(<span class="ruby-identifier">ret_cols</span>)
  <span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">ret_cols</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- _select_map_multiple-source -->
            
          </div>

          

          
        </div><!-- _select_map_multiple-method -->

      
        <div id="_select_map_single-method" class="method-detail ">
          <a name="method-i-_select_map_single"></a>

          
          <div class="method-heading">
            <span class="method-name">_select_map_single</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns an array of the first value in each row.</p>
            

            
            <div class="method-source-code" id="_select_map_single-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/actions.rb, line 718</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">_select_map_single</span>
  <span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">first</span>}
<span class="ruby-keyword">end</span></pre>
            </div><!-- _select_map_single-source -->
            
          </div>

          

          
        </div><!-- _select_map_single-method -->

      
      </div><!-- protected-instance-method-details -->
    
    </div><!-- 2+-+Methods+that+execute+code+on+the+database -->
  
    
    
    <div id="3+-+User+Methods+relating+to+SQL+Creation" class="documentation-section">
      
      <h2 class="section-header">
        3 - User Methods relating to SQL Creation
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These are methods you can call to see what <a href="SQL.html">SQL</a> will
be generated by the dataset.</p>

      </div>
      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="delete_sql-method" class="method-detail ">
          <a name="method-i-delete_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">delete_sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a <a href="Dataset.html#DELETE">DELETE</a> <a
href="SQL.html">SQL</a> query string.  See <tt>delete</tt>.</p>

<pre>dataset.filter{|o| o.price &gt;= 100}.delete_sql
# =&gt; &quot;DELETE FROM items WHERE (price &gt;= 100)&quot;</pre>
            

            
            <div class="method-source-code" id="delete_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete_sql</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">static_sql</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>]
  <span class="ruby-identifier">check_modification_allowed!</span>
  <span class="ruby-identifier">clause_sql</span>(<span class="ruby-value">:delete</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- delete_sql-source -->
            
          </div>

          

          
        </div><!-- delete_sql-method -->

      
        <div id="exists-method" class="method-detail ">
          <a name="method-i-exists"></a>

          
          <div class="method-heading">
            <span class="method-name">exists</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns an <a href="Dataset.html#EXISTS">EXISTS</a> clause for the dataset
as a <tt>LiteralString</tt>.</p>

<pre>DB.select(1).where(DB[:items].exists)
# SELECT 1 WHERE (EXISTS (SELECT * FROM items))</pre>
            

            
            <div class="method-source-code" id="exists-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exists</span>
  <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">PlaceholderLiteralString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">EXISTS</span>, [<span class="ruby-keyword">self</span>], <span class="ruby-keyword">true</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- exists-source -->
            
          </div>

          

          
        </div><!-- exists-method -->

      
        <div id="insert_sql-method" class="method-detail ">
          <a name="method-i-insert_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">insert_sql</span><span
              class="method-args">(*values)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns an <a href="Dataset.html#INSERT">INSERT</a> <a
href="SQL.html">SQL</a> query string.  See <tt>insert</tt>.</p>

<pre>DB[:items].insert_sql(:a=&gt;1)
# =&gt; &quot;INSERT INTO items (a) VALUES (1)&quot;</pre>
            

            
            <div class="method-source-code" id="insert_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">insert_sql</span>(*<span class="ruby-identifier">values</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">static_sql</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:sql</span>]) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:sql</span>]

  <span class="ruby-identifier">check_modification_allowed!</span>

  <span class="ruby-identifier">columns</span> = []

  <span class="ruby-keyword">case</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">0</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">insert_sql</span>({})
  <span class="ruby-keyword">when</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">vals</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
      <span class="ruby-identifier">vals</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:defaults</span>].<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">vals</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:defaults</span>]
      <span class="ruby-identifier">vals</span> = <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:overrides</span>]) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:overrides</span>]
      <span class="ruby-identifier">values</span> = []
      <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> 
        <span class="ruby-identifier">columns</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">k</span>
        <span class="ruby-identifier">values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">v</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Dataset</span>, <span class="ruby-constant">Array</span>, <span class="ruby-constant">LiteralString</span>
      <span class="ruby-identifier">values</span> = <span class="ruby-identifier">vals</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">v0</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)).<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">v1</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>)).<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">v1</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Dataset</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">v1</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">LiteralString</span>))
      <span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span> = <span class="ruby-identifier">v0</span>, <span class="ruby-identifier">v1</span>
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;Different number of values and columns given to insert_sql&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">length</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">insert_supports_empty_values?</span> 
    <span class="ruby-identifier">columns</span> = [<span class="ruby-identifier">columns</span>().<span class="ruby-identifier">last</span>]
    <span class="ruby-identifier">values</span> = [<span class="ruby-constant">DEFAULT</span>]
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:columns=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">columns</span>, <span class="ruby-value">:values=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">values</span>).<span class="ruby-identifier">_insert_sql</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- insert_sql-source -->
            
          </div>

          

          
        </div><!-- insert_sql-method -->

      
        <div id="literal_append-method" class="method-detail ">
          <a name="method-i-literal_append"></a>

          
          <div class="method-heading">
            <span class="method-name">literal_append</span><span
              class="method-args">(sql, v)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a literal representation of a value to be used as part of an <a
href="SQL.html">SQL</a> expression.</p>

<pre>DB[:items].literal(&quot;abc'def\\&quot;) #=&gt; &quot;'abc''def\\\\'&quot;
DB[:items].literal(:items__id) #=&gt; &quot;items.id&quot;
DB[:items].literal([1, 2, 3]) =&gt; &quot;(1, 2, 3)&quot;
DB[:items].literal(DB[:items]) =&gt; &quot;(SELECT * FROM items)&quot;
DB[:items].literal(:x + 1 &gt; :y) =&gt; &quot;((x + 1) &gt; y)&quot;</pre>

<p>If an unsupported object is given, an <tt>Error</tt> is raised.</p>
            

            
            <div class="method-source-code" id="literal_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">v</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">literal_symbol_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">v</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">LiteralString</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">v</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Blob</span>
      <span class="ruby-identifier">literal_blob_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">literal_string_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Integer</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_integer</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">literal_hash_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span>
    <span class="ruby-identifier">literal_expression_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Float</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_float</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">BigDecimal</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_big_decimal</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">NilClass</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_nil</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">TrueClass</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_true</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">FalseClass</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_false</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>
    <span class="ruby-identifier">literal_array_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Time</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQLTime</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">literal_sqltime</span>(<span class="ruby-identifier">v</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">literal_time</span>(<span class="ruby-identifier">v</span>))
  <span class="ruby-keyword">when</span> <span class="ruby-constant">DateTime</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_datetime</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Date</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">literal_date</span>(<span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Dataset</span>
    <span class="ruby-identifier">literal_dataset_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">literal_other_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- literal_append-source -->
            
          </div>

          

          
        </div><!-- literal_append-method -->

      
        <div id="multi_insert_sql-method" class="method-detail ">
          <a name="method-i-multi_insert_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">multi_insert_sql</span><span
              class="method-args">(columns, values)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns an array of insert statements for inserting multiple records. This
method is used by <tt>multi_insert</tt> to format insert statements and
expects a keys array and and an array of value arrays.</p>

<p>This method should be overridden by descendants if the support inserting
multiple records in a single <a href="SQL.html">SQL</a> statement.</p>
            

            
            <div class="method-source-code" id="multi_insert_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">multi_insert_sql</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">values</span>)
  <span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">insert_sql</span>(<span class="ruby-identifier">columns</span>, <span class="ruby-identifier">r</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- multi_insert_sql-source -->
            
          </div>

          

          
        </div><!-- multi_insert_sql-method -->

      
        <div id="select_sql-method" class="method-detail ">
          <a name="method-i-select_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">select_sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a <a href="Dataset.html#SELECT">SELECT</a> <a
href="SQL.html">SQL</a> query string.</p>

<pre>dataset.select_sql # =&gt; &quot;SELECT * FROM items&quot;</pre>
            

            
            <div class="method-source-code" id="select_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_sql</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">static_sql</span>(<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:sql</span>]) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:sql</span>]
  <span class="ruby-identifier">clause_sql</span>(<span class="ruby-value">:select</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_sql-source -->
            
          </div>

          

          
        </div><!-- select_sql-method -->

      
        <div id="sql-method" class="method-detail ">
          <a name="method-i-sql"></a>

          
          <div class="method-heading">
            <span class="method-name">sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Same as <tt>select_sql</tt>, not aliased directly to make subclassing
simpler.</p>
            

            
            <div class="method-source-code" id="sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-identifier">select_sql</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- sql-source -->
            
          </div>

          

          
        </div><!-- sql-method -->

      
        <div id="truncate_sql-method" class="method-detail ">
          <a name="method-i-truncate_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">truncate_sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a TRUNCATE <a href="SQL.html">SQL</a> query string.  See
<tt>truncate</tt></p>

<pre>DB[:items].truncate_sql # =&gt; 'TRUNCATE items'</pre>
            

            
            <div class="method-source-code" id="truncate_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">truncate_sql</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>]
    <span class="ruby-identifier">static_sql</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>])
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">check_truncation_allowed!</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">&quot;Can't truncate filtered datasets&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:where</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:having</span>]
    <span class="ruby-identifier">_truncate_sql</span>(<span class="ruby-identifier">source_list</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:from</span>]))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- truncate_sql-source -->
            
          </div>

          

          
        </div><!-- truncate_sql-method -->

      
        <div id="update_sql-method" class="method-detail ">
          <a name="method-i-update_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">update_sql</span><span
              class="method-args">(values = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Formats an <a href="Dataset.html#UPDATE">UPDATE</a> statement using the
given values.  See <tt>update</tt>.</p>

<pre>DB[:items].update_sql(:price =&gt; 100, :category =&gt; 'software')
# =&gt; &quot;UPDATE items SET price = 100, category = 'software'</pre>

<p>Raises an <tt>Error</tt> if the dataset is grouped or includes more than
one table.</p>
            

            
            <div class="method-source-code" id="update_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">update_sql</span>(<span class="ruby-identifier">values</span> = {})
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">static_sql</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:sql</span>]
  <span class="ruby-identifier">check_modification_allowed!</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:values=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">values</span>).<span class="ruby-identifier">_update_sql</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- update_sql-source -->
            
          </div>

          

          
        </div><!-- update_sql-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 3+-+User+Methods+relating+to+SQL+Creation -->
  
    
    
    <div id="4+-+Methods+that+describe+what+the+dataset+supports" class="documentation-section">
      
      <h2 class="section-header">
        4 - Methods that describe what the dataset supports
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods all return booleans, with most describing whether or not the
dataset supports a feature.</p>

      </div>
      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="provides_accurate_rows_matched-3F-method" class="method-detail ">
          <a name="method-i-provides_accurate_rows_matched-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">provides_accurate_rows_matched?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether this dataset will provide accurate number of rows matched for
delete and update statements.  Accurate in this case is the number of rows
matched by the dataset's filter.</p>
            

            
            <div class="method-source-code" id="provides_accurate_rows_matched-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">provides_accurate_rows_matched?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- provides_accurate_rows_matched-3F-source -->
            
          </div>

          

          
        </div><!-- provides_accurate_rows_matched-3F-method -->

      
        <div id="quote_identifiers-3F-method" class="method-detail ">
          <a name="method-i-quote_identifiers-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">quote_identifiers?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether this dataset quotes identifiers.</p>
            

            
            <div class="method-source-code" id="quote_identifiers-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">quote_identifiers?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@quote_identifiers</span>)
    <span class="ruby-ivar">@quote_identifiers</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">db</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:quote_identifiers?</span>)
    <span class="ruby-ivar">@quote_identifiers</span> = <span class="ruby-identifier">db</span>.<span class="ruby-identifier">quote_identifiers?</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@quote_identifiers</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- quote_identifiers-3F-source -->
            
          </div>

          

          
        </div><!-- quote_identifiers-3F-method -->

      
        <div id="recursive_cte_requires_column_aliases-3F-method" class="method-detail ">
          <a name="method-i-recursive_cte_requires_column_aliases-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">recursive_cte_requires_column_aliases?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether you must use a column alias list for recursive CTEs (false by
default).</p>
            

            
            <div class="method-source-code" id="recursive_cte_requires_column_aliases-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">recursive_cte_requires_column_aliases?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- recursive_cte_requires_column_aliases-3F-source -->
            
          </div>

          

          
        </div><!-- recursive_cte_requires_column_aliases-3F-method -->

      
        <div id="requires_placeholder_type_specifiers-3F-method" class="method-detail ">
          <a name="method-i-requires_placeholder_type_specifiers-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">requires_placeholder_type_specifiers?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether type specifiers are required for prepared statement/bound variable
argument placeholders (i.e. :bv__integer)</p>
            

            
            <div class="method-source-code" id="requires_placeholder_type_specifiers-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">requires_placeholder_type_specifiers?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- requires_placeholder_type_specifiers-3F-source -->
            
          </div>

          

          
        </div><!-- requires_placeholder_type_specifiers-3F-method -->

      
        <div id="requires_sql_standard_datetimes-3F-method" class="method-detail ">
          <a name="method-i-requires_sql_standard_datetimes-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">requires_sql_standard_datetimes?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset requires <a href="SQL.html">SQL</a> standard datetimes
(false by default, as most allow strings with ISO 8601 format).</p>
            

            
            <div class="method-source-code" id="requires_sql_standard_datetimes-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">requires_sql_standard_datetimes?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- requires_sql_standard_datetimes-3F-source -->
            
          </div>

          

          
        </div><!-- requires_sql_standard_datetimes-3F-method -->

      
        <div id="supports_cte-3F-method" class="method-detail ">
          <a name="method-i-supports_cte-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_cte?</span><span
              class="method-args">(type=:select)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports common table expressions (the WITH clause). If
given, <tt>type</tt> can be :select, :insert, :update, or :delete, in which
case it determines whether WITH is supported for the respective statement
type.</p>
            

            
            <div class="method-source-code" id="supports_cte-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_cte?</span>(<span class="ruby-identifier">type</span>=<span class="ruby-value">:select</span>)
  <span class="ruby-identifier">send</span>(<span class="ruby-value">:&quot;#{type}_clause_methods&quot;</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-value">:&quot;#{type}_with_sql&quot;</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_cte-3F-source -->
            
          </div>

          

          
        </div><!-- supports_cte-3F-method -->

      
        <div id="supports_cte_in_subqueries-3F-method" class="method-detail ">
          <a name="method-i-supports_cte_in_subqueries-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_cte_in_subqueries?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports common table expressions (the WITH clause) in
subqueries.  If false, applies the WITH clause to the main query, which can
cause issues if multiple WITH clauses use the same name.</p>
            

            
            <div class="method-source-code" id="supports_cte_in_subqueries-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_cte_in_subqueries?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_cte_in_subqueries-3F-source -->
            
          </div>

          

          
        </div><!-- supports_cte_in_subqueries-3F-method -->

      
        <div id="supports_distinct_on-3F-method" class="method-detail ">
          <a name="method-i-supports_distinct_on-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_distinct_on?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports or can emulate the <a
href="Dataset.html#DISTINCT">DISTINCT</a> <a href="Dataset.html#ON">ON</a>
clause, false by default.</p>
            

            
            <div class="method-source-code" id="supports_distinct_on-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_distinct_on?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_distinct_on-3F-source -->
            
          </div>

          

          
        </div><!-- supports_distinct_on-3F-method -->

      
        <div id="supports_group_cube-3F-method" class="method-detail ">
          <a name="method-i-supports_group_cube-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_group_cube?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports CUBE with GROUP BY.</p>
            

            
            <div class="method-source-code" id="supports_group_cube-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_group_cube?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_group_cube-3F-source -->
            
          </div>

          

          
        </div><!-- supports_group_cube-3F-method -->

      
        <div id="supports_group_rollup-3F-method" class="method-detail ">
          <a name="method-i-supports_group_rollup-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_group_rollup?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports ROLLUP with GROUP BY.</p>
            

            
            <div class="method-source-code" id="supports_group_rollup-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_group_rollup?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_group_rollup-3F-source -->
            
          </div>

          

          
        </div><!-- supports_group_rollup-3F-method -->

      
        <div id="supports_insert_select-3F-method" class="method-detail ">
          <a name="method-i-supports_insert_select-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_insert_select?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether this dataset supports the <tt>insert_select</tt> method for
returning all columns values directly from an insert query.</p>
            

            
            <div class="method-source-code" id="supports_insert_select-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_insert_select?</span>
  <span class="ruby-identifier">supports_returning?</span>(<span class="ruby-value">:insert</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_insert_select-3F-source -->
            
          </div>

          

          
        </div><!-- supports_insert_select-3F-method -->

      
        <div id="supports_intersect_except-3F-method" class="method-detail ">
          <a name="method-i-supports_intersect_except-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_intersect_except?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports the INTERSECT and EXCEPT compound operations,
true by default.</p>
            

            
            <div class="method-source-code" id="supports_intersect_except-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_intersect_except?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_intersect_except-3F-source -->
            
          </div>

          

          
        </div><!-- supports_intersect_except-3F-method -->

      
        <div id="supports_intersect_except_all-3F-method" class="method-detail ">
          <a name="method-i-supports_intersect_except_all-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_intersect_except_all?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports the INTERSECT <a
href="Dataset.html#ALL">ALL</a> and EXCEPT <a
href="Dataset.html#ALL">ALL</a> compound operations, true by default.</p>
            

            
            <div class="method-source-code" id="supports_intersect_except_all-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_intersect_except_all?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_intersect_except_all-3F-source -->
            
          </div>

          

          
        </div><!-- supports_intersect_except_all-3F-method -->

      
        <div id="supports_is_true-3F-method" class="method-detail ">
          <a name="method-i-supports_is_true-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_is_true?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports the IS TRUE syntax.</p>
            

            
            <div class="method-source-code" id="supports_is_true-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_is_true?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_is_true-3F-source -->
            
          </div>

          

          
        </div><!-- supports_is_true-3F-method -->

      
        <div id="supports_join_using-3F-method" class="method-detail ">
          <a name="method-i-supports_join_using-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_join_using?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports the JOIN table <a
href="Dataset.html#USING">USING</a> (column1, ...) syntax.</p>
            

            
            <div class="method-source-code" id="supports_join_using-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_join_using?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_join_using-3F-source -->
            
          </div>

          

          
        </div><!-- supports_join_using-3F-method -->

      
        <div id="supports_modifying_joins-3F-method" class="method-detail ">
          <a name="method-i-supports_modifying_joins-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_modifying_joins?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether modifying joined datasets is supported.</p>
            

            
            <div class="method-source-code" id="supports_modifying_joins-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_modifying_joins?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_modifying_joins-3F-source -->
            
          </div>

          

          
        </div><!-- supports_modifying_joins-3F-method -->

      
        <div id="supports_multiple_column_in-3F-method" class="method-detail ">
          <a name="method-i-supports_multiple_column_in-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_multiple_column_in?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the IN/NOT IN operators support multiple columns when an array of
values is given.</p>
            

            
            <div class="method-source-code" id="supports_multiple_column_in-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_multiple_column_in?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_multiple_column_in-3F-source -->
            
          </div>

          

          
        </div><!-- supports_multiple_column_in-3F-method -->

      
        <div id="supports_ordered_distinct_on-3F-method" class="method-detail ">
          <a name="method-i-supports_ordered_distinct_on-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_ordered_distinct_on?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports or can fully emulate the <a
href="Dataset.html#DISTINCT">DISTINCT</a> <a href="Dataset.html#ON">ON</a>
clause, including respecting the ORDER BY clause, false by default</p>
            

            
            <div class="method-source-code" id="supports_ordered_distinct_on-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_ordered_distinct_on?</span>
  <span class="ruby-identifier">supports_distinct_on?</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_ordered_distinct_on-3F-source -->
            
          </div>

          

          
        </div><!-- supports_ordered_distinct_on-3F-method -->

      
        <div id="supports_regexp-3F-method" class="method-detail ">
          <a name="method-i-supports_regexp-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_regexp?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports pattern matching by regular expressions.</p>
            

            
            <div class="method-source-code" id="supports_regexp-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_regexp?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_regexp-3F-source -->
            
          </div>

          

          
        </div><!-- supports_regexp-3F-method -->

      
        <div id="supports_returning-3F-method" class="method-detail ">
          <a name="method-i-supports_returning-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_returning?</span><span
              class="method-args">(type)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the <a href="Dataset.html#RETURNING">RETURNING</a> clause is
supported for the given type of query. <tt>type</tt> can be :insert,
:update, or :delete.</p>
            

            
            <div class="method-source-code" id="supports_returning-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_returning?</span>(<span class="ruby-identifier">type</span>)
  <span class="ruby-identifier">send</span>(<span class="ruby-value">:&quot;#{type}_clause_methods&quot;</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-value">:&quot;#{type}_returning_sql&quot;</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_returning-3F-source -->
            
          </div>

          

          
        </div><!-- supports_returning-3F-method -->

      
        <div id="supports_select_all_and_column-3F-method" class="method-detail ">
          <a name="method-i-supports_select_all_and_column-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_select_all_and_column?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the database supports <a href="Dataset.html#SELECT">SELECT</a> *,
column <a href="Dataset.html#FROM">FROM</a> table</p>
            

            
            <div class="method-source-code" id="supports_select_all_and_column-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_select_all_and_column?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_select_all_and_column-3F-source -->
            
          </div>

          

          
        </div><!-- supports_select_all_and_column-3F-method -->

      
        <div id="supports_timestamp_timezones-3F-method" class="method-detail ">
          <a name="method-i-supports_timestamp_timezones-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_timestamp_timezones?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports timezones in literal timestamps</p>
            

            
            <div class="method-source-code" id="supports_timestamp_timezones-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_timestamp_timezones?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_timestamp_timezones-3F-source -->
            
          </div>

          

          
        </div><!-- supports_timestamp_timezones-3F-method -->

      
        <div id="supports_timestamp_usecs-3F-method" class="method-detail ">
          <a name="method-i-supports_timestamp_usecs-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_timestamp_usecs?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports fractional seconds in literal timestamps</p>
            

            
            <div class="method-source-code" id="supports_timestamp_usecs-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_timestamp_usecs?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_timestamp_usecs-3F-source -->
            
          </div>

          

          
        </div><!-- supports_timestamp_usecs-3F-method -->

      
        <div id="supports_where_true-3F-method" class="method-detail ">
          <a name="method-i-supports_where_true-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_where_true?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports <a href="Dataset.html#WHERE">WHERE</a> TRUE
(or <a href="Dataset.html#WHERE">WHERE</a> 1 for databases that that use 1
for true).</p>
            

            
            <div class="method-source-code" id="supports_where_true-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_where_true?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_where_true-3F-source -->
            
          </div>

          

          
        </div><!-- supports_where_true-3F-method -->

      
        <div id="supports_window_functions-3F-method" class="method-detail ">
          <a name="method-i-supports_window_functions-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">supports_window_functions?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Whether the dataset supports window functions.</p>
            

            
            <div class="method-source-code" id="supports_window_functions-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/features.rb, line 144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">supports_window_functions?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- supports_window_functions-3F-source -->
            
          </div>

          

          
        </div><!-- supports_window_functions-3F-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 4+-+Methods+that+describe+what+the+dataset+supports -->
  
    
    
    <div id="5+-+Methods+related+to+dataset+graphing" class="documentation-section">
      
      <h2 class="section-header">
        5 - Methods related to dataset graphing
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p><a href="Dataset.html">Dataset</a> graphing changes the dataset to yield
hashes where keys are table name symbols and values are hashes representing
the columns related to that table.  All of these methods return modified
copies of the receiver.</p>

      </div>
      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="add_graph_aliases-method" class="method-detail ">
          <a name="method-i-add_graph_aliases"></a>

          
          <div class="method-heading">
            <span class="method-name">add_graph_aliases</span><span
              class="method-args">(graph_aliases)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds the given graph aliases to the list of graph aliases to use, unlike
<tt>set_graph_aliases</tt>, which replaces the list (the equivalent of
<tt>select_more</tt> when graphing).  See <tt>set_graph_aliases</tt>.</p>

<pre>DB[:table].add_graph_aliases(:some_alias=&gt;[:table, :column])
# SELECT ..., table.column AS some_alias
# =&gt; {:table=&gt;{:column=&gt;some_alias_value, ...}, ...}</pre>
            

            
            <div class="method-source-code" id="add_graph_aliases-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/graph.rb, line 17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_graph_aliases</span>(<span class="ruby-identifier">graph_aliases</span>)
  <span class="ruby-identifier">columns</span>, <span class="ruby-identifier">graph_aliases</span> = <span class="ruby-identifier">graph_alias_columns</span>(<span class="ruby-identifier">graph_aliases</span>)
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">select_more</span>(*<span class="ruby-identifier">columns</span>)
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph_aliases</span>] = (<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph_aliases</span>] <span class="ruby-operator">||</span> (<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph</span>][<span class="ruby-value">:column_aliases</span>] <span class="ruby-keyword">rescue</span> {}) <span class="ruby-operator">||</span> {}).<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">graph_aliases</span>)
  <span class="ruby-identifier">ds</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- add_graph_aliases-source -->
            
          </div>

          

          
        </div><!-- add_graph_aliases-method -->

      
        <div id="graph-method" class="method-detail ">
          <a name="method-i-graph"></a>

          
          <div class="method-heading">
            <span class="method-name">graph</span><span
              class="method-args">(dataset, join_conditions = nil, options = {}, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Allows you to join multiple datasets/tables and have the result set split
into component tables.</p>

<p>This differs from the usual usage of join, which returns the result set as
a single hash.  For example:</p>

<pre># CREATE TABLE artists (id INTEGER, name TEXT);
# CREATE TABLE albums (id INTEGER, name TEXT, artist_id INTEGER);

DB[:artists].left_outer_join(:albums, :artist_id=&gt;:id).first
#=&gt; {:id=&gt;albums.id, :name=&gt;albums.name, :artist_id=&gt;albums.artist_id}

DB[:artists].graph(:albums, :artist_id=&gt;:id).first
#=&gt; {:artists=&gt;{:id=&gt;artists.id, :name=&gt;artists.name}, :albums=&gt;{:id=&gt;albums.id, :name=&gt;albums.name, :artist_id=&gt;albums.artist_id}}</pre>

<p>Using a join such as left_outer_join, the attribute names that are shared
between the tables are combined in the single return hash.  You can get
around that by using <tt>select</tt> with correct aliases for all of the
columns, but it is simpler to use <tt>graph</tt> and have the result set
split for you.  In addition, <tt>graph</tt> respects any <tt>row_proc</tt>
of the current dataset and the datasets you use with <tt>graph</tt>.</p>

<p>If you are graphing a table and all columns for that table are nil, this
indicates that no matching rows existed in the table, so graph will return
nil instead of a hash with all nil values:</p>

<pre># If the artist doesn't have any albums
DB[:artists].graph(:albums, :artist_id=&gt;:id).first
=&gt; {:artists=&gt;{:id=&gt;artists.id, :name=&gt;artists.name}, :albums=&gt;nil}</pre>

<p>Arguments:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>dataset </p></td>
<td>
<p>Can be a symbol (specifying a table), another dataset, or an object that
responds to <tt>dataset</tt> and returns a symbol or a dataset</p>
</td></tr><tr><td class="rdoc-term"><p>join_conditions </p></td>
<td>
<p>Any condition(s) allowed by <tt>join_table</tt>.</p>
</td></tr><tr><td class="rdoc-term"><p>block </p></td>
<td>
<p>A block that is passed to <tt>join_table</tt>.</p>
</td></tr></table>

<p>Options:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>:from_self_alias </p></td>
<td>
<p>The alias to use when the receiver is not a graphed dataset but it contains
multiple <a href="Dataset.html#FROM">FROM</a> tables or a JOIN.  In this
case, the receiver is wrapped in a <a
href="Dataset.html#method-i-from_self">from_self</a> before graphing, and
this option determines the alias to use.</p>
</td></tr><tr><td class="rdoc-term"><p>:implicit_qualifier </p></td>
<td>
<p>The qualifier of implicit conditions, see <a
href="Dataset.html#method-i-join_table">join_table</a>.</p>
</td></tr><tr><td class="rdoc-term"><p>:join_type </p></td>
<td>
<p>The type of join to use (passed to <tt>join_table</tt>).  Defaults to
:left_outer.</p>
</td></tr><tr><td class="rdoc-term"><p>:qualify</p></td>
<td>
<p>The type of qualification to do, see <a
href="Dataset.html#method-i-join_table">join_table</a>.</p>
</td></tr><tr><td class="rdoc-term"><p>:select </p></td>
<td>
<p>An array of columns to select.  When not used, selects all columns in the
given dataset.  When set to false, selects no columns and is like simply
joining the tables, though graph keeps some metadata about the join that
makes it important to use <tt>graph</tt> instead of <tt>join_table</tt>.</p>
</td></tr><tr><td class="rdoc-term"><p>:table_alias </p></td>
<td>
<p>The alias to use for the table.  If not specified, doesn't alias the table.
You will get an error if the the alias (or table) name is used more than
once.</p>
</td></tr></table>
            

            
            <div class="method-source-code" id="graph-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/graph.rb, line 75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">graph</span>(<span class="ruby-identifier">dataset</span>, <span class="ruby-identifier">join_conditions</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">options</span> = {}, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-comment"># Allow the use of a dataset or symbol as the first argument</span>
  <span class="ruby-comment"># Find the table name/dataset based on the argument</span>
  <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:table_alias</span>]
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">dataset</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">table</span> = <span class="ruby-identifier">dataset</span>
    <span class="ruby-identifier">dataset</span> = <span class="ruby-ivar">@db</span>[<span class="ruby-identifier">dataset</span>]
    <span class="ruby-identifier">table_alias</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">table</span>
  <span class="ruby-keyword">when</span> <span class="ruby-operator">::</span><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Dataset</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">simple_select_all?</span>
      <span class="ruby-identifier">table</span> = <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:from</span>].<span class="ruby-identifier">first</span>
      <span class="ruby-identifier">table_alias</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">table</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">table</span> = <span class="ruby-identifier">dataset</span>
      <span class="ruby-identifier">table_alias</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">dataset_alias</span>((<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:num_dataset_sources</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0</span>)<span class="ruby-operator">+</span><span class="ruby-value">1</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;The dataset argument should be a symbol or dataset&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Raise Sequel::Error with explanation that the table alias has been used</span>
  <span class="ruby-identifier">raise_alias_error</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;this #{options[:table_alias] ? 'alias' : 'table'} has already been been used, please specify &quot;</span>            <span class="ruby-node">&quot;#{options[:table_alias] ? 'a different alias' : 'an alias via the :table_alias option'}&quot;</span>) 
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Only allow table aliases that haven't been used</span>
  <span class="ruby-identifier">raise_alias_error</span>.<span class="ruby-identifier">call</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:graph</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:graph</span>][<span class="ruby-value">:table_aliases</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:graph</span>][<span class="ruby-value">:table_aliases</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">table_alias</span>)
  
  <span class="ruby-comment"># Use a from_self if this is already a joined table</span>
  <span class="ruby-identifier">ds</span> = (<span class="ruby-operator">!</span><span class="ruby-ivar">@opts</span>[<span class="ruby-value">:graph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:from</span>].<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:join</span>])) <span class="ruby-operator">?</span> <span class="ruby-identifier">from_self</span>(<span class="ruby-value">:alias</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:from_self_alias</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">first_source</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
  
  <span class="ruby-comment"># Join the table early in order to avoid cloning the dataset twice</span>
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">join_table</span>(<span class="ruby-identifier">options</span>[<span class="ruby-value">:join_type</span>] <span class="ruby-operator">||</span> <span class="ruby-value">:left_outer</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">join_conditions</span>, <span class="ruby-value">:table_alias=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">table_alias</span>, <span class="ruby-value">:implicit_qualifier=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:implicit_qualifier</span>], <span class="ruby-value">:qualify=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:qualify</span>], &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>

  <span class="ruby-comment"># Whether to include the table in the result set</span>
  <span class="ruby-identifier">add_table</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
  <span class="ruby-comment"># Whether to add the columns to the list of column aliases</span>
  <span class="ruby-identifier">add_columns</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:graph_aliases</span>)

  <span class="ruby-comment"># Setup the initial graph data structure if it doesn't exist</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">graph</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph</span>]
    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph</span>] = <span class="ruby-identifier">graph</span> = <span class="ruby-identifier">graph</span>.<span class="ruby-identifier">dup</span>
    <span class="ruby-identifier">select</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:select</span>].<span class="ruby-identifier">dup</span>
    [<span class="ruby-value">:column_aliases</span>, <span class="ruby-value">:table_aliases</span>, <span class="ruby-value">:column_alias_num</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">graph</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">graph</span>[<span class="ruby-identifier">k</span>].<span class="ruby-identifier">dup</span>}
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">master</span> = <span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">first_source_alias</span>)
    <span class="ruby-identifier">raise_alias_error</span>.<span class="ruby-identifier">call</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">master</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">table_alias</span>
    <span class="ruby-comment"># Master hash storing all .graph related information</span>
    <span class="ruby-identifier">graph</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph</span>] = {}
    <span class="ruby-comment"># Associates column aliases back to tables and columns</span>
    <span class="ruby-identifier">column_aliases</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:column_aliases</span>] = {}
    <span class="ruby-comment"># Associates table alias (the master is never aliased)</span>
    <span class="ruby-identifier">table_aliases</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:table_aliases</span>] = {<span class="ruby-identifier">master</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>}
    <span class="ruby-comment"># Keep track of the alias numbers used</span>
    <span class="ruby-identifier">ca_num</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:column_alias_num</span>] = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">0</span>)
    <span class="ruby-comment"># All columns in the master table are never</span>
    <span class="ruby-comment"># aliased, but are not included if set_graph_aliases</span>
    <span class="ruby-comment"># has been used.</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">add_columns</span>
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">select</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:select</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">select</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">select</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">select</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ColumnAll</span>)))
        <span class="ruby-identifier">select</span> = <span class="ruby-identifier">select</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sel</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">column</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">sel</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
            <span class="ruby-identifier">_</span>, <span class="ruby-identifier">c</span>, <span class="ruby-identifier">a</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">sel</span>)
            (<span class="ruby-identifier">a</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">c</span>).<span class="ruby-identifier">to_sym</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>
            <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_sym</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">column</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-identifier">column</span>.<span class="ruby-identifier">value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>)
            <span class="ruby-identifier">column</span>.<span class="ruby-identifier">to_sym</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">aliaz</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-identifier">column</span>.<span class="ruby-identifier">value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">column</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>)
            <span class="ruby-identifier">column</span>.<span class="ruby-identifier">to_sym</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;can't figure out alias to use for graphing for #{sel.inspect}&quot;</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">column_aliases</span>[<span class="ruby-identifier">column</span>] = [<span class="ruby-identifier">master</span>, <span class="ruby-identifier">column</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">select</span> = <span class="ruby-identifier">qualified_expression</span>(<span class="ruby-identifier">select</span>, <span class="ruby-identifier">master</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">select</span> = <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">column</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">column_aliases</span>[<span class="ruby-identifier">column</span>] = [<span class="ruby-identifier">master</span>, <span class="ruby-identifier">column</span>]
          <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">master</span>, <span class="ruby-identifier">column</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Add the table alias to the list of aliases</span>
  <span class="ruby-comment"># Even if it isn't been used in the result set,</span>
  <span class="ruby-comment"># we add a key for it with a nil value so we can check if it</span>
  <span class="ruby-comment"># is used more than once</span>
  <span class="ruby-identifier">table_aliases</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:table_aliases</span>]
  <span class="ruby-identifier">table_aliases</span>[<span class="ruby-identifier">table_alias</span>] = <span class="ruby-identifier">add_table</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">dataset</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>

  <span class="ruby-comment"># Add the columns to the selection unless we are ignoring them</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">add_table</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">add_columns</span>
    <span class="ruby-identifier">column_aliases</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:column_aliases</span>]
    <span class="ruby-identifier">ca_num</span> = <span class="ruby-identifier">graph</span>[<span class="ruby-value">:column_alias_num</span>]
    <span class="ruby-comment"># Which columns to add to the result set</span>
    <span class="ruby-identifier">cols</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">columns</span>
    <span class="ruby-comment"># If the column hasn't been used yet, don't alias it.</span>
    <span class="ruby-comment"># If it has been used, try table_column.</span>
    <span class="ruby-comment"># If that has been used, try table_column_N </span>
    <span class="ruby-comment"># using the next value of N that we know hasn't been</span>
    <span class="ruby-comment"># used</span>
    <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">column</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">col_alias</span>, <span class="ruby-identifier">identifier</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">column_aliases</span>[<span class="ruby-identifier">column</span>]
        <span class="ruby-identifier">column_alias</span> = <span class="ruby-value">:&quot;#{table_alias}_#{column}&quot;</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">column_aliases</span>[<span class="ruby-identifier">column_alias</span>]
          <span class="ruby-identifier">column_alias_num</span> = <span class="ruby-identifier">ca_num</span>[<span class="ruby-identifier">column_alias</span>]
          <span class="ruby-identifier">column_alias</span> = <span class="ruby-value">:&quot;#{column_alias}_#{column_alias_num}&quot;</span> 
          <span class="ruby-identifier">ca_num</span>[<span class="ruby-identifier">column_alias</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
        [<span class="ruby-identifier">column_alias</span>, <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table_alias</span>, <span class="ruby-identifier">column</span>), <span class="ruby-identifier">column_alias</span>)]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">ident</span> = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table_alias</span>, <span class="ruby-identifier">column</span>)
        [<span class="ruby-identifier">column</span>, <span class="ruby-identifier">ident</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">column_aliases</span>[<span class="ruby-identifier">col_alias</span>] = [<span class="ruby-identifier">table_alias</span>, <span class="ruby-identifier">column</span>]
      <span class="ruby-identifier">select</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">identifier</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">add_columns</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>(*<span class="ruby-identifier">select</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- graph-source -->
            
          </div>

          

          
        </div><!-- graph-method -->

      
        <div id="set_graph_aliases-method" class="method-detail ">
          <a name="method-i-set_graph_aliases"></a>

          
          <div class="method-heading">
            <span class="method-name">set_graph_aliases</span><span
              class="method-args">(graph_aliases)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This allows you to manually specify the graph aliases to use when using
graph.  You can use it to only select certain columns, and have those
columns mapped to specific aliases in the result set.  This is the
equivalent of <tt>select</tt> for a graphed dataset, and must be used
instead of <tt>select</tt> whenever graphing is used.</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>graph_aliases </p></td>
<td>
<p>Should be a hash with keys being symbols of column aliases, and values
being either symbols or arrays with one to three elements. If the value is
a symbol, it is assumed to be the same as a one element array containing
that symbol. The first element of the array should be the table alias
symbol. The second should be the actual column name symbol.  If the array
only has a single element the column name symbol will be assumed to be the
same as the corresponding hash key. If the array has a third element, it is
used as the value returned, instead of table_alias.column_name.</p>
</td></tr></table>

<pre>DB[:artists].graph(:albums, :artist_id=&gt;:id).
  set_graph_aliases(:name=&gt;:artists,
                    :album_name=&gt;[:albums, :name],
                    :forty_two=&gt;[:albums, :fourtwo, 42]).first
# SELECT artists.name, albums.name AS album_name, 42 AS forty_two ...
# =&gt; {:artists=&gt;{:name=&gt;artists.name}, :albums=&gt;{:name=&gt;albums.name, :fourtwo=&gt;42}}</pre>
            

            
            <div class="method-source-code" id="set_graph_aliases-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/graph.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_graph_aliases</span>(<span class="ruby-identifier">graph_aliases</span>)
  <span class="ruby-identifier">columns</span>, <span class="ruby-identifier">graph_aliases</span> = <span class="ruby-identifier">graph_alias_columns</span>(<span class="ruby-identifier">graph_aliases</span>)
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">columns</span>)
  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:graph_aliases</span>] = <span class="ruby-identifier">graph_aliases</span>
  <span class="ruby-identifier">ds</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_graph_aliases-source -->
            
          </div>

          

          
        </div><!-- set_graph_aliases-method -->

      
        <div id="ungraphed-method" class="method-detail ">
          <a name="method-i-ungraphed"></a>

          
          <div class="method-heading">
            <span class="method-name">ungraphed</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Remove the splitting of results into subhashes, and all metadata related to
the current graph (if any).</p>
            

            
            <div class="method-source-code" id="ungraphed-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/graph.rb, line 239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ungraphed</span>
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:graph=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, <span class="ruby-value">:graph_aliases=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- ungraphed-source -->
            
          </div>

          

          
        </div><!-- ungraphed-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5+-+Methods+related+to+dataset+graphing -->
  
    
    
    <div id="6+-+Miscellaneous+methods" class="documentation-section">
      
      <h2 class="section-header">
        6 - Miscellaneous methods
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods don't fit cleanly into another section.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="ARG_BLOCK_ERROR_MSG">ARG_BLOCK_ERROR_MSG</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ARRAY_ACCESS_ERROR_MSG">ARRAY_ACCESS_ERROR_MSG</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="IMPORT_ERROR_MSG">IMPORT_ERROR_MSG</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="NOTIMPL_MSG">NOTIMPL_MSG</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="db-attribute-method" class="method-detail">
          <a name="db"></a>
          
          <a name="db="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">db</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>The database related to this dataset.  This is the <a
href="Database.html">Database</a> instance that will execute all of this
dataset's queries.</p>
          
          </div>
        </div>
        
        <div id="opts-attribute-method" class="method-detail">
          <a name="opts"></a>
          
          <a name="opts="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">opts</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>The hash of options for this dataset, keys are symbols.</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">(db, opts = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Constructs a new <a href="Dataset.html">Dataset</a> instance with an
associated database and  options. Datasets are usually constructed by
invoking the Database#[] method:</p>

<pre>DB[:posts]</pre>

<p><a href="Dataset.html">Sequel::Dataset</a> is an abstract class that is not
useful by itself. Each database adapter provides a subclass of <a
href="Dataset.html">Sequel::Dataset</a>, and has the <a
href="Database.html#method-i-dataset">Database#dataset</a> method return an
instance of that subclass.</p>
            

            
            <div class="method-source-code" id="new-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">db</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-ivar">@db</span> = <span class="ruby-identifier">db</span>
  <span class="ruby-ivar">@opts</span> = <span class="ruby-identifier">opts</span> <span class="ruby-operator">||</span> {}
<span class="ruby-keyword">end</span></pre>
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">==</span><span
              class="method-args">(o)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Define a hash value such that datasets with the same DB, opts, and <a
href="SQL.html">SQL</a> will be considered equal.</p>
            

            
            <div class="method-source-code" id="3D-3D-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 35</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">==</span>(<span class="ruby-identifier">o</span>)
  <span class="ruby-identifier">o</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">db</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">db</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">opts</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">opts</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sql</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sql</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->

      
        <div id="each_server-method" class="method-detail ">
          <a name="method-i-each_server"></a>

          
          <div class="method-heading">
            <span class="method-name">each_server</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Yield a dataset for each server in the connection pool that is tied to that
server. Intended for use in sharded environments where all servers need to
be modified with the same data:</p>

<pre>DB[:configs].where(:key=&gt;'setting').each_server{|ds| ds.update(:value=&gt;'new_value')}</pre>
            

            
            <div class="method-source-code" id="each_server-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_server</span>
  <span class="ruby-identifier">db</span>.<span class="ruby-identifier">servers</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">server</span>(<span class="ruby-identifier">s</span>)}
<span class="ruby-keyword">end</span></pre>
            </div><!-- each_server-source -->
            
          </div>

          

          
        </div><!-- each_server-method -->

      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">eql?</span><span
              class="method-args">(o)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias for ==</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">o</span>)
  <span class="ruby-keyword">self</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">o</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->

      
        <div id="first_source-method" class="method-detail ">
          <a name="method-i-first_source"></a>

          
          <div class="method-heading">
            <span class="method-name">first_source</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Alias of <tt>first_source_alias</tt></p>
            

            
            <div class="method-source-code" id="first_source-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">first_source</span>
  <span class="ruby-identifier">first_source_alias</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- first_source-source -->
            
          </div>

          

          
        </div><!-- first_source-method -->

      
        <div id="first_source_alias-method" class="method-detail ">
          <a name="method-i-first_source_alias"></a>

          
          <div class="method-heading">
            <span class="method-name">first_source_alias</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The first source (primary table) for this dataset.  If the dataset doesn't
have a table, raises an <tt>Error</tt>.  If the table is aliased, returns
the aliased name.</p>

<pre>DB[:table].first_source_alias
# =&gt; :table

DB[:table___t].first_source_alias
# =&gt; :t</pre>
            

            
            <div class="method-source-code" id="first_source_alias-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">first_source_alias</span>
  <span class="ruby-identifier">source</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:from</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">'No source specified for query'</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">s</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>
    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">aliaz</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">aliaz</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">s</span>)
    <span class="ruby-identifier">aliaz</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">aliaz</span>.<span class="ruby-identifier">to_sym</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- first_source_alias-source -->
            
          </div>

          

          
        </div><!-- first_source_alias-method -->

      
        <div id="first_source_table-method" class="method-detail ">
          <a name="method-i-first_source_table"></a>

          
          <div class="method-heading">
            <span class="method-name">first_source_table</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The first source (primary table) for this dataset.  If the dataset doesn't
have a table, raises an error.  If the table is aliased, returns the
original table, not the alias</p>

<pre>DB[:table].first_source_table
# =&gt; :table

DB[:table___t].first_source_table
# =&gt; :table</pre>
            

            
            <div class="method-source-code" id="first_source_table-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">first_source_table</span>
  <span class="ruby-identifier">source</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:from</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">'No source specified for query'</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">s</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>
    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">expression</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">aliaz</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">s</span>)
    <span class="ruby-identifier">aliaz</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">sch</span> <span class="ruby-operator">?</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">table</span>.<span class="ruby-identifier">to_sym</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- first_source_table-source -->
            
          </div>

          

          
        </div><!-- first_source_table-method -->

      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          <div class="method-heading">
            <span class="method-name">hash</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Define a hash value such that datasets with the same DB, opts, and <a
href="SQL.html">SQL</a> will have the same hash value</p>
            

            
            <div class="method-source-code" id="hash-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hash</span>
  [<span class="ruby-identifier">db</span>, <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">sort_by</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">to_s</span>}, <span class="ruby-identifier">sql</span>].<span class="ruby-identifier">hash</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->

      
        <div id="identifier_input_method-method" class="method-detail ">
          <a name="method-i-identifier_input_method"></a>

          
          <div class="method-heading">
            <span class="method-name">identifier_input_method</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The <a href="../String.html">String</a> instance method to call on
identifiers before sending them to the database.</p>
            

            
            <div class="method-source-code" id="identifier_input_method-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">identifier_input_method</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@identifier_input_method</span>)
    <span class="ruby-ivar">@identifier_input_method</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">db</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:identifier_input_method</span>)
    <span class="ruby-ivar">@identifier_input_method</span> = <span class="ruby-identifier">db</span>.<span class="ruby-identifier">identifier_input_method</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@identifier_input_method</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- identifier_input_method-source -->
            
          </div>

          

          
        </div><!-- identifier_input_method-method -->

      
        <div id="identifier_output_method-method" class="method-detail ">
          <a name="method-i-identifier_output_method"></a>

          
          <div class="method-heading">
            <span class="method-name">identifier_output_method</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The <a href="../String.html">String</a> instance method to call on
identifiers before sending them to the database.</p>
            

            
            <div class="method-source-code" id="identifier_output_method-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">identifier_output_method</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@identifier_output_method</span>)
    <span class="ruby-ivar">@identifier_output_method</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">db</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:identifier_output_method</span>)
    <span class="ruby-ivar">@identifier_output_method</span> = <span class="ruby-identifier">db</span>.<span class="ruby-identifier">identifier_output_method</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@identifier_output_method</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- identifier_output_method-source -->
            
          </div>

          

          
        </div><!-- identifier_output_method-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a string representation of the dataset including the class name 
and the corresponding <a href="SQL.html">SQL</a> select statement.</p>
            

            
            <div class="method-source-code" id="inspect-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inspect</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">superclass</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-string">''</span>
  <span class="ruby-node">&quot;#&lt;#{c.name}: #{sql.inspect}&gt;&quot;</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->

      
        <div id="row_number_column-method" class="method-detail ">
          <a name="method-i-row_number_column"></a>

          
          <div class="method-heading">
            <span class="method-name">row_number_column</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The alias to use for the row_number column, used when emulating <a
href="Dataset.html#OFFSET">OFFSET</a> support and for eager limit
strategies</p>
            

            
            <div class="method-source-code" id="row_number_column-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">row_number_column</span>
  <span class="ruby-value">:x_sequel_row_number_x</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- row_number_column-source -->
            
          </div>

          

          
        </div><!-- row_number_column-method -->

      
        <div id="split_alias-method" class="method-detail ">
          <a name="method-i-split_alias"></a>

          
          <div class="method-heading">
            <span class="method-name">split_alias</span><span
              class="method-args">(c)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Splits a possible implicit alias in <tt>c</tt>, handling both
SQL::AliasedExpressions and Symbols.  Returns an array of two elements,
with the first being the main expression, and the second being the alias.</p>
            

            
            <div class="method-source-code" id="split_alias-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">split_alias</span>(<span class="ruby-identifier">c</span>)
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">c</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">c_table</span>, <span class="ruby-identifier">column</span>, <span class="ruby-identifier">aliaz</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">c</span>)
    [<span class="ruby-identifier">c_table</span> <span class="ruby-operator">?</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">c_table</span>, <span class="ruby-identifier">column</span>.<span class="ruby-identifier">to_sym</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">column</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-identifier">aliaz</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>
    [<span class="ruby-identifier">c</span>.<span class="ruby-identifier">expression</span>, <span class="ruby-identifier">c</span>.<span class="ruby-identifier">aliaz</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">JoinClause</span>
    [<span class="ruby-identifier">c</span>.<span class="ruby-identifier">table</span>, <span class="ruby-identifier">c</span>.<span class="ruby-identifier">table_alias</span>]
  <span class="ruby-keyword">else</span>
    [<span class="ruby-identifier">c</span>, <span class="ruby-keyword">nil</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- split_alias-source -->
            
          </div>

          

          
        </div><!-- split_alias-method -->

      
        <div id="unused_table_alias-method" class="method-detail ">
          <a name="method-i-unused_table_alias"></a>

          
          <div class="method-heading">
            <span class="method-name">unused_table_alias</span><span
              class="method-args">(table_alias, used_aliases = [])</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates a unique table alias that hasn't already been used in the dataset.
table_alias can be any type of object accepted by alias_symbol. The symbol
returned will be the implicit alias in the argument, possibly appended with
"_N" if the implicit alias has already been used, where N is an integer
starting at 0 and increasing until an unused one is found.</p>

<p>You can provide a second addition array argument containing symbols that
should not be considered valid table aliases.  The current aliases for the
<a href="Dataset.html#FROM">FROM</a> and JOIN tables are automatically
included in this array.</p>

<pre>DB[:table].unused_table_alias(:t)
# =&gt; :t

DB[:table].unused_table_alias(:table)
# =&gt; :table_0

DB[:table, :table_0].unused_table_alias(:table)
# =&gt; :table_1

DB[:table, :table_0].unused_table_alias(:table, [:table_1, :table_2])
# =&gt; :table_3</pre>
            

            
            <div class="method-source-code" id="unused_table_alias-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/misc.rb, line 190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unused_table_alias</span>(<span class="ruby-identifier">table_alias</span>, <span class="ruby-identifier">used_aliases</span> = [])
  <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">table_alias</span>)
  <span class="ruby-identifier">used_aliases</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:from</span>].<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">t</span>)} <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:from</span>]
  <span class="ruby-identifier">used_aliases</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:join</span>].<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">j</span>.<span class="ruby-identifier">table_alias</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">alias_alias_symbol</span>(<span class="ruby-identifier">j</span>.<span class="ruby-identifier">table_alias</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">j</span>.<span class="ruby-identifier">table</span>)} <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:join</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">used_aliases</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">table_alias</span>)
    <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">ta</span> = <span class="ruby-value">:&quot;#{table_alias}_#{i}&quot;</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">ta</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">used_aliases</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">ta</span>)
      <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> 
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">table_alias</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- unused_table_alias-source -->
            
          </div>

          

          
        </div><!-- unused_table_alias-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 6+-+Miscellaneous+methods -->
  
    
    
    <div id="7+-+Mutation+methods" class="documentation-section">
      
      <h2 class="section-header">
        7 - Mutation methods
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods modify the receiving dataset and should be used with care.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="MUTATION_METHODS">MUTATION_METHODS</a></dt>
          
          <dd class="description"><p>All methods that should have a ! method added that modifies the receiver.</p></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="identifier_input_method-attribute-method" class="method-detail">
          <a name="identifier_input_method"></a>
          
          <a name="identifier_input_method="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">identifier_input_method</span><span
              class="attribute-access-type">[W]</span>
          </div>

          <div class="method-description">
          
          <p>Set the method to call on identifiers going into the database for this
dataset</p>
          
          </div>
        </div>
        
        <div id="identifier_output_method-attribute-method" class="method-detail">
          <a name="identifier_output_method"></a>
          
          <a name="identifier_output_method="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">identifier_output_method</span><span
              class="attribute-access-type">[W]</span>
          </div>

          <div class="method-description">
          
          <p>Set the method to call on identifiers coming the database for this dataset</p>
          
          </div>
        </div>
        
        <div id="quote_identifiers-attribute-method" class="method-detail">
          <a name="quote_identifiers"></a>
          
          <a name="quote_identifiers="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">quote_identifiers</span><span
              class="attribute-access-type">[W]</span>
          </div>

          <div class="method-description">
          
          <p>Whether to quote identifiers for this dataset</p>
          
          </div>
        </div>
        
        <div id="row_proc-attribute-method" class="method-detail">
          <a name="row_proc"></a>
          
          <a name="row_proc="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">row_proc</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>The <a href="Dataset.html#attribute-i-row_proc">row_proc</a> for this
database, should be any object that responds to <tt>call</tt> with a single
hash argument and returns the object you want <a
href="Dataset.html#method-i-each">each</a> to return.</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="def_mutation_method-method" class="method-detail ">
          <a name="method-c-def_mutation_method"></a>

          
          <div class="method-heading">
            <span class="method-name">def_mutation_method</span><span
              class="method-args">(*meths)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Setup mutation (e.g. filter!) methods.  These operate the same as the non-!
methods, but replace the options of the current dataset with the options of
the resulting dataset.</p>
            

            
            <div class="method-source-code" id="def_mutation_method-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/mutation.rb, line 14</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">def_mutation_method</span>(*<span class="ruby-identifier">meths</span>)
  <span class="ruby-identifier">meths</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">meth</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">class_eval</span>(<span class="ruby-node">&quot;def #{meth}!(*args, &amp;block); mutation_method(:#{meth}, *args, &amp;block) end&quot;</span>, <span class="ruby-keyword">__FILE__</span>, <span class="ruby-keyword">__LINE__</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- def_mutation_method-source -->
            
          </div>

          

          
        </div><!-- def_mutation_method-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="def_mutation_method-method" class="method-detail ">
          <a name="method-i-def_mutation_method"></a>

          
          <div class="method-heading">
            <span class="method-name">def_mutation_method</span><span
              class="method-args">(*meths)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Add a mutation method to this dataset instance.</p>
            

            
            <div class="method-source-code" id="def_mutation_method-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/mutation.rb, line 37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">def_mutation_method</span>(*<span class="ruby-identifier">meths</span>)
  <span class="ruby-identifier">meths</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">meth</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">instance_eval</span>(<span class="ruby-node">&quot;def #{meth}!(*args, &amp;block); mutation_method(:#{meth}, *args, &amp;block) end&quot;</span>, <span class="ruby-keyword">__FILE__</span>, <span class="ruby-keyword">__LINE__</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- def_mutation_method-source -->
            
          </div>

          

          
        </div><!-- def_mutation_method-method -->

      
        <div id="naked-21-method" class="method-detail ">
          <a name="method-i-naked-21"></a>

          
          <div class="method-heading">
            <span class="method-name">naked!</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Remove the <a href="Dataset.html#attribute-i-row_proc">row_proc</a> from
the current dataset.</p>
            

            
            <div class="method-source-code" id="naked-21-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/mutation.rb, line 44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">naked!</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">row_proc</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- naked-21-source -->
            
          </div>

          

          
        </div><!-- naked-21-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 7+-+Mutation+methods -->
  
    
    
    <div id="8+-+Methods+related+to+prepared+statements+or+bound+variables" class="documentation-section">
      
      <h2 class="section-header">
        8 - Methods related to prepared statements or bound variables
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>On some adapters, these use native prepared statements and bound variables,
on others support is emulated.  For details, see the <a
href="../files/doc/prepared_statements_rdoc.html">"Prepared
Statements/Bound Variables" guide</a>.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="PREPARED_ARG_PLACEHOLDER">PREPARED_ARG_PLACEHOLDER</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="bind-method" class="method-detail ">
          <a name="method-i-bind"></a>

          
          <div class="method-heading">
            <span class="method-name">bind</span><span
              class="method-args">(bind_vars={})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set the bind variables to use for the call.  If bind variables have already
been set for this dataset, they are updated with the contents of bind_vars.</p>

<pre>DB[:table].filter(:id=&gt;:$id).bind(:id=&gt;1).call(:first)
# SELECT * FROM table WHERE id = ? LIMIT 1 -- (1)
# =&gt; {:id=&gt;1}</pre>
            

            
            <div class="method-source-code" id="bind-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/prepared_statements.rb, line 217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">bind</span>(<span class="ruby-identifier">bind_vars</span>={})
  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:bind_vars=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@opts</span>[<span class="ruby-value">:bind_vars</span>] <span class="ruby-operator">?</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:bind_vars</span>].<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">bind_vars</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">bind_vars</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- bind-source -->
            
          </div>

          

          
        </div><!-- bind-method -->

      
        <div id="call-method" class="method-detail ">
          <a name="method-i-call"></a>

          
          <div class="method-heading">
            <span class="method-name">call</span><span
              class="method-args">(type, bind_variables={}, *values, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>For the given type (:select, :first, :insert, :insert_select, :update, or
:delete), run the sql with the bind variables specified in the hash. 
<tt>values</tt> is a hash passed to insert or update (if one of those types
is used), which may contain placeholders.</p>

<pre>DB[:table].filter(:id=&gt;:$id).call(:first, :id=&gt;1)
# SELECT * FROM table WHERE id = ? LIMIT 1 -- (1)
# =&gt; {:id=&gt;1}</pre>
            

            
            <div class="method-source-code" id="call-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/prepared_statements.rb, line 228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">call</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">bind_variables</span>={}, *<span class="ruby-identifier">values</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">prepare</span>(<span class="ruby-identifier">type</span>, <span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">values</span>).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">bind_variables</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- call-source -->
            
          </div>

          

          
        </div><!-- call-method -->

      
        <div id="prepare-method" class="method-detail ">
          <a name="method-i-prepare"></a>

          
          <div class="method-heading">
            <span class="method-name">prepare</span><span
              class="method-args">(type, name=nil, *values)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Prepare an <a href="SQL.html">SQL</a> statement for later execution.  Takes
a type similar to <a href="Dataset.html#method-i-call">call</a>, and the
<tt>name</tt> symbol of the prepared statement.  While <tt>name</tt>
defaults to <tt>nil</tt>, it should always be provided as a symbol for the
name of the prepared statement, as some databases require that prepared
statements have names.</p>

<p>This returns a clone of the dataset extended with <a
href="Dataset/PreparedStatementMethods.html">PreparedStatementMethods</a>,
which you can <tt>call</tt> with the hash of bind variables to use. The
prepared statement is also stored in the associated database, where it can
be called by name. The following usage is identical:</p>

<pre>ps = DB[:table].filter(:name=&gt;:$name).prepare(:first, :select_by_name)

ps.call(:name=&gt;'Blah')
# SELECT * FROM table WHERE name = ? -- ('Blah')
# =&gt; {:id=&gt;1, :name=&gt;'Blah'}

DB.call(:select_by_name, :name=&gt;'Blah') # Same thing</pre>
            

            
            <div class="method-source-code" id="prepare-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/prepared_statements.rb, line 250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">prepare</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">name</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">values</span>)
  <span class="ruby-identifier">ps</span> = <span class="ruby-identifier">to_prepared_statement</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">values</span>)
  <span class="ruby-identifier">db</span>.<span class="ruby-identifier">set_prepared_statement</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ps</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>
  <span class="ruby-identifier">ps</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- prepare-source -->
            
          </div>

          

          
        </div><!-- prepare-method -->

      
      </div><!-- public-instance-method-details -->
    
      <div id="protected-instance-method-details" class="method-section section">
        <h3 class="section-header">Protected Instance Methods</h3>

      
        <div id="to_prepared_statement-method" class="method-detail ">
          <a name="method-i-to_prepared_statement"></a>

          
          <div class="method-heading">
            <span class="method-name">to_prepared_statement</span><span
              class="method-args">(type, values=nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a cloned copy of the current dataset extended with <a
href="Dataset/PreparedStatementMethods.html">PreparedStatementMethods</a>,
setting the type and modify values.</p>
            

            
            <div class="method-source-code" id="to_prepared_statement-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/prepared_statements.rb, line 260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_prepared_statement</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">values</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">ps</span> = <span class="ruby-identifier">bind</span>
  <span class="ruby-identifier">ps</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">PreparedStatementMethods</span>)
  <span class="ruby-identifier">ps</span>.<span class="ruby-identifier">orig_dataset</span> = <span class="ruby-keyword">self</span>
  <span class="ruby-identifier">ps</span>.<span class="ruby-identifier">prepared_type</span> = <span class="ruby-identifier">type</span>
  <span class="ruby-identifier">ps</span>.<span class="ruby-identifier">prepared_modify_values</span> = <span class="ruby-identifier">values</span>
  <span class="ruby-identifier">ps</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_prepared_statement-source -->
            
          </div>

          

          
        </div><!-- to_prepared_statement-method -->

      
      </div><!-- protected-instance-method-details -->
    
    </div><!-- 8+-+Methods+related+to+prepared+statements+or+bound+variables -->
  
    
    
    <div id="9+-+Internal+Methods+relating+to+SQL+Creation" class="documentation-section">
      
      <h2 class="section-header">
        9 - Internal Methods relating to SQL Creation
        <a href="#top">&uarr; top</a>
      </h2>
      

      
      <div class="description">
        
<p>These methods, while public, are not designed to be used directly by the
end user.</p>

      </div>
      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="ALL">ALL</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="AND_SEPARATOR">AND_SEPARATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="APOS">APOS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="APOS_RE">APOS_RE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ARRAY_EMPTY">ARRAY_EMPTY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="AS">AS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ASC">ASC</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="BOOL_FALSE">BOOL_FALSE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="BOOL_TRUE">BOOL_TRUE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="BRACKET_CLOSE">BRACKET_CLOSE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="BRACKET_OPEN">BRACKET_OPEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CASE_ELSE">CASE_ELSE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CASE_END">CASE_END</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CASE_OPEN">CASE_OPEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CASE_THEN">CASE_THEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CASE_WHEN">CASE_WHEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CAST_OPEN">CAST_OPEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COLUMN_REF_RE1">COLUMN_REF_RE1</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COLUMN_REF_RE2">COLUMN_REF_RE2</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COLUMN_REF_RE3">COLUMN_REF_RE3</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COMMA">COMMA</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COMMA_SEPARATOR">COMMA_SEPARATOR</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CONDITION_FALSE">CONDITION_FALSE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="CONDITION_TRUE">CONDITION_TRUE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COUNT_FROM_SELF_OPTS">COUNT_FROM_SELF_OPTS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="COUNT_OF_ALL_AS_COUNT">COUNT_OF_ALL_AS_COUNT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DATASET_ALIAS_BASE_NAME">DATASET_ALIAS_BASE_NAME</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DEFAULT">DEFAULT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DEFAULT_VALUES">DEFAULT_VALUES</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DELETE">DELETE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DELETE_CLAUSE_METHODS">DELETE_CLAUSE_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DESC">DESC</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DISTINCT">DISTINCT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DOT">DOT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DOUBLE_APOS">DOUBLE_APOS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="DOUBLE_QUOTE">DOUBLE_QUOTE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="EMULATED_FUNCTION_MAP">EMULATED_FUNCTION_MAP</a></dt>
          
          <dd class="description"><p>Map of emulated function names to native function names.</p></dd>
          
        
          <dt><a name="EQUAL">EQUAL</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="EXISTS">EXISTS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="EXTRACT">EXTRACT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_DATE">FORMAT_DATE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_DATE_STANDARD">FORMAT_DATE_STANDARD</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_OFFSET">FORMAT_OFFSET</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_TIMESTAMP_RE">FORMAT_TIMESTAMP_RE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_TIMESTAMP_USEC">FORMAT_TIMESTAMP_USEC</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FORMAT_USEC">FORMAT_USEC</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FOR_UPDATE">FOR_UPDATE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FRAME_ALL">FRAME_ALL</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FRAME_ROWS">FRAME_ROWS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FROM">FROM</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="FUNCTION_EMPTY">FUNCTION_EMPTY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="GROUP_BY">GROUP_BY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="HAVING">HAVING</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="INSERT">INSERT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="INSERT_CLAUSE_METHODS">INSERT_CLAUSE_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="INTO">INTO</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="IS_LITERALS">IS_LITERALS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="IS_OPERATORS">IS_OPERATORS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="LIMIT">LIMIT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="NOT_SPACE">NOT_SPACE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="NULL">NULL</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="NULLS_FIRST">NULLS_FIRST</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="NULLS_LAST">NULLS_LAST</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="N_ARITY_OPERATORS">N_ARITY_OPERATORS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="OFFSET">OFFSET</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ON">ON</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ON_PAREN">ON_PAREN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ORDER_BY">ORDER_BY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="ORDER_BY_NS">ORDER_BY_NS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="OVER">OVER</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PAREN_CLOSE">PAREN_CLOSE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PAREN_OPEN">PAREN_OPEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PAREN_SPACE_OPEN">PAREN_SPACE_OPEN</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PARTITION_BY">PARTITION_BY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PRIVATE_APPEND_METHODS">PRIVATE_APPEND_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="PUBLIC_APPEND_METHODS">PUBLIC_APPEND_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="QUALIFY_KEYS">QUALIFY_KEYS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="QUESTION_MARK">QUESTION_MARK</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="QUESTION_MARK_RE">QUESTION_MARK_RE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="QUOTE">QUOTE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="QUOTE_RE">QUOTE_RE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="REGEXP_OPERATORS">REGEXP_OPERATORS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="RETURNING">RETURNING</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SELECT">SELECT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SELECT_CLAUSE_METHODS">SELECT_CLAUSE_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SET">SET</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SPACE">SPACE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SPACE_WITH">SPACE_WITH</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SQL_WITH">SQL_WITH</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="STANDARD_TIMESTAMP_FORMAT">STANDARD_TIMESTAMP_FORMAT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="TILDE">TILDE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="TIMESTAMP_FORMAT">TIMESTAMP_FORMAT</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="TWO_ARITY_OPERATORS">TWO_ARITY_OPERATORS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UNDERSCORE">UNDERSCORE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UPDATE">UPDATE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="UPDATE_CLAUSE_METHODS">UPDATE_CLAUSE_METHODS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="USING">USING</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="V190">V190</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="VALUES">VALUES</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="WHERE">WHERE</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="WILDCARD">WILDCARD</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="clause_methods-method" class="method-detail ">
          <a name="method-c-clause_methods"></a>

          
          <div class="method-heading">
            <span class="method-name">clause_methods</span><span
              class="method-args">(type, clauses)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Given a type (e.g. select) and an array of clauses, return an array of
methods to call to build the <a href="SQL.html">SQL</a> string.</p>
            

            
            <div class="method-source-code" id="clause_methods-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 177</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clause_methods</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">clauses</span>)
  <span class="ruby-identifier">clauses</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">clause</span><span class="ruby-operator">|</span> <span class="ruby-value">:&quot;#{type}_#{clause}_sql&quot;</span>}.<span class="ruby-identifier">freeze</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- clause_methods-source -->
            
          </div>

          

          
        </div><!-- clause_methods-method -->

      
        <div id="def_append_methods-method" class="method-detail ">
          <a name="method-c-def_append_methods"></a>

          
          <div class="method-heading">
            <span class="method-name">def_append_methods</span><span
              class="method-args">(meths)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="def_append_methods-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 326</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">def_append_methods</span>(<span class="ruby-identifier">meths</span>)
  <span class="ruby-identifier">meths</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">meth</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">class_eval</span>(<span class="ruby-string">          def #{meth}(*args, &amp;block)            s = ''            #{meth}_append(s, *args, &amp;block)            s          end</span>, <span class="ruby-keyword">__FILE__</span>, <span class="ruby-keyword">__LINE__</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- def_append_methods-source -->
            
          </div>

          

          
        </div><!-- def_append_methods-method -->

      
        <div id="introspect_all_columns-method" class="method-detail ">
          <a name="method-c-introspect_all_columns"></a>

          
          <div class="method-heading">
            <span class="method-name">introspect_all_columns</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Enable column introspection for every dataset.</p>
            

            
            <div class="method-source-code" id="introspect_all_columns-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/columns_introspection.rb, line 64</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">introspect_all_columns</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">ColumnsIntrospection</span>
  <span class="ruby-identifier">remove_method</span>(<span class="ruby-value">:columns</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">instance_methods</span>(<span class="ruby-keyword">false</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_s</span>}.<span class="ruby-identifier">include?</span>(<span class="ruby-string">'columns'</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- introspect_all_columns-source -->
            
          </div>

          

          
        </div><!-- introspect_all_columns-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="aliased_expression_sql_append-method" class="method-detail ">
          <a name="method-i-aliased_expression_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">aliased_expression_sql_append</span><span
              class="method-args">(sql, ae)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for AliasedExpression</p>
            

            
            <div class="method-source-code" id="aliased_expression_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">aliased_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ae</span>)
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ae</span>.<span class="ruby-identifier">expression</span>)
  <span class="ruby-identifier">as_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ae</span>.<span class="ruby-identifier">aliaz</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- aliased_expression_sql_append-source -->
            
          </div>

          

          
        </div><!-- aliased_expression_sql_append-method -->

      
        <div id="array_sql_append-method" class="method-detail ">
          <a name="method-i-array_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">array_sql_append</span><span
              class="method-args">(sql, a)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for <a href="../Array.html">Array</a></p>
            

            
            <div class="method-source-code" id="array_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 347</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">array_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">a</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">ARRAY_EMPTY</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
    <span class="ruby-identifier">expression_list_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">a</span>)
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- array_sql_append-source -->
            
          </div>

          

          
        </div><!-- array_sql_append-method -->

      
        <div id="boolean_constant_sql_append-method" class="method-detail ">
          <a name="method-i-boolean_constant_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">boolean_constant_sql_append</span><span
              class="method-args">(sql, constant)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for BooleanConstants</p>
            

            
            <div class="method-source-code" id="boolean_constant_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">boolean_constant_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">constant</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">constant</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">constant</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_where_true?</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">constant</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">?</span> <span class="ruby-constant">CONDITION_TRUE</span> <span class="ruby-operator">:</span> <span class="ruby-constant">CONDITION_FALSE</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">constant</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- boolean_constant_sql_append-source -->
            
          </div>

          

          
        </div><!-- boolean_constant_sql_append-method -->

      
        <div id="case_expression_sql_append-method" class="method-detail ">
          <a name="method-i-case_expression_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">case_expression_sql_append</span><span
              class="method-args">(sql, ce)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for CaseExpression</p>
            

            
            <div class="method-source-code" id="case_expression_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 367</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">case_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ce</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">CASE_OPEN</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">ce</span>.<span class="ruby-identifier">expression?</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ce</span>.<span class="ruby-identifier">expression</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">w</span> = <span class="ruby-constant">CASE_WHEN</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-constant">CASE_THEN</span>
  <span class="ruby-identifier">ce</span>.<span class="ruby-identifier">conditions</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span>,<span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">w</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">c</span>)
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">t</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">r</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">CASE_ELSE</span>
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ce</span>.<span class="ruby-identifier">default</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">CASE_END</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- case_expression_sql_append-source -->
            
          </div>

          

          
        </div><!-- case_expression_sql_append-method -->

      
        <div id="cast_sql_append-method" class="method-detail ">
          <a name="method-i-cast_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">cast_sql_append</span><span
              class="method-args">(sql, expr, type)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for the <a href="SQL.html">SQL</a> CAST
expression</p>
            

            
            <div class="method-source-code" id="cast_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 387</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cast_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">type</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">CAST_OPEN</span>
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">expr</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">AS</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">db</span>.<span class="ruby-identifier">cast_type_literal</span>(<span class="ruby-identifier">type</span>).<span class="ruby-identifier">to_s</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- cast_sql_append-source -->
            
          </div>

          

          
        </div><!-- cast_sql_append-method -->

      
        <div id="column_all_sql_append-method" class="method-detail ">
          <a name="method-i-column_all_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">column_all_sql_append</span><span
              class="method-args">(sql, ca)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for specifying all columns in a given
table</p>
            

            
            <div class="method-source-code" id="column_all_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">column_all_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ca</span>)
  <span class="ruby-identifier">qualified_identifier_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">ca</span>.<span class="ruby-identifier">table</span>, <span class="ruby-constant">WILDCARD</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- column_all_sql_append-source -->
            
          </div>

          

          
        </div><!-- column_all_sql_append-method -->

      
        <div id="columns_without_introspection-method" class="method-detail method-alias">
          <a name="method-i-columns_without_introspection"></a>

          
          <div class="method-heading">
            <span class="method-name">columns_without_introspection</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Dataset.html#method-i-columns">columns</a>
          </div>
          
        </div><!-- columns_without_introspection-method -->

      
        <div id="complex_expression_sql_append-method" class="method-detail ">
          <a name="method-i-complex_expression_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">complex_expression_sql_append</span><span
              class="method-args">(sql, op, args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for the complex expression.</p>
            

            
            <div class="method-source-code" id="complex_expression_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">op</span>, <span class="ruby-identifier">args</span>)
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">op</span>
  <span class="ruby-keyword">when</span> *<span class="ruby-constant">IS_OPERATORS</span>
    <span class="ruby-identifier">r</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">supports_is_true?</span>
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-string">'Invalid argument used for IS operator'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">v</span> = <span class="ruby-constant">IS_LITERALS</span>[<span class="ruby-identifier">r</span>]
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>))
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">op</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:IS</span>
      <span class="ruby-identifier">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-value">:&quot;=&quot;</span>, <span class="ruby-identifier">args</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-value">:OR</span>, [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:&quot;!=&quot;</span>, *<span class="ruby-identifier">args</span>), <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:IS</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>), <span class="ruby-keyword">nil</span>)])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:IN</span>, <span class="ruby-value">:&quot;NOT IN&quot;</span>
    <span class="ruby-identifier">cols</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)
    <span class="ruby-identifier">vals</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>)
    <span class="ruby-identifier">col_array</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
      <span class="ruby-identifier">val_array</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">empty_val_array</span> = <span class="ruby-identifier">vals</span> <span class="ruby-operator">==</span> []
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">empty_val_array</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">empty_array_value</span>(<span class="ruby-identifier">op</span>, <span class="ruby-identifier">cols</span>))
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">col_array</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_multiple_column_in?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">val_array</span>
          <span class="ruby-identifier">expr</span> = <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:OR</span>, *<span class="ruby-identifier">vals</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">vs</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">BooleanExpression</span>.<span class="ruby-identifier">from_value_pairs</span>(<span class="ruby-identifier">cols</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">vs</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">c</span>, <span class="ruby-identifier">v</span>]})})
          <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:IN</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">expr</span> <span class="ruby-operator">:</span> <span class="ruby-operator">~</span><span class="ruby-identifier">expr</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">old_vals</span> = <span class="ruby-identifier">vals</span>
          <span class="ruby-identifier">vals</span> = <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">naked</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Dataset</span>)
          <span class="ruby-identifier">vals</span> = <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">to_a</span>
          <span class="ruby-identifier">val_cols</span> = <span class="ruby-identifier">old_vals</span>.<span class="ruby-identifier">columns</span>
          <span class="ruby-identifier">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">op</span>, [<span class="ruby-identifier">cols</span>, <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">map!</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">values_at</span>(*<span class="ruby-identifier">val_cols</span>)}])
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># If the columns and values are both arrays, use array_sql instead of</span>
        <span class="ruby-comment"># literal so that if values is an array of two element arrays, it</span>
        <span class="ruby-comment"># will be treated as a value list instead of a condition specifier.</span>
        <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
        <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">cols</span>)
        <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">op</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">val_array</span>
          <span class="ruby-identifier">array_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">vals</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">vals</span>)
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">cols</span>)
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">op</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">vals</span>)
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> *<span class="ruby-constant">TWO_ARITY_OPERATORS</span>
    <span class="ruby-keyword">if</span> <span class="ruby-constant">REGEXP_OPERATORS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">op</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">supports_regexp?</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">InvalidOperation</span>, <span class="ruby-node">&quot;Pattern matching via regular expressions is not supported on #{db.database_type}&quot;</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>))
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">op</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>))
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
  <span class="ruby-keyword">when</span> *<span class="ruby-constant">N_ARITY_OPERATORS</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">op_str</span> = <span class="ruby-node">&quot; #{op} &quot;</span>
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">op_str</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">a</span>)
      <span class="ruby-identifier">c</span> <span class="ruby-operator">||=</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:NOT</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NOT_SPACE</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>))
  <span class="ruby-keyword">when</span> <span class="ruby-value">:NOOP</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>))
  <span class="ruby-keyword">when</span> <span class="ruby-value">:'B~'</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">TILDE</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>))
  <span class="ruby-keyword">when</span> <span class="ruby-value">:extract</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">EXTRACT</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">FROM</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>))
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">InvalidOperation</span>, <span class="ruby-node">&quot;invalid operator #{op}&quot;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- complex_expression_sql_append-source -->
            
          </div>

          

          
        </div><!-- complex_expression_sql_append-method -->

      
        <div id="constant_sql_append-method" class="method-detail ">
          <a name="method-i-constant_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">constant_sql_append</span><span
              class="method-args">(sql, constant)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for constants</p>
            

            
            <div class="method-source-code" id="constant_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 495</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">constant_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">constant</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">constant</span>.<span class="ruby-identifier">to_s</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- constant_sql_append-source -->
            
          </div>

          

          
        </div><!-- constant_sql_append-method -->

      
        <div id="delayed_evaluation_sql_append-method" class="method-detail ">
          <a name="method-i-delayed_evaluation_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">delayed_evaluation_sql_append</span><span
              class="method-args">(sql, callable)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for delayed evaluations, evaluating the
object and literalizing the returned value.</p>
            

            
            <div class="method-source-code" id="delayed_evaluation_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 501</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delayed_evaluation_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">callable</span>)
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">callable</span>.<span class="ruby-identifier">call</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- delayed_evaluation_sql_append-source -->
            
          </div>

          

          
        </div><!-- delayed_evaluation_sql_append-method -->

      
        <div id="each_page-method" class="method-detail ">
          <a name="method-i-each_page"></a>

          
          <div class="method-heading">
            <span class="method-name">each_page</span><span
              class="method-args">(page_size)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Yields a paginated dataset for each page and returns the receiver. Does a
count to find the total number of records for this dataset.</p>
            

            
            <div class="method-source-code" id="each_page-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/pagination.rb, line 24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_page</span>(<span class="ruby-identifier">page_size</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;You cannot paginate a dataset that already has a limit&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:limit</span>]
  <span class="ruby-identifier">record_count</span> = <span class="ruby-identifier">count</span>
  <span class="ruby-identifier">total_pages</span> = (<span class="ruby-identifier">record_count</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">page_size</span>.<span class="ruby-identifier">to_f</span>).<span class="ruby-identifier">ceil</span>
  (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">total_pages</span>).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">page_no</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">paginate</span>(<span class="ruby-identifier">page_no</span>, <span class="ruby-identifier">page_size</span>, <span class="ruby-identifier">record_count</span>)}
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- each_page-source -->
            
          </div>

          

          
        </div><!-- each_page-method -->

      
        <div id="emulated_function_sql_append-method" class="method-detail ">
          <a name="method-i-emulated_function_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">emulated_function_sql_append</span><span
              class="method-args">(sql, f)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment specifying an emulated <a
href="SQL.html">SQL</a> function call. By default, assumes just the
function name may need to be emulated, adapters should set an <a
href="Dataset.html#EMULATED_FUNCTION_MAP">EMULATED_FUNCTION_MAP</a> hash
mapping emulated functions to native functions in their dataset class to
setup the emulation.</p>
            

            
            <div class="method-source-code" id="emulated_function_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 510</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">emulated_function_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">f</span>)
  <span class="ruby-identifier">_function_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">native_function_name</span>(<span class="ruby-identifier">f</span>.<span class="ruby-identifier">f</span>), <span class="ruby-identifier">f</span>.<span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- emulated_function_sql_append-source -->
            
          </div>

          

          
        </div><!-- emulated_function_sql_append-method -->

      
        <div id="function_sql_append-method" class="method-detail ">
          <a name="method-i-function_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">function_sql_append</span><span
              class="method-args">(sql, f)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment specifying an <a
href="SQL.html">SQL</a> function call without emulation.</p>
            

            
            <div class="method-source-code" id="function_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">function_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">f</span>)
  <span class="ruby-identifier">_function_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">f</span>.<span class="ruby-identifier">f</span>, <span class="ruby-identifier">f</span>.<span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- function_sql_append-source -->
            
          </div>

          

          
        </div><!-- function_sql_append-method -->

      
        <div id="join_clause_sql_append-method" class="method-detail ">
          <a name="method-i-join_clause_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">join_clause_sql_append</span><span
              class="method-args">(sql, jc)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment specifying a JOIN clause without <a
href="Dataset.html#ON">ON</a> or <a href="Dataset.html#USING">USING</a>.</p>
            

            
            <div class="method-source-code" id="join_clause_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">join_clause_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>)
  <span class="ruby-identifier">table</span> = <span class="ruby-identifier">jc</span>.<span class="ruby-identifier">table</span>
  <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">jc</span>.<span class="ruby-identifier">table_alias</span>
  <span class="ruby-identifier">table_alias</span> = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">table</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">table_alias</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">join_type_sql</span>(<span class="ruby-identifier">jc</span>.<span class="ruby-identifier">join_type</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">SPACE</span>
  <span class="ruby-identifier">identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table</span>)
  <span class="ruby-identifier">as_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table_alias</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">table_alias</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- join_clause_sql_append-source -->
            
          </div>

          

          
        </div><!-- join_clause_sql_append-method -->

      
        <div id="join_on_clause_sql_append-method" class="method-detail ">
          <a name="method-i-join_on_clause_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">join_on_clause_sql_append</span><span
              class="method-args">(sql, jc)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment specifying a JOIN clause with <a
href="Dataset.html#ON">ON</a>.</p>
            

            
            <div class="method-source-code" id="join_on_clause_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 530</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">join_on_clause_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>)
  <span class="ruby-identifier">join_clause_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">ON</span>
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">filter_expr</span>(<span class="ruby-identifier">jc</span>.<span class="ruby-identifier">on</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- join_on_clause_sql_append-source -->
            
          </div>

          

          
        </div><!-- join_on_clause_sql_append-method -->

      
        <div id="join_using_clause_sql_append-method" class="method-detail ">
          <a name="method-i-join_using_clause_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">join_using_clause_sql_append</span><span
              class="method-args">(sql, jc)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment specifying a JOIN clause with <a
href="Dataset.html#USING">USING</a>.</p>
            

            
            <div class="method-source-code" id="join_using_clause_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 537</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">join_using_clause_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>)
  <span class="ruby-identifier">join_clause_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">USING</span>
  <span class="ruby-identifier">column_list_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">jc</span>.<span class="ruby-identifier">using</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- join_using_clause_sql_append-source -->
            
          </div>

          

          
        </div><!-- join_using_clause_sql_append-method -->

      
        <div id="negative_boolean_constant_sql_append-method" class="method-detail ">
          <a name="method-i-negative_boolean_constant_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">negative_boolean_constant_sql_append</span><span
              class="method-args">(sql, constant)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for NegativeBooleanConstants</p>
            

            
            <div class="method-source-code" id="negative_boolean_constant_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 545</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">negative_boolean_constant_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">constant</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NOT_SPACE</span>
  <span class="ruby-identifier">boolean_constant_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">constant</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- negative_boolean_constant_sql_append-source -->
            
          </div>

          

          
        </div><!-- negative_boolean_constant_sql_append-method -->

      
        <div id="nullify-method" class="method-detail ">
          <a name="method-i-nullify"></a>

          
          <div class="method-heading">
            <span class="method-name">nullify</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a cloned nullified dataset.</p>
            

            
            <div class="method-source-code" id="nullify-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/null_dataset.rb, line 85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nullify</span>
  <span class="ruby-identifier">clone</span>.<span class="ruby-identifier">nullify!</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- nullify-source -->
            
          </div>

          

          
        </div><!-- nullify-method -->

      
        <div id="nullify-21-method" class="method-detail ">
          <a name="method-i-nullify-21"></a>

          
          <div class="method-heading">
            <span class="method-name">nullify!</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Nullify the current dataset</p>
            

            
            <div class="method-source-code" id="nullify-21-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/null_dataset.rb, line 90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nullify!</span>
  <span class="ruby-identifier">extend</span> <span class="ruby-constant">NullDataset</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- nullify-21-source -->
            
          </div>

          

          
        </div><!-- nullify-21-method -->

      
        <div id="ordered_expression_sql_append-method" class="method-detail ">
          <a name="method-i-ordered_expression_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">ordered_expression_sql_append</span><span
              class="method-args">(sql, oe)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for the ordered expression, used in the
ORDER BY clause.</p>
            

            
            <div class="method-source-code" id="ordered_expression_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 552</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ordered_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">oe</span>)
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">oe</span>.<span class="ruby-identifier">expression</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">oe</span>.<span class="ruby-identifier">descending</span> <span class="ruby-operator">?</span> <span class="ruby-constant">DESC</span> <span class="ruby-operator">:</span> <span class="ruby-constant">ASC</span>)
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">oe</span>.<span class="ruby-identifier">nulls</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:first</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NULLS_FIRST</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:last</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NULLS_LAST</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- ordered_expression_sql_append-source -->
            
          </div>

          

          
        </div><!-- ordered_expression_sql_append-method -->

      
        <div id="paginate-method" class="method-detail ">
          <a name="method-i-paginate"></a>

          
          <div class="method-heading">
            <span class="method-name">paginate</span><span
              class="method-args">(page_no, page_size, record_count=nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a paginated dataset. The returned dataset is limited to the page
size at the correct offset, and extended with the <a
href="Dataset/Pagination.html">Pagination</a> module.  If a record count is
not provided, does a count of total number of records for this dataset.</p>
            

            
            <div class="method-source-code" id="paginate-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/pagination.rb, line 15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">paginate</span>(<span class="ruby-identifier">page_no</span>, <span class="ruby-identifier">page_size</span>, <span class="ruby-identifier">record_count</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;You cannot paginate a dataset that already has a limit&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:limit</span>]
  <span class="ruby-identifier">paginated</span> = <span class="ruby-identifier">limit</span>(<span class="ruby-identifier">page_size</span>, (<span class="ruby-identifier">page_no</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) * <span class="ruby-identifier">page_size</span>)
  <span class="ruby-identifier">paginated</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Pagination</span>)
  <span class="ruby-identifier">paginated</span>.<span class="ruby-identifier">set_pagination_info</span>(<span class="ruby-identifier">page_no</span>, <span class="ruby-identifier">page_size</span>, <span class="ruby-identifier">record_count</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">count</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- paginate-source -->
            
          </div>

          

          
        </div><!-- paginate-method -->

      
        <div id="placeholder_literal_string_sql_append-method" class="method-detail ">
          <a name="method-i-placeholder_literal_string_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">placeholder_literal_string_sql_append</span><span
              class="method-args">(sql, pls)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for a literal string with placeholders</p>
            

            
            <div class="method-source-code" id="placeholder_literal_string_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 564</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">placeholder_literal_string_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">pls</span>)
  <span class="ruby-identifier">args</span> = <span class="ruby-identifier">pls</span>.<span class="ruby-identifier">args</span>
  <span class="ruby-identifier">str</span> = <span class="ruby-identifier">pls</span>.<span class="ruby-identifier">str</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">pls</span>.<span class="ruby-identifier">parens</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
    <span class="ruby-identifier">re</span> = <span class="ruby-node">/:(#{args.keys.map{|k| Regexp.escape(k.to_s)}.join('|')})\b/</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">previous</span>, <span class="ruby-identifier">q</span>, <span class="ruby-identifier">str</span> = <span class="ruby-identifier">str</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-identifier">re</span>)
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">previous</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>[(<span class="ruby-node">$1</span><span class="ruby-operator">||</span><span class="ruby-identifier">q</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">to_s</span>).<span class="ruby-identifier">to_sym</span>]) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-identifier">len</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span>
    <span class="ruby-identifier">str</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>[<span class="ruby-identifier">i</span>]) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">len</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">i</span> = <span class="ruby-value">-1</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">previous</span>, <span class="ruby-identifier">q</span>, <span class="ruby-identifier">str</span> = <span class="ruby-identifier">str</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-constant">QUESTION_MARK</span>)
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">previous</span>
       <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">+=</span><span class="ruby-value">1</span>)) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">pls</span>.<span class="ruby-identifier">parens</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- placeholder_literal_string_sql_append-source -->
            
          </div>

          

          
        </div><!-- placeholder_literal_string_sql_append-method -->

      
        <div id="print-method" class="method-detail ">
          <a name="method-i-print"></a>

          
          <div class="method-heading">
            <span class="method-name">print</span><span
              class="method-args">(*cols)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Pretty prints the records in the dataset as plain-text table.</p>
            

            
            <div class="method-source-code" id="print-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/pretty_table.rb, line 21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">print</span>(*<span class="ruby-identifier">cols</span>)
  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">naked</span>
  <span class="ruby-identifier">rows</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">all</span>
  <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">PrettyTable</span>.<span class="ruby-identifier">print</span>(<span class="ruby-identifier">rows</span>, <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">columns</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">cols</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- print-source -->
            
          </div>

          

          
        </div><!-- print-method -->

      
        <div id="qualified_identifier_sql_append-method" class="method-detail ">
          <a name="method-i-qualified_identifier_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">qualified_identifier_sql_append</span><span
              class="method-args">(sql, table, column=(c = table.column; table = table.table; c))</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for the qualifed identifier, specifying
a table and a column (or schema and table). If 3 arguments are given, the
2nd should be the table/qualifier and the third should be column/qualified.
If 2 arguments are given, the 2nd should be an <a
href="SQL/QualifiedIdentifier.html">SQL::QualifiedIdentifier</a>.</p>
            

            
            <div class="method-source-code" id="qualified_identifier_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 598</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">qualified_identifier_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">column</span>=(<span class="ruby-identifier">c</span> = <span class="ruby-identifier">table</span>.<span class="ruby-identifier">column</span>; <span class="ruby-identifier">table</span> = <span class="ruby-identifier">table</span>.<span class="ruby-identifier">table</span>; <span class="ruby-identifier">c</span>))
  <span class="ruby-identifier">identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">DOT</span>
  <span class="ruby-identifier">identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">column</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- qualified_identifier_sql_append-source -->
            
          </div>

          

          
        </div><!-- qualified_identifier_sql_append-method -->

      
        <div id="query-method" class="method-detail ">
          <a name="method-i-query"></a>

          
          <div class="method-heading">
            <span class="method-name">query</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Translates a query block into a dataset. Query blocks can be useful when
expressing complex <a href="Dataset.html#SELECT">SELECT</a> statements,
e.g.:</p>

<pre>dataset = DB[:items].query do
  select :x, :y, :z
  filter{(x &gt; 1) &amp; (y &gt; 2)}
  reverse :z
end</pre>

<p>Which is the same as:</p>

<pre>dataset = DB[:items].select(:x, :y, :z).filter{(x &gt; 1) &amp; (y &gt; 2)}.reverse(:z)</pre>

<p>Note that inside a call to query, you cannot call each, insert, update, or
delete (or any method that calls those), or <a
href="../Sequel.html">Sequel</a> will raise an error.</p>
            

            
            <div class="method-source-code" id="query-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/query.rb, line 34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">query</span>(&amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">copy</span> = <span class="ruby-identifier">clone</span>({})
  <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">QueryBlockCopy</span>)
  <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">instance_eval</span>(&amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">clone</span>(<span class="ruby-identifier">copy</span>.<span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- query-source -->
            
          </div>

          

          
        </div><!-- query-method -->

      
        <div id="quote_identifier_append-method" class="method-detail ">
          <a name="method-i-quote_identifier_append"></a>

          
          <div class="method-heading">
            <span class="method-name">quote_identifier_append</span><span
              class="method-args">(sql, name)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds quoting to identifiers (columns and tables). If identifiers are not
being quoted, returns name as a string.  If identifiers are being quoted
quote the name with quoted_identifier.</p>
            

            
            <div class="method-source-code" id="quote_identifier_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">quote_identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">name</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">LiteralString</span>)
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">name</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>)
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">input_identifier</span>(<span class="ruby-identifier">name</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">quote_identifiers?</span>
      <span class="ruby-identifier">quoted_identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">name</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">name</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- quote_identifier_append-source -->
            
          </div>

          

          
        </div><!-- quote_identifier_append-method -->

      
        <div id="quote_schema_table_append-method" class="method-detail ">
          <a name="method-i-quote_schema_table_append"></a>

          
          <div class="method-heading">
            <span class="method-name">quote_schema_table_append</span><span
              class="method-args">(sql, table)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Separates the schema from the table and returns a string with them quoted
(if quoting identifiers)</p>
            

            
            <div class="method-source-code" id="quote_schema_table_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 623</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">quote_schema_table_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table</span>)
  <span class="ruby-identifier">schema</span>, <span class="ruby-identifier">table</span> = <span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">table</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">schema</span>
    <span class="ruby-identifier">quote_identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">schema</span>)
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">DOT</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">quote_identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">table</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- quote_schema_table_append-source -->
            
          </div>

          

          
        </div><!-- quote_schema_table_append-method -->

      
        <div id="quoted_identifier_append-method" class="method-detail ">
          <a name="method-i-quoted_identifier_append"></a>

          
          <div class="method-heading">
            <span class="method-name">quoted_identifier_append</span><span
              class="method-args">(sql, name)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method quotes the given name with the <a href="SQL.html">SQL</a>
standard double quote.  should be overridden by subclasses to provide
quoting not matching the <a href="SQL.html">SQL</a> standard, such as
backtick (used by <a href="MySQL.html">MySQL</a> and <a
href="SQLite.html">SQLite</a>).</p>
            

            
            <div class="method-source-code" id="quoted_identifier_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 635</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">quoted_identifier_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">QUOTE</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-constant">QUOTE_RE</span>, <span class="ruby-constant">DOUBLE_QUOTE</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">QUOTE</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- quoted_identifier_append-source -->
            
          </div>

          

          
        </div><!-- quoted_identifier_append-method -->

      
        <div id="schema_and_table-method" class="method-detail ">
          <a name="method-i-schema_and_table"></a>

          
          <div class="method-heading">
            <span class="method-name">schema_and_table</span><span
              class="method-args">(table_name)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Split the schema information from the table</p>
            

            
            <div class="method-source-code" id="schema_and_table-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 640</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">table_name</span>)
  <span class="ruby-identifier">sch</span> = <span class="ruby-identifier">db</span>.<span class="ruby-identifier">default_schema</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">db</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">table_name</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>
    <span class="ruby-identifier">s</span>, <span class="ruby-identifier">t</span>, <span class="ruby-identifier">a</span> = <span class="ruby-identifier">split_symbol</span>(<span class="ruby-identifier">table_name</span>)
    [<span class="ruby-identifier">s</span><span class="ruby-operator">||</span><span class="ruby-identifier">sch</span>, <span class="ruby-identifier">t</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>
    [<span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">table</span>, <span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">column</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Identifier</span>
    [<span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">value</span>]
  <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
    [<span class="ruby-identifier">sch</span>, <span class="ruby-identifier">table_name</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">'table_name should be a Symbol, SQL::QualifiedIdentifier, SQL::Identifier, or String'</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- schema_and_table-source -->
            
          </div>

          

          
        </div><!-- schema_and_table-method -->

      
        <div id="select_remove-method" class="method-detail ">
          <a name="method-i-select_remove"></a>

          
          <div class="method-heading">
            <span class="method-name">select_remove</span><span
              class="method-args">(*cols)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Remove columns from the list of selected columns.  If any of the currently
selected columns use expressions/aliases, this will remove selected columns
with the given aliases.  It will also remove entries from the selection
that match exactly:</p>

<pre># Assume columns a, b, and c in items table
DB[:items] # SELECT * FROM items
DB[:items].select_remove(:c) # SELECT a, b FROM items
DB[:items].select(:a, :b___c, :c___b).select_remove(:c) # SELECT a, c AS b FROM items
DB[:items].select(:a, :b___c, :c___b).select_remove(:c___b) # SELECT a, b AS c FROM items</pre>

<p>Note that there are a few cases where this method may not work correctly:</p>
<ul><li>
<p>This dataset joins multiple tables and does not have an existing explicit
selection. In this case, the code will currently use unqualified column
names for all columns the dataset returns, except for the columns given.</p>
</li><li>
<p>This dataset has an existing explicit selection containing an item that
returns multiple database columns (e.g. Sequel.expr(:table).*,
Sequel.lit('column1, column2')).  In this case, the behavior is undefined
and this method should not be used.</p>
</li></ul>

<p>There may be other cases where this method does not work correctly, use it
with caution.</p>
            

            
            <div class="method-source-code" id="select_remove-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/select_remove.rb, line 31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">select_remove</span>(*<span class="ruby-identifier">cols</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sel</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:select</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">sel</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">select</span>(*(<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">sel</span>).<span class="ruby-identifier">reject</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span>, <span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">c</span>)}.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span>, <span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>} <span class="ruby-operator">-</span> <span class="ruby-identifier">cols</span>))
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">select</span>(*(<span class="ruby-identifier">columns</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">cols</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- select_remove-source -->
            
          </div>

          

          
        </div><!-- select_remove-method -->

      
        <div id="subscript_sql_append-method" class="method-detail ">
          <a name="method-i-subscript_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">subscript_sql_append</span><span
              class="method-args">(sql, s)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="SQL.html">SQL</a> fragment for specifying subscripts (<a
href="SQL.html">SQL</a> array accesses)</p>
            

            
            <div class="method-source-code" id="subscript_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 658</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">subscript_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">s</span>)
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">s</span>.<span class="ruby-identifier">f</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">BRACKET_OPEN</span>
  <span class="ruby-identifier">expression_list_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">s</span>.<span class="ruby-identifier">sub</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">BRACKET_CLOSE</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- subscript_sql_append-source -->
            
          </div>

          

          
        </div><!-- subscript_sql_append-method -->

      
        <div id="to_dot-method" class="method-detail ">
          <a name="method-i-to_dot"></a>

          
          <div class="method-heading">
            <span class="method-name">to_dot</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a string that can be processed by the <tt>dot</tt> program (included
with graphviz) in order to see a visualization of the dataset's abstract
syntax tree.</p>
            

            
            <div class="method-source-code" id="to_dot-source">
<pre>
<span class="ruby-comment"># File lib/sequel/extensions/to_dot.rb, line 149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_dot</span>
  <span class="ruby-constant">ToDot</span>.<span class="ruby-identifier">output</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_dot-source -->
            
          </div>

          

          
        </div><!-- to_dot-method -->

      
        <div id="window_function_sql_append-method" class="method-detail ">
          <a name="method-i-window_function_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">window_function_sql_append</span><span
              class="method-args">(sql, function, window)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The <a href="SQL.html">SQL</a> fragment for the given window function's
function and window.</p>
            

            
            <div class="method-source-code" id="window_function_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 707</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">window_function_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">function</span>, <span class="ruby-identifier">window</span>)
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">function</span>)
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">OVER</span>
  <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">window</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- window_function_sql_append-source -->
            
          </div>

          

          
        </div><!-- window_function_sql_append-method -->

      
        <div id="window_sql_append-method" class="method-detail ">
          <a name="method-i-window_sql_append"></a>

          
          <div class="method-heading">
            <span class="method-name">window_sql_append</span><span
              class="method-args">(sql, opts)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The <a href="SQL.html">SQL</a> fragment for the given window's options.</p>
            

            
            <div class="method-source-code" id="window_sql_append-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 666</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">window_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Error</span>, <span class="ruby-string">'This dataset does not support window functions'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">supports_window_functions?</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_OPEN</span>
  <span class="ruby-identifier">window</span>, <span class="ruby-identifier">part</span>, <span class="ruby-identifier">order</span>, <span class="ruby-identifier">frame</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:window</span>, <span class="ruby-value">:partition</span>, <span class="ruby-value">:order</span>, <span class="ruby-value">:frame</span>)
  <span class="ruby-identifier">space</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">space_s</span> = <span class="ruby-constant">SPACE</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">window</span>
    <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">window</span>)
    <span class="ruby-identifier">space</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">space_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">space</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PARTITION_BY</span>
    <span class="ruby-identifier">expression_list_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-constant">Array</span>(<span class="ruby-identifier">part</span>))
    <span class="ruby-identifier">space</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">order</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">space_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">space</span>
    <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">ORDER_BY_NS</span>
    <span class="ruby-identifier">expression_list_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-constant">Array</span>(<span class="ruby-identifier">order</span>))
    <span class="ruby-identifier">space</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">frame</span>
    <span class="ruby-keyword">when</span> <span class="ruby-keyword">nil</span>
      <span class="ruby-comment"># nothing</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:all</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">space_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">space</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">FRAME_ALL</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:rows</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">space_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">space</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">FRAME_ROWS</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">space_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">space</span>
      <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">frame</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;invalid window frame clause, should be :all, :rows, a string, or nil&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">sql</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">PAREN_CLOSE</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- window_sql_append-source -->
            
          </div>

          

          
        </div><!-- window_sql_append-method -->

      
      </div><!-- public-instance-method-details -->
    
      <div id="protected-instance-method-details" class="method-section section">
        <h3 class="section-header">Protected Instance Methods</h3>

      
        <div id="_insert_sql-method" class="method-detail ">
          <a name="method-i-_insert_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">_insert_sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Formats in <a href="Dataset.html#INSERT">INSERT</a> statement using the
stored columns and values.</p>
            

            
            <div class="method-source-code" id="_insert_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 716</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">_insert_sql</span>
  <span class="ruby-identifier">clause_sql</span>(<span class="ruby-value">:insert</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- _insert_sql-source -->
            
          </div>

          

          
        </div><!-- _insert_sql-method -->

      
        <div id="_update_sql-method" class="method-detail ">
          <a name="method-i-_update_sql"></a>

          
          <div class="method-heading">
            <span class="method-name">_update_sql</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Formats an <a href="Dataset.html#UPDATE">UPDATE</a> statement using the
stored values.</p>
            

            
            <div class="method-source-code" id="_update_sql-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 721</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">_update_sql</span>
  <span class="ruby-identifier">clause_sql</span>(<span class="ruby-value">:update</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- _update_sql-source -->
            
          </div>

          

          
        </div><!-- _update_sql-method -->

      
        <div id="compound_from_self-method" class="method-detail ">
          <a name="method-i-compound_from_self"></a>

          
          <div class="method-heading">
            <span class="method-name">compound_from_self</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Return a <a href="Dataset.html#method-i-from_self">from_self</a> dataset if
an order or limit is specified, so it works as expected with UNION, EXCEPT,
and INTERSECT clauses.</p>
            

            
            <div class="method-source-code" id="compound_from_self-source">
<pre>
<span class="ruby-comment"># File lib/sequel/dataset/sql.rb, line 727</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compound_from_self</span>
  (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:limit</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:order</span>]) <span class="ruby-operator">?</span> <span class="ruby-identifier">from_self</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- compound_from_self-source -->
            
          </div>

          

          
        </div><!-- compound_from_self-method -->

      
      </div><!-- protected-instance-method-details -->
    
    </div><!-- 9+-+Internal+Methods+relating+to+SQL+Creation -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

